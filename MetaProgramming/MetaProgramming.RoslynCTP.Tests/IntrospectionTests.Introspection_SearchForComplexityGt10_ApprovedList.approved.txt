[
  [
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "exoticComparisonExpression",
      "SourcesSample": "public void exoticComparisonExpression() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:224:2: ( ^( LIKE expr expr likeEscape ) | ^( NOT_LIKE expr expr likeEscape ) | ^( BETWEEN expr expr expr ) | ^( NOT_BETWEEN expr expr expr ) | ^( IN expr inList ) | ^( NOT_IN expr inList ) | ^( EXISTS quantified ) | ^( IS_NULL expr ) | ^( IS_NOT_NULL expr ) )\r\n            int alt46 = 9;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case LIKE:\r\n            \t{\r\n                alt46 = 1;\r\n                }\r\n                break;\r\n            case NOT_LIKE:\r\n            \t{\r\n                alt46 = 2;\r\n                }\r\n                break;\r\n            case BETWEEN:\r\n            \t{\r\n                alt46 = 3;\r\n                }\r\n                break;\r\n            case NOT_BETWEEN:\r\n            \t{\r\n                alt46 = 4;\r\n                }\r\n                break;\r\n            case IN:\r\n            \t{\r\n                alt46 = 5;\r\n                }\r\n                break;\r\n            case NOT_IN:\r\n            \t{\r\n                alt46 = 6;\r\n                }\r\n                break;\r\n            case EXISTS:\r\n            \t{\r\n                alt46 = 7;\r\n                }\r\n                break;\r\n            case IS_NULL:\r\n            \t{\r\n                alt46 = 8;\r\n                }\r\n                break;\r\n            case IS_NOT_NULL:\r\n            \t{\r\n                alt46 = 9;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t    NoViableAltException nvae_d46s0 =\r\n            \t        new NoViableAltException(\"\", 46, 0, input);\r\n\r\n            \t    throw nvae_d46s0;\r\n            }\r\n\r\n            switch (alt46) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:224:4: ^( LIKE expr expr likeEscape )\r\n                    {\r\n                    \tMatch(input,LIKE,FOLLOW_LIKE_in_exoticComparisonExpression1167); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1169);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" like \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1173);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_likeEscape_in_exoticComparisonExpression1175);\r\n                    \tlikeEscape();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:225:4: ^( NOT_LIKE expr expr likeEscape )\r\n                    {\r\n                    \tMatch(input,NOT_LIKE,FOLLOW_NOT_LIKE_in_exoticComparisonExpression1183); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1185);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" not like \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1189);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_likeEscape_in_exoticComparisonExpression1191);\r\n                    \tlikeEscape();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:226:4: ^( BETWEEN expr expr expr )\r\n                    {\r\n                    \tMatch(input,BETWEEN,FOLLOW_BETWEEN_in_exoticComparisonExpression1198); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1200);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" between \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1204);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" and \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1208);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // SqlGenerator.g:227:4: ^( NOT_BETWEEN expr expr expr )\r\n                    {\r\n                    \tMatch(input,NOT_BETWEEN,FOLLOW_NOT_BETWEEN_in_exoticComparisonExpression1215); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1217);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" not between \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1221);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" and \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1225);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 5 :\r\n                    // SqlGenerator.g:228:4: ^( IN expr inList )\r\n                    {\r\n                    \tMatch(input,IN,FOLLOW_IN_in_exoticComparisonExpression1232); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1234);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" in\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_inList_in_exoticComparisonExpression1238);\r\n                    \tinList();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 6 :\r\n                    // SqlGenerator.g:229:4: ^( NOT_IN expr inList )\r\n                    {\r\n                    \tMatch(input,NOT_IN,FOLLOW_NOT_IN_in_exoticComparisonExpression1246); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1248);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" not in \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_inList_in_exoticComparisonExpression1252);\r\n                    \tinList();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 7 :\r\n                    // SqlGenerator.g:230:4: ^( EXISTS quantified )\r\n                    {\r\n                    \tMatch(input,EXISTS,FOLLOW_EXISTS_in_exoticComparisonExpression1260); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   OptionalSpace(); Out(\"exists \"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_quantified_in_exoticComparisonExpression1264);\r\n                    \tquantified();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 8 :\r\n                    // SqlGenerator.g:231:4: ^( IS_NULL expr )\r\n                    {\r\n                    \tMatch(input,IS_NULL,FOLLOW_IS_NULL_in_exoticComparisonExpression1272); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1274);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" is null\"); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 9 :\r\n                    // SqlGenerator.g:232:4: ^( IS_NOT_NULL expr )\r\n                    {\r\n                    \tMatch(input,IS_NOT_NULL,FOLLOW_IS_NOT_NULL_in_exoticComparisonExpression1283); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_exoticComparisonExpression1285);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" is not null\"); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 61,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 3457
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "caseExpr",
      "SourcesSample": "public void caseExpr() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:333:2: ( ^( CASE ( ^( WHEN booleanExpr[false] expr ) )+ ( ^( ELSE expr ) )? ) | ^( CASE2 expr ( ^( WHEN expr expr ) )+ ( ^( ELSE expr ) )? ) )\r\n            int alt65 = 2;\r\n            int LA65_0 = input.LA(1);\r\n\r\n            if ( (LA65_0 == CASE) )\r\n            {\r\n                alt65 = 1;\r\n            }\r\n            else if ( (LA65_0 == CASE2) )\r\n            {\r\n                alt65 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d65s0 =\r\n                    new NoViableAltException(\"\", 65, 0, input);\r\n\r\n                throw nvae_d65s0;\r\n            }\r\n            switch (alt65) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:333:4: ^( CASE ( ^( WHEN booleanExpr[false] expr ) )+ ( ^( ELSE expr ) )? )\r\n                    {\r\n                    \tMatch(input,CASE,FOLLOW_CASE_in_caseExpr1860); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"case\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t// SqlGenerator.g:334:3: ( ^( WHEN booleanExpr[false] expr ) )+\r\n                    \tint cnt61 = 0;\r\n                    \tdo \r\n                    \t{\r\n                    \t    int alt61 = 2;\r\n                    \t    int LA61_0 = input.LA(1);\r\n\r\n                    \t    if ( (LA61_0 == WHEN) )\r\n                    \t    {\r\n                    \t        alt61 = 1;\r\n                    \t    }\r\n\r\n\r\n                    \t    switch (alt61) \r\n                    \t\t{\r\n                    \t\t\tcase 1 :\r\n                    \t\t\t    // SqlGenerator.g:334:5: ^( WHEN booleanExpr[false] expr )\r\n                    \t\t\t    {\r\n                    \t\t\t    \tMatch(input,WHEN,FOLLOW_WHEN_in_caseExpr1870); if (state.failed) return ;\r\n\r\n                    \t\t\t    \tif ( (state.backtracking==0) )\r\n                    \t\t\t    \t{\r\n                    \t\t\t    \t   Out( \" when \"); \r\n                    \t\t\t    \t}\r\n\r\n                    \t\t\t    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t\t\t    \tPushFollow(FOLLOW_booleanExpr_in_caseExpr1874);\r\n                    \t\t\t    \tbooleanExpr(false);\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n                    \t\t\t    \tif (state.failed) return ;\r\n                    \t\t\t    \tif ( (state.backtracking==0) )\r\n                    \t\t\t    \t{\r\n                    \t\t\t    \t   Out(\" then \"); \r\n                    \t\t\t    \t}\r\n                    \t\t\t    \tPushFollow(FOLLOW_expr_in_caseExpr1879);\r\n                    \t\t\t    \texpr();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n                    \t\t\t    \tif (state.failed) return ;\r\n\r\n                    \t\t\t    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    \t\t\t    }\r\n                    \t\t\t    break;\r\n\r\n                    \t\t\tdefault:\r\n                    \t\t\t    if ( cnt61 >= 1 ) goto loop61;\r\n                    \t\t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                    \t\t            EarlyExitException eee61 =\r\n                    \t\t                new EarlyExitException(61, input);\r\n                    \t\t            throw eee61;\r\n                    \t    }\r\n                    \t    cnt61++;\r\n                    \t} while (true);\r\n\r\n                    \tloop61:\r\n                    \t\t;\t// Stops C# compiler whining that label 'loop61' has no statements\r\n\r\n                    \t// SqlGenerator.g:335:3: ( ^( ELSE expr ) )?\r\n                    \tint alt62 = 2;\r\n                    \tint LA62_0 = input.LA(1);\r\n\r\n                    \tif ( (LA62_0 == ELSE) )\r\n                    \t{\r\n                    \t    alt62 = 1;\r\n                    \t}\r\n                    \tswitch (alt62) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // SqlGenerator.g:335:5: ^( ELSE expr )\r\n                    \t        {\r\n                    \t        \tMatch(input,ELSE,FOLLOW_ELSE_in_caseExpr1891); if (state.failed) return ;\r\n\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n                    \t        \t   Out(\" else \"); \r\n                    \t        \t}\r\n\r\n                    \t        \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t        \tPushFollow(FOLLOW_expr_in_caseExpr1895);\r\n                    \t        \texpr();\r\n                    \t        \tstate.followingStackPointer--;\r\n                    \t        \tif (state.failed) return ;\r\n\r\n                    \t        \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" end\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:337:4: ^( CASE2 expr ( ^( WHEN expr expr ) )+ ( ^( ELSE expr ) )? )\r\n                    {\r\n                    \tMatch(input,CASE2,FOLLOW_CASE2_in_caseExpr1911); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"case \"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_caseExpr1915);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \t// SqlGenerator.g:338:3: ( ^( WHEN expr expr ) )+\r\n                    \tint cnt63 = 0;\r\n                    \tdo \r\n                    \t{\r\n                    \t    int alt63 = 2;\r\n                    \t    int LA63_0 = input.LA(1);\r\n\r\n                    \t    if ( (LA63_0 == WHEN) )\r\n                    \t    {\r\n                    \t        alt63 = 1;\r\n                    \t    }\r\n\r\n\r\n                    \t    switch (alt63) \r\n                    \t\t{\r\n                    \t\t\tcase 1 :\r\n                    \t\t\t    // SqlGenerator.g:338:5: ^( WHEN expr expr )\r\n                    \t\t\t    {\r\n                    \t\t\t    \tMatch(input,WHEN,FOLLOW_WHEN_in_caseExpr1922); if (state.failed) return ;\r\n\r\n                    \t\t\t    \tif ( (state.backtracking==0) )\r\n                    \t\t\t    \t{\r\n                    \t\t\t    \t   Out( \" when \"); \r\n                    \t\t\t    \t}\r\n\r\n                    \t\t\t    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t\t\t    \tPushFollow(FOLLOW_expr_in_caseExpr1926);\r\n                    \t\t\t    \texpr();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n                    \t\t\t    \tif (state.failed) return ;\r\n                    \t\t\t    \tif ( (state.backtracking==0) )\r\n                    \t\t\t    \t{\r\n                    \t\t\t    \t   Out(\" then \"); \r\n                    \t\t\t    \t}\r\n                    \t\t\t    \tPushFollow(FOLLOW_expr_in_caseExpr1930);\r\n                    \t\t\t    \texpr();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n                    \t\t\t    \tif (state.failed) return ;\r\n\r\n                    \t\t\t    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    \t\t\t    }\r\n                    \t\t\t    break;\r\n\r\n                    \t\t\tdefault:\r\n                    \t\t\t    if ( cnt63 >= 1 ) goto loop63;\r\n                    \t\t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                    \t\t            EarlyExitException eee63 =\r\n                    \t\t                new EarlyExitException(63, input);\r\n                    \t\t            throw eee63;\r\n                    \t    }\r\n                    \t    cnt63++;\r\n                    \t} while (true);\r\n\r\n                    \tloop63:\r\n                    \t\t;\t// Stops C# compiler whining that label 'loop63' has no statements\r\n\r\n                    \t// SqlGenerator.g:339:3: ( ^( ELSE expr ) )?\r\n                    \tint alt64 = 2;\r\n                    \tint LA64_0 = input.LA(1);\r\n\r\n                    \tif ( (LA64_0 == ELSE) )\r\n                    \t{\r\n                    \t    alt64 = 1;\r\n                    \t}\r\n                    \tswitch (alt64) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // SqlGenerator.g:339:5: ^( ELSE expr )\r\n                    \t        {\r\n                    \t        \tMatch(input,ELSE,FOLLOW_ELSE_in_caseExpr1942); if (state.failed) return ;\r\n\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n                    \t        \t   Out(\" else \"); \r\n                    \t        \t}\r\n\r\n                    \t        \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t        \tPushFollow(FOLLOW_expr_in_caseExpr1946);\r\n                    \t        \texpr();\r\n                    \t        \tstate.followingStackPointer--;\r\n                    \t        \tif (state.failed) return ;\r\n\r\n                    \t        \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" end\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 54,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 5223
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "selectStatement",
      "SourcesSample": "public void selectStatement() // throws RecognitionException [1]\r\n    {   \r\n        SqlGenerator.limitValue_return si = default(SqlGenerator.limitValue_return);\r\n\r\n        SqlGenerator.limitValue_return ti = default(SqlGenerator.limitValue_return);\r\n\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:35:2: ( ^( SELECT selectClause from ( ^( WHERE whereExpr ) )? ( ^( GROUP groupExprs ) )? ( ^( HAVING booleanExpr[false] ) )? ( ^( ORDER orderExprs ) )? ( ^( SKIP si= limitValue ) )? ( ^( TAKE ti= limitValue ) )? ) )\r\n            // SqlGenerator.g:35:4: ^( SELECT selectClause from ( ^( WHERE whereExpr ) )? ( ^( GROUP groupExprs ) )? ( ^( HAVING booleanExpr[false] ) )? ( ^( ORDER orderExprs ) )? ( ^( SKIP si= limitValue ) )? ( ^( TAKE ti= limitValue ) )? )\r\n            {\r\n            \tMatch(input,SELECT,FOLLOW_SELECT_in_selectStatement84); if (state.failed) return ;\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   StartQuery(); Out(\"select \"); \r\n            \t}\r\n\r\n            \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \tPushFollow(FOLLOW_selectClause_in_selectStatement90);\r\n            \tselectClause();\r\n            \tstate.followingStackPointer--;\r\n            \tif (state.failed) return ;\r\n            \tPushFollow(FOLLOW_from_in_selectStatement94);\r\n            \tfrom();\r\n            \tstate.followingStackPointer--;\r\n            \tif (state.failed) return ;\r\n            \t// SqlGenerator.g:38:3: ( ^( WHERE whereExpr ) )?\r\n            \tint alt2 = 2;\r\n            \tint LA2_0 = input.LA(1);\r\n\r\n            \tif ( (LA2_0 == WHERE) )\r\n            \t{\r\n            \t    alt2 = 1;\r\n            \t}\r\n            \tswitch (alt2) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:38:5: ^( WHERE whereExpr )\r\n            \t        {\r\n            \t        \tMatch(input,WHERE,FOLLOW_WHERE_in_selectStatement101); if (state.failed) return ;\r\n\r\n            \t        \tif ( (state.backtracking==0) )\r\n            \t        \t{\r\n            \t        \t   Out(\" where \"); \r\n            \t        \t}\r\n\r\n            \t        \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t        \tPushFollow(FOLLOW_whereExpr_in_selectStatement105);\r\n            \t        \twhereExpr();\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// SqlGenerator.g:39:3: ( ^( GROUP groupExprs ) )?\r\n            \tint alt3 = 2;\r\n            \tint LA3_0 = input.LA(1);\r\n\r\n            \tif ( (LA3_0 == GROUP) )\r\n            \t{\r\n            \t    alt3 = 1;\r\n            \t}\r\n            \tswitch (alt3) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:39:5: ^( GROUP groupExprs )\r\n            \t        {\r\n            \t        \tMatch(input,GROUP,FOLLOW_GROUP_in_selectStatement117); if (state.failed) return ;\r\n\r\n            \t        \tif ( (state.backtracking==0) )\r\n            \t        \t{\r\n            \t        \t   Out(\" group by \"); \r\n            \t        \t}\r\n\r\n            \t        \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t        \tPushFollow(FOLLOW_groupExprs_in_selectStatement121);\r\n            \t        \tgroupExprs();\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// SqlGenerator.g:40:3: ( ^( HAVING booleanExpr[false] ) )?\r\n            \tint alt4 = 2;\r\n            \tint LA4_0 = input.LA(1);\r\n\r\n            \tif ( (LA4_0 == HAVING) )\r\n            \t{\r\n            \t    alt4 = 1;\r\n            \t}\r\n            \tswitch (alt4) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:40:5: ^( HAVING booleanExpr[false] )\r\n            \t        {\r\n            \t        \tMatch(input,HAVING,FOLLOW_HAVING_in_selectStatement133); if (state.failed) return ;\r\n\r\n            \t        \tif ( (state.backtracking==0) )\r\n            \t        \t{\r\n            \t        \t   Out(\" having \"); \r\n            \t        \t}\r\n\r\n            \t        \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t        \tPushFollow(FOLLOW_booleanExpr_in_selectStatement137);\r\n            \t        \tbooleanExpr(false);\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// SqlGenerator.g:41:3: ( ^( ORDER orderExprs ) )?\r\n            \tint alt5 = 2;\r\n            \tint LA5_0 = input.LA(1);\r\n\r\n            \tif ( (LA5_0 == ORDER) )\r\n            \t{\r\n            \t    alt5 = 1;\r\n            \t}\r\n            \tswitch (alt5) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:41:5: ^( ORDER orderExprs )\r\n            \t        {\r\n            \t        \tMatch(input,ORDER,FOLLOW_ORDER_in_selectStatement149); if (state.failed) return ;\r\n\r\n            \t        \tif ( (state.backtracking==0) )\r\n            \t        \t{\r\n            \t        \t   Out(\" order by \"); \r\n            \t        \t}\r\n\r\n            \t        \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t        \tPushFollow(FOLLOW_orderExprs_in_selectStatement153);\r\n            \t        \torderExprs();\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// SqlGenerator.g:42:3: ( ^( SKIP si= limitValue ) )?\r\n            \tint alt6 = 2;\r\n            \tint LA6_0 = input.LA(1);\r\n\r\n            \tif ( (LA6_0 == SKIP) )\r\n            \t{\r\n            \t    alt6 = 1;\r\n            \t}\r\n            \tswitch (alt6) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:42:5: ^( SKIP si= limitValue )\r\n            \t        {\r\n            \t        \tMatch(input,SKIP,FOLLOW_SKIP_in_selectStatement165); if (state.failed) return ;\r\n\r\n            \t        \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t        \tPushFollow(FOLLOW_limitValue_in_selectStatement169);\r\n            \t        \tsi = limitValue();\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n            \t        \tif ( (state.backtracking==0) )\r\n            \t        \t{\r\n            \t        \t   Skip(((si != null) ? ((IASTNode)si.Start) : null)); \r\n            \t        \t}\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// SqlGenerator.g:43:3: ( ^( TAKE ti= limitValue ) )?\r\n            \tint alt7 = 2;\r\n            \tint LA7_0 = input.LA(1);\r\n\r\n            \tif ( (LA7_0 == TAKE) )\r\n            \t{\r\n            \t    alt7 = 1;\r\n            \t}\r\n            \tswitch (alt7) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:43:5: ^( TAKE ti= limitValue )\r\n            \t        {\r\n            \t        \tMatch(input,TAKE,FOLLOW_TAKE_in_selectStatement181); if (state.failed) return ;\r\n\r\n            \t        \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t        \tPushFollow(FOLLOW_limitValue_in_selectStatement185);\r\n            \t        \tti = limitValue();\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n            \t        \tif ( (state.backtracking==0) )\r\n            \t        \t{\r\n            \t        \t   Take(((ti != null) ? ((IASTNode)ti.Start) : null)); \r\n            \t        \t}\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   EndQuery(); \r\n            \t}\r\n\r\n            \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 50,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 460
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "binaryComparisonExpression",
      "SourcesSample": "public void binaryComparisonExpression() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:215:2: ( ^( EQ expr expr ) | ^( NE expr expr ) | ^( GT expr expr ) | ^( GE expr expr ) | ^( LT expr expr ) | ^( LE expr expr ) )\r\n            int alt45 = 6;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case EQ:\r\n            \t{\r\n                alt45 = 1;\r\n                }\r\n                break;\r\n            case NE:\r\n            \t{\r\n                alt45 = 2;\r\n                }\r\n                break;\r\n            case GT:\r\n            \t{\r\n                alt45 = 3;\r\n                }\r\n                break;\r\n            case GE:\r\n            \t{\r\n                alt45 = 4;\r\n                }\r\n                break;\r\n            case LT:\r\n            \t{\r\n                alt45 = 5;\r\n                }\r\n                break;\r\n            case LE:\r\n            \t{\r\n                alt45 = 6;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t    NoViableAltException nvae_d45s0 =\r\n            \t        new NoViableAltException(\"\", 45, 0, input);\r\n\r\n            \t    throw nvae_d45s0;\r\n            }\r\n\r\n            switch (alt45) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:215:4: ^( EQ expr expr )\r\n                    {\r\n                    \tMatch(input,EQ,FOLLOW_EQ_in_binaryComparisonExpression1082); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1084);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"=\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1088);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:216:4: ^( NE expr expr )\r\n                    {\r\n                    \tMatch(input,NE,FOLLOW_NE_in_binaryComparisonExpression1095); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1097);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"<>\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1101);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:217:4: ^( GT expr expr )\r\n                    {\r\n                    \tMatch(input,GT,FOLLOW_GT_in_binaryComparisonExpression1108); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1110);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\">\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1114);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // SqlGenerator.g:218:4: ^( GE expr expr )\r\n                    {\r\n                    \tMatch(input,GE,FOLLOW_GE_in_binaryComparisonExpression1121); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1123);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\">=\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1127);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 5 :\r\n                    // SqlGenerator.g:219:4: ^( LT expr expr )\r\n                    {\r\n                    \tMatch(input,LT,FOLLOW_LT_in_binaryComparisonExpression1134); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1136);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"<\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1140);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 6 :\r\n                    // SqlGenerator.g:220:4: ^( LE expr expr )\r\n                    {\r\n                    \tMatch(input,LE,FOLLOW_LE_in_binaryComparisonExpression1147); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1149);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"<=\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_binaryComparisonExpression1153);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 40,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 3253
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "selectAtom",
      "SourcesSample": "public SqlGenerator.selectAtom_return selectAtom() // throws RecognitionException [1]\r\n    {   \r\n        SqlGenerator.selectAtom_return retval = new SqlGenerator.selectAtom_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:166:2: ( ^( DOT ( . )* ) | ^( SQL_TOKEN ( . )* ) | ^( ALIAS_REF ( . )* ) | ^( SELECT_EXPR ( . )* ) )\r\n            int alt34 = 4;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case DOT:\r\n            \t{\r\n                alt34 = 1;\r\n                }\r\n                break;\r\n            case SQL_TOKEN:\r\n            \t{\r\n                alt34 = 2;\r\n                }\r\n                break;\r\n            case ALIAS_REF:\r\n            \t{\r\n                alt34 = 3;\r\n                }\r\n                break;\r\n            case SELECT_EXPR:\r\n            \t{\r\n                alt34 = 4;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return retval;}\r\n            \t    NoViableAltException nvae_d34s0 =\r\n            \t        new NoViableAltException(\"\", 34, 0, input);\r\n\r\n            \t    throw nvae_d34s0;\r\n            }\r\n\r\n            switch (alt34) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:166:4: ^( DOT ( . )* )\r\n                    {\r\n                    \tMatch(input,DOT,FOLLOW_DOT_in_selectAtom786); if (state.failed) return retval;\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \t    // SqlGenerator.g:166:10: ( . )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt30 = 2;\r\n                    \t        int LA30_0 = input.LA(1);\r\n\r\n                    \t        if ( ((LA30_0 >= ALL && LA30_0 <= BOGUS)) )\r\n                    \t        {\r\n                    \t            alt30 = 1;\r\n                    \t        }\r\n                    \t        else if ( (LA30_0 == UP) )\r\n                    \t        {\r\n                    \t            alt30 = 2;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt30) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:166:10: .\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tMatchAny(input); if (state.failed) return retval;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop30;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop30:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop30' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return retval;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:167:4: ^( SQL_TOKEN ( . )* )\r\n                    {\r\n                    \tMatch(input,SQL_TOKEN,FOLLOW_SQL_TOKEN_in_selectAtom796); if (state.failed) return retval;\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \t    // SqlGenerator.g:167:16: ( . )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt31 = 2;\r\n                    \t        int LA31_0 = input.LA(1);\r\n\r\n                    \t        if ( ((LA31_0 >= ALL && LA31_0 <= BOGUS)) )\r\n                    \t        {\r\n                    \t            alt31 = 1;\r\n                    \t        }\r\n                    \t        else if ( (LA31_0 == UP) )\r\n                    \t        {\r\n                    \t            alt31 = 2;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt31) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:167:16: .\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tMatchAny(input); if (state.failed) return retval;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop31;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop31:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop31' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return retval;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:168:4: ^( ALIAS_REF ( . )* )\r\n                    {\r\n                    \tMatch(input,ALIAS_REF,FOLLOW_ALIAS_REF_in_selectAtom806); if (state.failed) return retval;\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \t    // SqlGenerator.g:168:16: ( . )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt32 = 2;\r\n                    \t        int LA32_0 = input.LA(1);\r\n\r\n                    \t        if ( ((LA32_0 >= ALL && LA32_0 <= BOGUS)) )\r\n                    \t        {\r\n                    \t            alt32 = 1;\r\n                    \t        }\r\n                    \t        else if ( (LA32_0 == UP) )\r\n                    \t        {\r\n                    \t            alt32 = 2;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt32) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:168:16: .\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tMatchAny(input); if (state.failed) return retval;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop32;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop32:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop32' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return retval;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // SqlGenerator.g:169:4: ^( SELECT_EXPR ( . )* )\r\n                    {\r\n                    \tMatch(input,SELECT_EXPR,FOLLOW_SELECT_EXPR_in_selectAtom816); if (state.failed) return retval;\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \t    // SqlGenerator.g:169:18: ( . )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt33 = 2;\r\n                    \t        int LA33_0 = input.LA(1);\r\n\r\n                    \t        if ( ((LA33_0 >= ALL && LA33_0 <= BOGUS)) )\r\n                    \t        {\r\n                    \t            alt33 = 1;\r\n                    \t        }\r\n                    \t        else if ( (LA33_0 == UP) )\r\n                    \t        {\r\n                    \t            alt33 = 2;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt33) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:169:18: .\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tMatchAny(input); if (state.failed) return retval;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop33;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop33:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop33' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return retval;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 40,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 2304
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "DFA60_SpecialStateTransition",
      "SourcesSample": "protected internal int DFA60_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException\r\n    {\r\n            ITreeNodeStream input = (ITreeNodeStream)_input;\r\n    \tint _s = s;\r\n        switch ( s )\r\n        {\r\n               \tcase 0 : \r\n                   \tint LA60_1 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_1 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_1);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 1 : \r\n                   \tint LA60_2 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_2 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_2);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 2 : \r\n                   \tint LA60_3 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_3 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_3);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 3 : \r\n                   \tint LA60_4 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_4 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_4);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 4 : \r\n                   \tint LA60_5 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_5 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_5);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 5 : \r\n                   \tint LA60_6 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_6 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_6);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 6 : \r\n                   \tint LA60_7 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_7 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_7);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 7 : \r\n                   \tint LA60_8 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_8 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_8);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 8 : \r\n                   \tint LA60_9 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_9 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_9);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 9 : \r\n                   \tint LA60_10 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_10 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_10);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 10 : \r\n                   \tint LA60_11 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index60_11 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred4_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 12; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index60_11);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n        }\r\n        if (state.backtracking > 0) {state.failed = true; return -1;}\r\n        NoViableAltException nvae60 =\r\n            new NoViableAltException(dfa.Description, 60, _s, input);\r\n        dfa.Error(nvae60);\r\n        throw nvae60;\r\n    }",
      "nStatementSyntax": 36,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 6512
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "expr",
      "SourcesSample": "public SqlGenerator.expr_return expr() // throws RecognitionException [1]\r\n    {   \r\n        SqlGenerator.expr_return retval = new SqlGenerator.expr_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        SqlGenerator.expr_return e = default(SqlGenerator.expr_return);\r\n\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:249:2: ( simpleExpr | ^( VECTOR_EXPR (e= expr )* ) | parenSelect | ^( ANY quantified ) | ^( ALL quantified ) | ^( SOME quantified ) )\r\n            int alt51 = 6;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case COUNT:\r\n            case DOT:\r\n            case FALSE:\r\n            case NULL:\r\n            case TRUE:\r\n            case CASE:\r\n            case AGGREGATE:\r\n            case CASE2:\r\n            case INDEX_OP:\r\n            case METHOD_CALL:\r\n            case UNARY_MINUS:\r\n            case CONSTANT:\r\n            case NUM_INT:\r\n            case NUM_DOUBLE:\r\n            case NUM_DECIMAL:\r\n            case NUM_FLOAT:\r\n            case NUM_LONG:\r\n            case JAVA_CONSTANT:\r\n            case PARAM:\r\n            case BNOT:\r\n            case BOR:\r\n            case BXOR:\r\n            case BAND:\r\n            case PLUS:\r\n            case MINUS:\r\n            case STAR:\r\n            case DIV:\r\n            case QUOTED_String:\r\n            case IDENT:\r\n            case ALIAS_REF:\r\n            case SQL_TOKEN:\r\n            case NAMED_PARAM:\r\n            \t{\r\n                alt51 = 1;\r\n                }\r\n                break;\r\n            case VECTOR_EXPR:\r\n            \t{\r\n                alt51 = 2;\r\n                }\r\n                break;\r\n            case SELECT:\r\n            case UNION:\r\n            \t{\r\n                alt51 = 3;\r\n                }\r\n                break;\r\n            case ANY:\r\n            \t{\r\n                alt51 = 4;\r\n                }\r\n                break;\r\n            case ALL:\r\n            \t{\r\n                alt51 = 5;\r\n                }\r\n                break;\r\n            case SOME:\r\n            \t{\r\n                alt51 = 6;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return retval;}\r\n            \t    NoViableAltException nvae_d51s0 =\r\n            \t        new NoViableAltException(\"\", 51, 0, input);\r\n\r\n            \t    throw nvae_d51s0;\r\n            }\r\n\r\n            switch (alt51) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:249:4: simpleExpr\r\n                    {\r\n                    \tPushFollow(FOLLOW_simpleExpr_in_expr1372);\r\n                    \tsimpleExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:250:4: ^( VECTOR_EXPR (e= expr )* )\r\n                    {\r\n                    \tMatch(input,VECTOR_EXPR,FOLLOW_VECTOR_EXPR_in_expr1379); if (state.failed) return retval;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"(\"); \r\n                    \t}\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \t    // SqlGenerator.g:250:33: (e= expr )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt50 = 2;\r\n                    \t        int LA50_0 = input.LA(1);\r\n\r\n                    \t        if ( ((LA50_0 >= ALL && LA50_0 <= ANY) || LA50_0 == COUNT || LA50_0 == DOT || LA50_0 == FALSE || LA50_0 == NULL || LA50_0 == SELECT || LA50_0 == SOME || (LA50_0 >= TRUE && LA50_0 <= UNION) || LA50_0 == CASE || LA50_0 == AGGREGATE || LA50_0 == CASE2 || LA50_0 == INDEX_OP || LA50_0 == METHOD_CALL || LA50_0 == UNARY_MINUS || LA50_0 == VECTOR_EXPR || (LA50_0 >= CONSTANT && LA50_0 <= JAVA_CONSTANT) || LA50_0 == PARAM || (LA50_0 >= BNOT && LA50_0 <= DIV) || (LA50_0 >= QUOTED_String && LA50_0 <= IDENT) || LA50_0 == ALIAS_REF || LA50_0 == SQL_TOKEN || LA50_0 == NAMED_PARAM) )\r\n                    \t        {\r\n                    \t            alt50 = 1;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt50) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:250:34: e= expr\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tPushFollow(FOLLOW_expr_in_expr1386);\r\n                    \t    \t\t    \te = expr();\r\n                    \t    \t\t    \tstate.followingStackPointer--;\r\n                    \t    \t\t    \tif (state.failed) return retval;\r\n                    \t    \t\t    \tif ( (state.backtracking==0) )\r\n                    \t    \t\t    \t{\r\n                    \t    \t\t    \t   Separator(((e != null) ? ((IASTNode)e.Start) : null),\" , \"); \r\n                    \t    \t\t    \t}\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop50;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop50:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop50' has no statements\r\n\r\n                    \t    if ( (state.backtracking==0) )\r\n                    \t    {\r\n                    \t       Out(\")\"); \r\n                    \t    }\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return retval;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:251:4: parenSelect\r\n                    {\r\n                    \tPushFollow(FOLLOW_parenSelect_in_expr1401);\r\n                    \tparenSelect();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // SqlGenerator.g:252:4: ^( ANY quantified )\r\n                    {\r\n                    \tMatch(input,ANY,FOLLOW_ANY_in_expr1407); if (state.failed) return retval;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"any \"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \tPushFollow(FOLLOW_quantified_in_expr1411);\r\n                    \tquantified();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 5 :\r\n                    // SqlGenerator.g:253:4: ^( ALL quantified )\r\n                    {\r\n                    \tMatch(input,ALL,FOLLOW_ALL_in_expr1419); if (state.failed) return retval;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"all \"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \tPushFollow(FOLLOW_quantified_in_expr1423);\r\n                    \tquantified();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 6 :\r\n                    // SqlGenerator.g:254:4: ^( SOME quantified )\r\n                    {\r\n                    \tMatch(input,SOME,FOLLOW_SOME_in_expr1431); if (state.failed) return retval;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"some \"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \tPushFollow(FOLLOW_quantified_in_expr1435);\r\n                    \tquantified();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 32,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 3978
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "bitwiseExpr",
      "SourcesSample": "public void bitwiseExpr() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:308:2: ( ^( BAND expr nestedExpr ) | ^( BOR expr nestedExpr ) | ^( BXOR expr nestedExpr ) | ^( BNOT nestedExpr ) )\r\n            int alt57 = 4;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case BAND:\r\n            \t{\r\n                alt57 = 1;\r\n                }\r\n                break;\r\n            case BOR:\r\n            \t{\r\n                alt57 = 2;\r\n                }\r\n                break;\r\n            case BXOR:\r\n            \t{\r\n                alt57 = 3;\r\n                }\r\n                break;\r\n            case BNOT:\r\n            \t{\r\n                alt57 = 4;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t    NoViableAltException nvae_d57s0 =\r\n            \t        new NoViableAltException(\"\", 57, 0, input);\r\n\r\n            \t    throw nvae_d57s0;\r\n            }\r\n\r\n            switch (alt57) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:308:4: ^( BAND expr nestedExpr )\r\n                    {\r\n                    \tMatch(input,BAND,FOLLOW_BAND_in_bitwiseExpr1699); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_bitwiseExpr1701);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"&\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_nestedExpr_in_bitwiseExpr1705);\r\n                    \tnestedExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:309:4: ^( BOR expr nestedExpr )\r\n                    {\r\n                    \tMatch(input,BOR,FOLLOW_BOR_in_bitwiseExpr1712); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_bitwiseExpr1714);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"|\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_nestedExpr_in_bitwiseExpr1718);\r\n                    \tnestedExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:310:4: ^( BXOR expr nestedExpr )\r\n                    {\r\n                    \tMatch(input,BXOR,FOLLOW_BXOR_in_bitwiseExpr1725); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_bitwiseExpr1727);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"^\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_nestedExpr_in_bitwiseExpr1731);\r\n                    \tnestedExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // SqlGenerator.g:311:4: ^( BNOT nestedExpr )\r\n                    {\r\n                    \tMatch(input,BNOT,FOLLOW_BNOT_in_bitwiseExpr1738); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"~\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_nestedExpr_in_bitwiseExpr1742);\r\n                    \tnestedExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 27,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 4860
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "selectExpr",
      "SourcesSample": "public SqlGenerator.selectExpr_return selectExpr() // throws RecognitionException [1]\r\n    {   \r\n        SqlGenerator.selectExpr_return retval = new SqlGenerator.selectExpr_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        SqlGenerator.selectAtom_return e = default(SqlGenerator.selectAtom_return);\r\n\r\n        SqlGenerator.constant_return c = default(SqlGenerator.constant_return);\r\n\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:137:2: (e= selectAtom | count | ^( CONSTRUCTOR ( DOT | IDENT ) ( selectColumn )+ ) | methodCall | aggregate | c= constant | arithmeticExpr | parameter | selectStatement )\r\n            int alt25 = 9;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case DOT:\r\n            case ALIAS_REF:\r\n            case SQL_TOKEN:\r\n            case SELECT_EXPR:\r\n            \t{\r\n                alt25 = 1;\r\n                }\r\n                break;\r\n            case COUNT:\r\n            \t{\r\n                alt25 = 2;\r\n                }\r\n                break;\r\n            case CONSTRUCTOR:\r\n            \t{\r\n                alt25 = 3;\r\n                }\r\n                break;\r\n            case METHOD_CALL:\r\n            \t{\r\n                alt25 = 4;\r\n                }\r\n                break;\r\n            case AGGREGATE:\r\n            \t{\r\n                alt25 = 5;\r\n                }\r\n                break;\r\n            case FALSE:\r\n            case TRUE:\r\n            case CONSTANT:\r\n            case NUM_INT:\r\n            case NUM_DOUBLE:\r\n            case NUM_DECIMAL:\r\n            case NUM_FLOAT:\r\n            case NUM_LONG:\r\n            case JAVA_CONSTANT:\r\n            case QUOTED_String:\r\n            case IDENT:\r\n            \t{\r\n                alt25 = 6;\r\n                }\r\n                break;\r\n            case CASE:\r\n            case CASE2:\r\n            case UNARY_MINUS:\r\n            case BNOT:\r\n            case BOR:\r\n            case BXOR:\r\n            case BAND:\r\n            case PLUS:\r\n            case MINUS:\r\n            case STAR:\r\n            case DIV:\r\n            \t{\r\n                alt25 = 7;\r\n                }\r\n                break;\r\n            case PARAM:\r\n            case NAMED_PARAM:\r\n            \t{\r\n                alt25 = 8;\r\n                }\r\n                break;\r\n            case SELECT:\r\n            \t{\r\n                alt25 = 9;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return retval;}\r\n            \t    NoViableAltException nvae_d25s0 =\r\n            \t        new NoViableAltException(\"\", 25, 0, input);\r\n\r\n            \t    throw nvae_d25s0;\r\n            }\r\n\r\n            switch (alt25) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:137:4: e= selectAtom\r\n                    {\r\n                    \tPushFollow(FOLLOW_selectAtom_in_selectExpr630);\r\n                    \te = selectAtom();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(((e != null) ? ((IASTNode)e.Start) : null)); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:138:4: count\r\n                    {\r\n                    \tPushFollow(FOLLOW_count_in_selectExpr637);\r\n                    \tcount();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:139:4: ^( CONSTRUCTOR ( DOT | IDENT ) ( selectColumn )+ )\r\n                    {\r\n                    \tMatch(input,CONSTRUCTOR,FOLLOW_CONSTRUCTOR_in_selectExpr643); if (state.failed) return retval;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return retval;\r\n                    \tif ( input.LA(1) == DOT || input.LA(1) == IDENT ) \r\n                    \t{\r\n                    \t    input.Consume();\r\n                    \t    state.errorRecovery = false;state.failed = false;\r\n                    \t}\r\n                    \telse \r\n                    \t{\r\n                    \t    if ( state.backtracking > 0 ) {state.failed = true; return retval;}\r\n                    \t    MismatchedSetException mse = new MismatchedSetException(null,input);\r\n                    \t    throw mse;\r\n                    \t}\r\n\r\n                    \t// SqlGenerator.g:139:32: ( selectColumn )+\r\n                    \tint cnt24 = 0;\r\n                    \tdo \r\n                    \t{\r\n                    \t    int alt24 = 2;\r\n                    \t    int LA24_0 = input.LA(1);\r\n\r\n                    \t    if ( (LA24_0 == COUNT || LA24_0 == DOT || LA24_0 == FALSE || LA24_0 == SELECT || LA24_0 == TRUE || LA24_0 == CASE || LA24_0 == AGGREGATE || (LA24_0 >= CONSTRUCTOR && LA24_0 <= CASE2) || LA24_0 == METHOD_CALL || LA24_0 == UNARY_MINUS || (LA24_0 >= CONSTANT && LA24_0 <= JAVA_CONSTANT) || LA24_0 == PARAM || (LA24_0 >= BNOT && LA24_0 <= DIV) || (LA24_0 >= QUOTED_String && LA24_0 <= IDENT) || LA24_0 == ALIAS_REF || LA24_0 == SQL_TOKEN || LA24_0 == SELECT_EXPR || LA24_0 == NAMED_PARAM) )\r\n                    \t    {\r\n                    \t        alt24 = 1;\r\n                    \t    }\r\n\r\n\r\n                    \t    switch (alt24) \r\n                    \t\t{\r\n                    \t\t\tcase 1 :\r\n                    \t\t\t    // SqlGenerator.g:139:34: selectColumn\r\n                    \t\t\t    {\r\n                    \t\t\t    \tPushFollow(FOLLOW_selectColumn_in_selectExpr655);\r\n                    \t\t\t    \tselectColumn();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n                    \t\t\t    \tif (state.failed) return retval;\r\n\r\n                    \t\t\t    }\r\n                    \t\t\t    break;\r\n\r\n                    \t\t\tdefault:\r\n                    \t\t\t    if ( cnt24 >= 1 ) goto loop24;\r\n                    \t\t\t    if ( state.backtracking > 0 ) {state.failed = true; return retval;}\r\n                    \t\t            EarlyExitException eee24 =\r\n                    \t\t                new EarlyExitException(24, input);\r\n                    \t\t            throw eee24;\r\n                    \t    }\r\n                    \t    cnt24++;\r\n                    \t} while (true);\r\n\r\n                    \tloop24:\r\n                    \t\t;\t// Stops C# compiler whining that label 'loop24' has no statements\r\n\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // SqlGenerator.g:140:4: methodCall\r\n                    {\r\n                    \tPushFollow(FOLLOW_methodCall_in_selectExpr665);\r\n                    \tmethodCall();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 5 :\r\n                    // SqlGenerator.g:141:4: aggregate\r\n                    {\r\n                    \tPushFollow(FOLLOW_aggregate_in_selectExpr670);\r\n                    \taggregate();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 6 :\r\n                    // SqlGenerator.g:142:4: c= constant\r\n                    {\r\n                    \tPushFollow(FOLLOW_constant_in_selectExpr677);\r\n                    \tc = constant();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(((c != null) ? ((IASTNode)c.Start) : null)); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 7 :\r\n                    // SqlGenerator.g:143:4: arithmeticExpr\r\n                    {\r\n                    \tPushFollow(FOLLOW_arithmeticExpr_in_selectExpr684);\r\n                    \tarithmeticExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 8 :\r\n                    // SqlGenerator.g:144:4: parameter\r\n                    {\r\n                    \tPushFollow(FOLLOW_parameter_in_selectExpr689);\r\n                    \tparameter();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 9 :\r\n                    // SqlGenerator.g:147:4: selectStatement\r\n                    {\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"(\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_selectStatement_in_selectExpr698);\r\n                    \tselectStatement();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\")\"); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 27,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 1791
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "booleanOp",
      "SourcesSample": "public void booleanOp(bool parens) // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:197:2: ( ^( AND booleanExpr[true] booleanExpr[true] ) | ^( OR booleanExpr[false] booleanExpr[false] ) | ^( NOT booleanExpr[false] ) )\r\n            int alt42 = 3;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case AND:\r\n            \t{\r\n                alt42 = 1;\r\n                }\r\n                break;\r\n            case OR:\r\n            \t{\r\n                alt42 = 2;\r\n                }\r\n                break;\r\n            case NOT:\r\n            \t{\r\n                alt42 = 3;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t    NoViableAltException nvae_d42s0 =\r\n            \t        new NoViableAltException(\"\", 42, 0, input);\r\n\r\n            \t    throw nvae_d42s0;\r\n            }\r\n\r\n            switch (alt42) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:197:4: ^( AND booleanExpr[true] booleanExpr[true] )\r\n                    {\r\n                    \tMatch(input,AND,FOLLOW_AND_in_booleanOp968); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_booleanExpr_in_booleanOp970);\r\n                    \tbooleanExpr(true);\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" and \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_booleanExpr_in_booleanOp975);\r\n                    \tbooleanExpr(true);\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:198:4: ^( OR booleanExpr[false] booleanExpr[false] )\r\n                    {\r\n                    \tMatch(input,OR,FOLLOW_OR_in_booleanOp983); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   if (parens) Out(\"(\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_booleanExpr_in_booleanOp987);\r\n                    \tbooleanExpr(false);\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" or \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_booleanExpr_in_booleanOp992);\r\n                    \tbooleanExpr(false);\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   if (parens) Out(\")\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:199:4: ^( NOT booleanExpr[false] )\r\n                    {\r\n                    \tMatch(input,NOT,FOLLOW_NOT_in_booleanOp1002); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" not (\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_booleanExpr_in_booleanOp1006);\r\n                    \tbooleanExpr(false);\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\")\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 26,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 2936
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "fromTable",
      "SourcesSample": "public void fromTable() // throws RecognitionException [1]\r\n    {   \r\n        IASTNode a = null;\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:187:2: ( ^(a= FROM_FRAGMENT ( tableJoin[ a ] )* ) | ^(a= JOIN_FRAGMENT ( tableJoin[ a ] )* ) )\r\n            int alt38 = 2;\r\n            int LA38_0 = input.LA(1);\r\n\r\n            if ( (LA38_0 == FROM_FRAGMENT) )\r\n            {\r\n                alt38 = 1;\r\n            }\r\n            else if ( (LA38_0 == JOIN_FRAGMENT) )\r\n            {\r\n                alt38 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d38s0 =\r\n                    new NoViableAltException(\"\", 38, 0, input);\r\n\r\n                throw nvae_d38s0;\r\n            }\r\n            switch (alt38) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:187:4: ^(a= FROM_FRAGMENT ( tableJoin[ a ] )* )\r\n                    {\r\n                    \ta=(IASTNode)Match(input,FROM_FRAGMENT,FOLLOW_FROM_FRAGMENT_in_fromTable872); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(a); \r\n                    \t}\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t    // SqlGenerator.g:187:36: ( tableJoin[ a ] )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt36 = 2;\r\n                    \t        int LA36_0 = input.LA(1);\r\n\r\n                    \t        if ( (LA36_0 == FROM_FRAGMENT || LA36_0 == JOIN_FRAGMENT) )\r\n                    \t        {\r\n                    \t            alt36 = 1;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt36) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:187:37: tableJoin[ a ]\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tPushFollow(FOLLOW_tableJoin_in_fromTable878);\r\n                    \t    \t\t    \ttableJoin(a);\r\n                    \t    \t\t    \tstate.followingStackPointer--;\r\n                    \t    \t\t    \tif (state.failed) return ;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop36;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop36:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop36' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:188:4: ^(a= JOIN_FRAGMENT ( tableJoin[ a ] )* )\r\n                    {\r\n                    \ta=(IASTNode)Match(input,JOIN_FRAGMENT,FOLLOW_JOIN_FRAGMENT_in_fromTable893); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(a); \r\n                    \t}\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t    // SqlGenerator.g:188:36: ( tableJoin[ a ] )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt37 = 2;\r\n                    \t        int LA37_0 = input.LA(1);\r\n\r\n                    \t        if ( (LA37_0 == FROM_FRAGMENT || LA37_0 == JOIN_FRAGMENT) )\r\n                    \t        {\r\n                    \t            alt37 = 1;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt37) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:188:37: tableJoin[ a ]\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tPushFollow(FOLLOW_tableJoin_in_fromTable899);\r\n                    \t    \t\t    \ttableJoin(a);\r\n                    \t    \t\t    \tstate.followingStackPointer--;\r\n                    \t    \t\t    \tif (state.failed) return ;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop37;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop37:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop37' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n            if ( (state.backtracking==0) )\r\n            {\r\n\r\n                 FromFragmentSeparator(a);\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 24,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 2629
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "tableJoin",
      "SourcesSample": "public void tableJoin(IASTNode parent) // throws RecognitionException [1]\r\n    {   \r\n        IASTNode c = null;\r\n        IASTNode d = null;\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:192:2: ( ^(c= JOIN_FRAGMENT ( tableJoin[ c ] )* ) | ^(d= FROM_FRAGMENT ( tableJoin[ d ] )* ) )\r\n            int alt41 = 2;\r\n            int LA41_0 = input.LA(1);\r\n\r\n            if ( (LA41_0 == JOIN_FRAGMENT) )\r\n            {\r\n                alt41 = 1;\r\n            }\r\n            else if ( (LA41_0 == FROM_FRAGMENT) )\r\n            {\r\n                alt41 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d41s0 =\r\n                    new NoViableAltException(\"\", 41, 0, input);\r\n\r\n                throw nvae_d41s0;\r\n            }\r\n            switch (alt41) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:192:4: ^(c= JOIN_FRAGMENT ( tableJoin[ c ] )* )\r\n                    {\r\n                    \tc=(IASTNode)Match(input,JOIN_FRAGMENT,FOLLOW_JOIN_FRAGMENT_in_tableJoin922); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\" \"); Out(c); \r\n                    \t}\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t    // SqlGenerator.g:192:46: ( tableJoin[ c ] )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt39 = 2;\r\n                    \t        int LA39_0 = input.LA(1);\r\n\r\n                    \t        if ( (LA39_0 == FROM_FRAGMENT || LA39_0 == JOIN_FRAGMENT) )\r\n                    \t        {\r\n                    \t            alt39 = 1;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt39) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:192:47: tableJoin[ c ]\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tPushFollow(FOLLOW_tableJoin_in_tableJoin927);\r\n                    \t    \t\t    \ttableJoin(c);\r\n                    \t    \t\t    \tstate.followingStackPointer--;\r\n                    \t    \t\t    \tif (state.failed) return ;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop39;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop39:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop39' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:193:4: ^(d= FROM_FRAGMENT ( tableJoin[ d ] )* )\r\n                    {\r\n                    \td=(IASTNode)Match(input,FROM_FRAGMENT,FOLLOW_FROM_FRAGMENT_in_tableJoin943); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   NestedFromFragment(d,parent); \r\n                    \t}\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t    // SqlGenerator.g:193:58: ( tableJoin[ d ] )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt40 = 2;\r\n                    \t        int LA40_0 = input.LA(1);\r\n\r\n                    \t        if ( (LA40_0 == FROM_FRAGMENT || LA40_0 == JOIN_FRAGMENT) )\r\n                    \t        {\r\n                    \t            alt40 = 1;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt40) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:193:59: tableJoin[ d ]\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tPushFollow(FOLLOW_tableJoin_in_tableJoin948);\r\n                    \t    \t\t    \ttableJoin(d);\r\n                    \t    \t\t    \tstate.followingStackPointer--;\r\n                    \t    \t\t    \tif (state.failed) return ;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop40;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop40:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop40' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 23,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 2785
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "addrExpr",
      "SourcesSample": "public void addrExpr() // throws RecognitionException [1]\r\n    {   \r\n        IASTNode r = null;\r\n        IASTNode i = null;\r\n        IASTNode j = null;\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:370:2: ( ^(r= DOT . . ) | i= ALIAS_REF | ^(j= INDEX_OP ( . )* ) )\r\n            int alt73 = 3;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case DOT:\r\n            \t{\r\n                alt73 = 1;\r\n                }\r\n                break;\r\n            case ALIAS_REF:\r\n            \t{\r\n                alt73 = 2;\r\n                }\r\n                break;\r\n            case INDEX_OP:\r\n            \t{\r\n                alt73 = 3;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t    NoViableAltException nvae_d73s0 =\r\n            \t        new NoViableAltException(\"\", 73, 0, input);\r\n\r\n            \t    throw nvae_d73s0;\r\n            }\r\n\r\n            switch (alt73) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:370:4: ^(r= DOT . . )\r\n                    {\r\n                    \tr=(IASTNode)Match(input,DOT,FOLLOW_DOT_in_addrExpr2116); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tMatchAny(input); if (state.failed) return ;\r\n                    \tMatchAny(input); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(r); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:371:4: i= ALIAS_REF\r\n                    {\r\n                    \ti=(IASTNode)Match(input,ALIAS_REF,FOLLOW_ALIAS_REF_in_addrExpr2130); if (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(i); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:372:4: ^(j= INDEX_OP ( . )* )\r\n                    {\r\n                    \tj=(IASTNode)Match(input,INDEX_OP,FOLLOW_INDEX_OP_in_addrExpr2140); if (state.failed) return ;\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t    // SqlGenerator.g:372:17: ( . )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt72 = 2;\r\n                    \t        int LA72_0 = input.LA(1);\r\n\r\n                    \t        if ( ((LA72_0 >= ALL && LA72_0 <= BOGUS)) )\r\n                    \t        {\r\n                    \t            alt72 = 1;\r\n                    \t        }\r\n                    \t        else if ( (LA72_0 == UP) )\r\n                    \t        {\r\n                    \t            alt72 = 2;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt72) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:372:17: .\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tMatchAny(input); if (state.failed) return ;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop72;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop72:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop72' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n                    \t}\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(j); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 22,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 5892
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "DFA59_SpecialStateTransition",
      "SourcesSample": "protected internal int DFA59_SpecialStateTransition(DFA dfa, int s, IIntStream _input) //throws NoViableAltException\r\n    {\r\n            ITreeNodeStream input = (ITreeNodeStream)_input;\r\n    \tint _s = s;\r\n        switch ( s )\r\n        {\r\n               \tcase 0 : \r\n                   \tint LA59_1 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index59_1 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred2_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 7; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index59_1);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 1 : \r\n                   \tint LA59_2 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index59_2 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred2_SqlGenerator()) ) { s = 29; }\r\n\r\n                   \telse if ( (true) ) { s = 7; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index59_2);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 2 : \r\n                   \tint LA59_3 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index59_3 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred3_SqlGenerator()) ) { s = 30; }\r\n\r\n                   \telse if ( (true) ) { s = 7; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index59_3);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 3 : \r\n                   \tint LA59_4 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index59_4 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred3_SqlGenerator()) ) { s = 30; }\r\n\r\n                   \telse if ( (true) ) { s = 7; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index59_4);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 4 : \r\n                   \tint LA59_5 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index59_5 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred3_SqlGenerator()) ) { s = 30; }\r\n\r\n                   \telse if ( (true) ) { s = 7; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index59_5);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n               \tcase 5 : \r\n                   \tint LA59_6 = input.LA(1);\r\n\r\n                   \t \r\n                   \tint index59_6 = input.Index();\r\n                   \tinput.Rewind();\r\n                   \ts = -1;\r\n                   \tif ( (synpred3_SqlGenerator()) ) { s = 30; }\r\n\r\n                   \telse if ( (true) ) { s = 7; }\r\n\r\n                   \t \r\n                   \tinput.Seek(index59_6);\r\n                   \tif ( s >= 0 ) return s;\r\n                   \tbreak;\r\n        }\r\n        if (state.backtracking > 0) {state.failed = true; return -1;}\r\n        NoViableAltException nvae59 =\r\n            new NoViableAltException(dfa.Description, 59, _s, input);\r\n        dfa.Error(nvae59);\r\n        throw nvae59;\r\n    }",
      "nStatementSyntax": 21,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 6324
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "whereExpr",
      "SourcesSample": "public void whereExpr() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:108:2: ( filters ( thetaJoins )? ( booleanExpr[ true ] )? | thetaJoins ( booleanExpr[ true ] )? | booleanExpr[false] )\r\n            int alt19 = 3;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case FILTERS:\r\n            \t{\r\n                alt19 = 1;\r\n                }\r\n                break;\r\n            case THETA_JOINS:\r\n            \t{\r\n                alt19 = 2;\r\n                }\r\n                break;\r\n            case AND:\r\n            case BETWEEN:\r\n            case EXISTS:\r\n            case IN:\r\n            case LIKE:\r\n            case NOT:\r\n            case OR:\r\n            case IS_NOT_NULL:\r\n            case IS_NULL:\r\n            case METHOD_CALL:\r\n            case NOT_BETWEEN:\r\n            case NOT_IN:\r\n            case NOT_LIKE:\r\n            case EQ:\r\n            case NE:\r\n            case LT:\r\n            case GT:\r\n            case LE:\r\n            case GE:\r\n            case SQL_TOKEN:\r\n            \t{\r\n                alt19 = 3;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t    NoViableAltException nvae_d19s0 =\r\n            \t        new NoViableAltException(\"\", 19, 0, input);\r\n\r\n            \t    throw nvae_d19s0;\r\n            }\r\n\r\n            switch (alt19) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:108:4: filters ( thetaJoins )? ( booleanExpr[ true ] )?\r\n                    {\r\n                    \tPushFollow(FOLLOW_filters_in_whereExpr465);\r\n                    \tfilters();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \t// SqlGenerator.g:109:3: ( thetaJoins )?\r\n                    \tint alt16 = 2;\r\n                    \tint LA16_0 = input.LA(1);\r\n\r\n                    \tif ( (LA16_0 == THETA_JOINS) )\r\n                    \t{\r\n                    \t    alt16 = 1;\r\n                    \t}\r\n                    \tswitch (alt16) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // SqlGenerator.g:109:5: thetaJoins\r\n                    \t        {\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n                    \t        \t   Out(\" and \"); \r\n                    \t        \t}\r\n                    \t        \tPushFollow(FOLLOW_thetaJoins_in_whereExpr473);\r\n                    \t        \tthetaJoins();\r\n                    \t        \tstate.followingStackPointer--;\r\n                    \t        \tif (state.failed) return ;\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \t// SqlGenerator.g:110:3: ( booleanExpr[ true ] )?\r\n                    \tint alt17 = 2;\r\n                    \tint LA17_0 = input.LA(1);\r\n\r\n                    \tif ( (LA17_0 == AND || LA17_0 == BETWEEN || LA17_0 == EXISTS || LA17_0 == IN || LA17_0 == LIKE || LA17_0 == NOT || LA17_0 == OR || (LA17_0 >= IS_NOT_NULL && LA17_0 <= NOT_LIKE) || LA17_0 == EQ || LA17_0 == NE || (LA17_0 >= LT && LA17_0 <= GE) || LA17_0 == SQL_TOKEN) )\r\n                    \t{\r\n                    \t    alt17 = 1;\r\n                    \t}\r\n                    \tswitch (alt17) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // SqlGenerator.g:110:5: booleanExpr[ true ]\r\n                    \t        {\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n                    \t        \t   Out(\" and \"); \r\n                    \t        \t}\r\n                    \t        \tPushFollow(FOLLOW_booleanExpr_in_whereExpr484);\r\n                    \t        \tbooleanExpr(true);\r\n                    \t        \tstate.followingStackPointer--;\r\n                    \t        \tif (state.failed) return ;\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:111:4: thetaJoins ( booleanExpr[ true ] )?\r\n                    {\r\n                    \tPushFollow(FOLLOW_thetaJoins_in_whereExpr494);\r\n                    \tthetaJoins();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \t// SqlGenerator.g:112:3: ( booleanExpr[ true ] )?\r\n                    \tint alt18 = 2;\r\n                    \tint LA18_0 = input.LA(1);\r\n\r\n                    \tif ( (LA18_0 == AND || LA18_0 == BETWEEN || LA18_0 == EXISTS || LA18_0 == IN || LA18_0 == LIKE || LA18_0 == NOT || LA18_0 == OR || (LA18_0 >= IS_NOT_NULL && LA18_0 <= NOT_LIKE) || LA18_0 == EQ || LA18_0 == NE || (LA18_0 >= LT && LA18_0 <= GE) || LA18_0 == SQL_TOKEN) )\r\n                    \t{\r\n                    \t    alt18 = 1;\r\n                    \t}\r\n                    \tswitch (alt18) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // SqlGenerator.g:112:5: booleanExpr[ true ]\r\n                    \t        {\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n                    \t        \t   Out(\" and \"); \r\n                    \t        \t}\r\n                    \t        \tPushFollow(FOLLOW_booleanExpr_in_whereExpr502);\r\n                    \t        \tbooleanExpr(true);\r\n                    \t        \tstate.followingStackPointer--;\r\n                    \t        \tif (state.failed) return ;\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:113:4: booleanExpr[false]\r\n                    {\r\n                    \tPushFollow(FOLLOW_booleanExpr_in_whereExpr513);\r\n                    \tbooleanExpr(false);\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 19,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 1325
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "additiveExpr",
      "SourcesSample": "public void additiveExpr() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:303:2: ( ^( PLUS expr expr ) | ^( MINUS expr nestedExprAfterMinusDiv ) )\r\n            int alt56 = 2;\r\n            int LA56_0 = input.LA(1);\r\n\r\n            if ( (LA56_0 == PLUS) )\r\n            {\r\n                alt56 = 1;\r\n            }\r\n            else if ( (LA56_0 == MINUS) )\r\n            {\r\n                alt56 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d56s0 =\r\n                    new NoViableAltException(\"\", 56, 0, input);\r\n\r\n                throw nvae_d56s0;\r\n            }\r\n            switch (alt56) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:303:4: ^( PLUS expr expr )\r\n                    {\r\n                    \tMatch(input,PLUS,FOLLOW_PLUS_in_additiveExpr1667); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_additiveExpr1669);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"+\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_expr_in_additiveExpr1673);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:304:4: ^( MINUS expr nestedExprAfterMinusDiv )\r\n                    {\r\n                    \tMatch(input,MINUS,FOLLOW_MINUS_in_additiveExpr1680); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_additiveExpr1682);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"-\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_nestedExprAfterMinusDiv_in_additiveExpr1686);\r\n                    \tnestedExprAfterMinusDiv();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 4770
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "arguments",
      "SourcesSample": "public void arguments() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:355:2: ( ( expr | comparisonExpr[true] ) ( ( expr | comparisonExpr[true] ) )* )\r\n            // SqlGenerator.g:355:4: ( expr | comparisonExpr[true] ) ( ( expr | comparisonExpr[true] ) )*\r\n            {\r\n            \t// SqlGenerator.g:355:4: ( expr | comparisonExpr[true] )\r\n            \tint alt68 = 2;\r\n            \tint LA68_0 = input.LA(1);\r\n\r\n            \tif ( ((LA68_0 >= ALL && LA68_0 <= ANY) || LA68_0 == COUNT || LA68_0 == DOT || LA68_0 == FALSE || LA68_0 == NULL || LA68_0 == SELECT || LA68_0 == SOME || (LA68_0 >= TRUE && LA68_0 <= UNION) || LA68_0 == CASE || LA68_0 == AGGREGATE || LA68_0 == CASE2 || LA68_0 == INDEX_OP || LA68_0 == METHOD_CALL || LA68_0 == UNARY_MINUS || LA68_0 == VECTOR_EXPR || (LA68_0 >= CONSTANT && LA68_0 <= JAVA_CONSTANT) || LA68_0 == PARAM || (LA68_0 >= BNOT && LA68_0 <= DIV) || (LA68_0 >= QUOTED_String && LA68_0 <= IDENT) || LA68_0 == ALIAS_REF || LA68_0 == SQL_TOKEN || LA68_0 == NAMED_PARAM) )\r\n            \t{\r\n            \t    alt68 = 1;\r\n            \t}\r\n            \telse if ( (LA68_0 == BETWEEN || LA68_0 == EXISTS || LA68_0 == IN || LA68_0 == LIKE || (LA68_0 >= IS_NOT_NULL && LA68_0 <= IS_NULL) || (LA68_0 >= NOT_BETWEEN && LA68_0 <= NOT_LIKE) || LA68_0 == EQ || LA68_0 == NE || (LA68_0 >= LT && LA68_0 <= GE)) )\r\n            \t{\r\n            \t    alt68 = 2;\r\n            \t}\r\n            \telse \r\n            \t{\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t    NoViableAltException nvae_d68s0 =\r\n            \t        new NoViableAltException(\"\", 68, 0, input);\r\n\r\n            \t    throw nvae_d68s0;\r\n            \t}\r\n            \tswitch (alt68) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:355:5: expr\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_expr_in_arguments2035);\r\n            \t        \texpr();\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 2 :\r\n            \t        // SqlGenerator.g:355:12: comparisonExpr[true]\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_comparisonExpr_in_arguments2039);\r\n            \t        \tcomparisonExpr(true);\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// SqlGenerator.g:355:34: ( ( expr | comparisonExpr[true] ) )*\r\n            \tdo \r\n            \t{\r\n            \t    int alt70 = 2;\r\n            \t    int LA70_0 = input.LA(1);\r\n\r\n            \t    if ( ((LA70_0 >= ALL && LA70_0 <= ANY) || LA70_0 == BETWEEN || LA70_0 == COUNT || LA70_0 == DOT || (LA70_0 >= EXISTS && LA70_0 <= FALSE) || LA70_0 == IN || LA70_0 == LIKE || LA70_0 == NULL || LA70_0 == SELECT || LA70_0 == SOME || (LA70_0 >= TRUE && LA70_0 <= UNION) || LA70_0 == CASE || LA70_0 == AGGREGATE || LA70_0 == CASE2 || (LA70_0 >= INDEX_OP && LA70_0 <= NOT_LIKE) || LA70_0 == UNARY_MINUS || LA70_0 == VECTOR_EXPR || (LA70_0 >= CONSTANT && LA70_0 <= JAVA_CONSTANT) || LA70_0 == EQ || (LA70_0 >= PARAM && LA70_0 <= NE) || (LA70_0 >= LT && LA70_0 <= GE) || (LA70_0 >= BNOT && LA70_0 <= DIV) || (LA70_0 >= QUOTED_String && LA70_0 <= IDENT) || LA70_0 == ALIAS_REF || LA70_0 == SQL_TOKEN || LA70_0 == NAMED_PARAM) )\r\n            \t    {\r\n            \t        alt70 = 1;\r\n            \t    }\r\n\r\n\r\n            \t    switch (alt70) \r\n            \t\t{\r\n            \t\t\tcase 1 :\r\n            \t\t\t    // SqlGenerator.g:355:36: ( expr | comparisonExpr[true] )\r\n            \t\t\t    {\r\n            \t\t\t    \tif ( (state.backtracking==0) )\r\n            \t\t\t    \t{\r\n            \t\t\t    \t   CommaBetweenParameters(\", \"); \r\n            \t\t\t    \t}\r\n            \t\t\t    \t// SqlGenerator.g:355:70: ( expr | comparisonExpr[true] )\r\n            \t\t\t    \tint alt69 = 2;\r\n            \t\t\t    \tint LA69_0 = input.LA(1);\r\n\r\n            \t\t\t    \tif ( ((LA69_0 >= ALL && LA69_0 <= ANY) || LA69_0 == COUNT || LA69_0 == DOT || LA69_0 == FALSE || LA69_0 == NULL || LA69_0 == SELECT || LA69_0 == SOME || (LA69_0 >= TRUE && LA69_0 <= UNION) || LA69_0 == CASE || LA69_0 == AGGREGATE || LA69_0 == CASE2 || LA69_0 == INDEX_OP || LA69_0 == METHOD_CALL || LA69_0 == UNARY_MINUS || LA69_0 == VECTOR_EXPR || (LA69_0 >= CONSTANT && LA69_0 <= JAVA_CONSTANT) || LA69_0 == PARAM || (LA69_0 >= BNOT && LA69_0 <= DIV) || (LA69_0 >= QUOTED_String && LA69_0 <= IDENT) || LA69_0 == ALIAS_REF || LA69_0 == SQL_TOKEN || LA69_0 == NAMED_PARAM) )\r\n            \t\t\t    \t{\r\n            \t\t\t    \t    alt69 = 1;\r\n            \t\t\t    \t}\r\n            \t\t\t    \telse if ( (LA69_0 == BETWEEN || LA69_0 == EXISTS || LA69_0 == IN || LA69_0 == LIKE || (LA69_0 >= IS_NOT_NULL && LA69_0 <= IS_NULL) || (LA69_0 >= NOT_BETWEEN && LA69_0 <= NOT_LIKE) || LA69_0 == EQ || LA69_0 == NE || (LA69_0 >= LT && LA69_0 <= GE)) )\r\n            \t\t\t    \t{\r\n            \t\t\t    \t    alt69 = 2;\r\n            \t\t\t    \t}\r\n            \t\t\t    \telse \r\n            \t\t\t    \t{\r\n            \t\t\t    \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t\t\t    \t    NoViableAltException nvae_d69s0 =\r\n            \t\t\t    \t        new NoViableAltException(\"\", 69, 0, input);\r\n\r\n            \t\t\t    \t    throw nvae_d69s0;\r\n            \t\t\t    \t}\r\n            \t\t\t    \tswitch (alt69) \r\n            \t\t\t    \t{\r\n            \t\t\t    \t    case 1 :\r\n            \t\t\t    \t        // SqlGenerator.g:355:71: expr\r\n            \t\t\t    \t        {\r\n            \t\t\t    \t        \tPushFollow(FOLLOW_expr_in_arguments2048);\r\n            \t\t\t    \t        \texpr();\r\n            \t\t\t    \t        \tstate.followingStackPointer--;\r\n            \t\t\t    \t        \tif (state.failed) return ;\r\n\r\n            \t\t\t    \t        }\r\n            \t\t\t    \t        break;\r\n            \t\t\t    \t    case 2 :\r\n            \t\t\t    \t        // SqlGenerator.g:355:78: comparisonExpr[true]\r\n            \t\t\t    \t        {\r\n            \t\t\t    \t        \tPushFollow(FOLLOW_comparisonExpr_in_arguments2052);\r\n            \t\t\t    \t        \tcomparisonExpr(true);\r\n            \t\t\t    \t        \tstate.followingStackPointer--;\r\n            \t\t\t    \t        \tif (state.failed) return ;\r\n\r\n            \t\t\t    \t        }\r\n            \t\t\t    \t        break;\r\n\r\n            \t\t\t    \t}\r\n\r\n\r\n            \t\t\t    }\r\n            \t\t\t    break;\r\n\r\n            \t\t\tdefault:\r\n            \t\t\t    goto loop70;\r\n            \t    }\r\n            \t} while (true);\r\n\r\n            \tloop70:\r\n            \t\t;\t// Stops C# compiler whining that label 'loop70' has no statements\r\n\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 5630
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "distinctOrAll",
      "SourcesSample": "public void distinctOrAll() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:155:2: ( DISTINCT | ^( ALL ( . )* ) )\r\n            int alt28 = 2;\r\n            int LA28_0 = input.LA(1);\r\n\r\n            if ( (LA28_0 == DISTINCT) )\r\n            {\r\n                alt28 = 1;\r\n            }\r\n            else if ( (LA28_0 == ALL) )\r\n            {\r\n                alt28 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d28s0 =\r\n                    new NoViableAltException(\"\", 28, 0, input);\r\n\r\n                throw nvae_d28s0;\r\n            }\r\n            switch (alt28) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:155:4: DISTINCT\r\n                    {\r\n                    \tMatch(input,DISTINCT,FOLLOW_DISTINCT_in_distinctOrAll740); if (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"distinct \"); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:156:4: ^( ALL ( . )* )\r\n                    {\r\n                    \tMatch(input,ALL,FOLLOW_ALL_in_distinctOrAll748); if (state.failed) return ;\r\n\r\n                    \tif ( input.LA(1) == Token.DOWN )\r\n                    \t{\r\n                    \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \t    // SqlGenerator.g:156:10: ( . )*\r\n                    \t    do \r\n                    \t    {\r\n                    \t        int alt27 = 2;\r\n                    \t        int LA27_0 = input.LA(1);\r\n\r\n                    \t        if ( ((LA27_0 >= ALL && LA27_0 <= BOGUS)) )\r\n                    \t        {\r\n                    \t            alt27 = 1;\r\n                    \t        }\r\n                    \t        else if ( (LA27_0 == UP) )\r\n                    \t        {\r\n                    \t            alt27 = 2;\r\n                    \t        }\r\n\r\n\r\n                    \t        switch (alt27) \r\n                    \t    \t{\r\n                    \t    \t\tcase 1 :\r\n                    \t    \t\t    // SqlGenerator.g:156:10: .\r\n                    \t    \t\t    {\r\n                    \t    \t\t    \tMatchAny(input); if (state.failed) return ;\r\n\r\n                    \t    \t\t    }\r\n                    \t    \t\t    break;\r\n\r\n                    \t    \t\tdefault:\r\n                    \t    \t\t    goto loop27;\r\n                    \t        }\r\n                    \t    } while (true);\r\n\r\n                    \t    loop27:\r\n                    \t    \t;\t// Stops C# compiler whining that label 'loop27' has no statements\r\n\r\n\r\n                    \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n                    \t}\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"all \"); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 2129
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "multiplicativeExpr",
      "SourcesSample": "public void multiplicativeExpr() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:315:2: ( ^( STAR nestedExpr nestedExpr ) | ^( DIV nestedExpr nestedExprAfterMinusDiv ) )\r\n            int alt58 = 2;\r\n            int LA58_0 = input.LA(1);\r\n\r\n            if ( (LA58_0 == STAR) )\r\n            {\r\n                alt58 = 1;\r\n            }\r\n            else if ( (LA58_0 == DIV) )\r\n            {\r\n                alt58 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d58s0 =\r\n                    new NoViableAltException(\"\", 58, 0, input);\r\n\r\n                throw nvae_d58s0;\r\n            }\r\n            switch (alt58) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:315:4: ^( STAR nestedExpr nestedExpr )\r\n                    {\r\n                    \tMatch(input,STAR,FOLLOW_STAR_in_multiplicativeExpr1756); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_nestedExpr_in_multiplicativeExpr1758);\r\n                    \tnestedExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"*\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_nestedExpr_in_multiplicativeExpr1762);\r\n                    \tnestedExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:316:4: ^( DIV nestedExpr nestedExprAfterMinusDiv )\r\n                    {\r\n                    \tMatch(input,DIV,FOLLOW_DIV_in_multiplicativeExpr1769); if (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_nestedExpr_in_multiplicativeExpr1771);\r\n                    \tnestedExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"/\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_nestedExprAfterMinusDiv_in_multiplicativeExpr1775);\r\n                    \tnestedExprAfterMinusDiv();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 5005
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "insertStatement",
      "SourcesSample": "public void insertStatement() // throws RecognitionException [1]\r\n    {   \r\n        IASTNode i = null;\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:68:2: ( ^( INSERT ^(i= INTO ( . )* ) selectStatement ) )\r\n            // SqlGenerator.g:68:4: ^( INSERT ^(i= INTO ( . )* ) selectStatement )\r\n            {\r\n            \tMatch(input,INSERT,FOLLOW_INSERT_in_insertStatement280); if (state.failed) return ;\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   Out( \"insert \" ); \r\n            \t}\r\n\r\n            \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \ti=(IASTNode)Match(input,INTO,FOLLOW_INTO_in_insertStatement289); if (state.failed) return ;\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   Out( i ); Out( \" \" ); \r\n            \t}\r\n\r\n            \tif ( input.LA(1) == Token.DOWN )\r\n            \t{\r\n            \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t    // SqlGenerator.g:69:38: ( . )*\r\n            \t    do \r\n            \t    {\r\n            \t        int alt10 = 2;\r\n            \t        int LA10_0 = input.LA(1);\r\n\r\n            \t        if ( ((LA10_0 >= ALL && LA10_0 <= BOGUS)) )\r\n            \t        {\r\n            \t            alt10 = 1;\r\n            \t        }\r\n            \t        else if ( (LA10_0 == UP) )\r\n            \t        {\r\n            \t            alt10 = 2;\r\n            \t        }\r\n\r\n\r\n            \t        switch (alt10) \r\n            \t    \t{\r\n            \t    \t\tcase 1 :\r\n            \t    \t\t    // SqlGenerator.g:69:38: .\r\n            \t    \t\t    {\r\n            \t    \t\t    \tMatchAny(input); if (state.failed) return ;\r\n\r\n            \t    \t\t    }\r\n            \t    \t\t    break;\r\n\r\n            \t    \t\tdefault:\r\n            \t    \t\t    goto loop10;\r\n            \t        }\r\n            \t    } while (true);\r\n\r\n            \t    loop10:\r\n            \t    \t;\t// Stops C# compiler whining that label 'loop10' has no statements\r\n\r\n\r\n            \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n            \t}\r\n            \tPushFollow(FOLLOW_selectStatement_in_insertStatement299);\r\n            \tselectStatement();\r\n            \tstate.followingStackPointer--;\r\n            \tif (state.failed) return ;\r\n\r\n            \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 16,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 844
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "methodCall",
      "SourcesSample": "public void methodCall() // throws RecognitionException [1]\r\n    {   \r\n        IASTNode m = null;\r\n        IASTNode i = null;\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:349:2: ( ^(m= METHOD_CALL i= METHOD_NAME ( ^( EXPR_LIST ( arguments )? ) )? ) )\r\n            // SqlGenerator.g:349:4: ^(m= METHOD_CALL i= METHOD_NAME ( ^( EXPR_LIST ( arguments )? ) )? )\r\n            {\r\n            \tm=(IASTNode)Match(input,METHOD_CALL,FOLLOW_METHOD_CALL_in_methodCall1994); if (state.failed) return ;\r\n\r\n            \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \ti=(IASTNode)Match(input,METHOD_NAME,FOLLOW_METHOD_NAME_in_methodCall1998); if (state.failed) return ;\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   BeginFunctionTemplate(m,i); \r\n            \t}\r\n            \t// SqlGenerator.g:350:3: ( ^( EXPR_LIST ( arguments )? ) )?\r\n            \tint alt67 = 2;\r\n            \tint LA67_0 = input.LA(1);\r\n\r\n            \tif ( (LA67_0 == EXPR_LIST) )\r\n            \t{\r\n            \t    alt67 = 1;\r\n            \t}\r\n            \tswitch (alt67) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:350:5: ^( EXPR_LIST ( arguments )? )\r\n            \t        {\r\n            \t        \tMatch(input,EXPR_LIST,FOLLOW_EXPR_LIST_in_methodCall2007); if (state.failed) return ;\r\n\r\n            \t        \tif ( input.LA(1) == Token.DOWN )\r\n            \t        \t{\r\n            \t        \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t        \t    // SqlGenerator.g:350:17: ( arguments )?\r\n            \t        \t    int alt66 = 2;\r\n            \t        \t    int LA66_0 = input.LA(1);\r\n\r\n            \t        \t    if ( ((LA66_0 >= ALL && LA66_0 <= ANY) || LA66_0 == BETWEEN || LA66_0 == COUNT || LA66_0 == DOT || (LA66_0 >= EXISTS && LA66_0 <= FALSE) || LA66_0 == IN || LA66_0 == LIKE || LA66_0 == NULL || LA66_0 == SELECT || LA66_0 == SOME || (LA66_0 >= TRUE && LA66_0 <= UNION) || LA66_0 == CASE || LA66_0 == AGGREGATE || LA66_0 == CASE2 || (LA66_0 >= INDEX_OP && LA66_0 <= NOT_LIKE) || LA66_0 == UNARY_MINUS || LA66_0 == VECTOR_EXPR || (LA66_0 >= CONSTANT && LA66_0 <= JAVA_CONSTANT) || LA66_0 == EQ || (LA66_0 >= PARAM && LA66_0 <= NE) || (LA66_0 >= LT && LA66_0 <= GE) || (LA66_0 >= BNOT && LA66_0 <= DIV) || (LA66_0 >= QUOTED_String && LA66_0 <= IDENT) || LA66_0 == ALIAS_REF || LA66_0 == SQL_TOKEN || LA66_0 == NAMED_PARAM) )\r\n            \t        \t    {\r\n            \t        \t        alt66 = 1;\r\n            \t        \t    }\r\n            \t        \t    switch (alt66) \r\n            \t        \t    {\r\n            \t        \t        case 1 :\r\n            \t        \t            // SqlGenerator.g:350:18: arguments\r\n            \t        \t            {\r\n            \t        \t            \tPushFollow(FOLLOW_arguments_in_methodCall2010);\r\n            \t        \t            \targuments();\r\n            \t        \t            \tstate.followingStackPointer--;\r\n            \t        \t            \tif (state.failed) return ;\r\n\r\n            \t        \t            }\r\n            \t        \t            break;\r\n\r\n            \t        \t    }\r\n\r\n\r\n            \t        \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n            \t        \t}\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   EndFunctionTemplate(m); \r\n            \t}\r\n\r\n            \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 16,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 5537
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "parenSelect",
      "SourcesSample": "public void parenSelect() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:262:2: ( selectStatement | ^( UNION selectStatement parenSelect ) )\r\n            int alt53 = 2;\r\n            int LA53_0 = input.LA(1);\r\n\r\n            if ( (LA53_0 == SELECT) )\r\n            {\r\n                alt53 = 1;\r\n            }\r\n            else if ( (LA53_0 == UNION) )\r\n            {\r\n                alt53 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d53s0 =\r\n                    new NoViableAltException(\"\", 53, 0, input);\r\n\r\n                throw nvae_d53s0;\r\n            }\r\n            switch (alt53) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:262:4: selectStatement\r\n                    {\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"(\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_selectStatement_in_parenSelect1476);\r\n                    \tselectStatement();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\")\"); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:263:4: ^( UNION selectStatement parenSelect )\r\n                    {\r\n                    \tMatch(input,UNION,FOLLOW_UNION_in_parenSelect1485); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"(\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_selectStatement_in_parenSelect1489);\r\n                    \tselectStatement();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\") union \"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_parenSelect_in_parenSelect1493);\r\n                    \tparenSelect();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 4301
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "simpleExpr",
      "SourcesSample": "public SqlGenerator.simpleExpr_return simpleExpr() // throws RecognitionException [1]\r\n    {   \r\n        SqlGenerator.simpleExpr_return retval = new SqlGenerator.simpleExpr_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        SqlGenerator.constant_return c = default(SqlGenerator.constant_return);\r\n\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:268:2: (c= constant | NULL | addrExpr | sqlToken | aggregate | methodCall | count | parameter | arithmeticExpr )\r\n            int alt54 = 9;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case FALSE:\r\n            case TRUE:\r\n            case CONSTANT:\r\n            case NUM_INT:\r\n            case NUM_DOUBLE:\r\n            case NUM_DECIMAL:\r\n            case NUM_FLOAT:\r\n            case NUM_LONG:\r\n            case JAVA_CONSTANT:\r\n            case QUOTED_String:\r\n            case IDENT:\r\n            \t{\r\n                alt54 = 1;\r\n                }\r\n                break;\r\n            case NULL:\r\n            \t{\r\n                alt54 = 2;\r\n                }\r\n                break;\r\n            case DOT:\r\n            case INDEX_OP:\r\n            case ALIAS_REF:\r\n            \t{\r\n                alt54 = 3;\r\n                }\r\n                break;\r\n            case SQL_TOKEN:\r\n            \t{\r\n                alt54 = 4;\r\n                }\r\n                break;\r\n            case AGGREGATE:\r\n            \t{\r\n                alt54 = 5;\r\n                }\r\n                break;\r\n            case METHOD_CALL:\r\n            \t{\r\n                alt54 = 6;\r\n                }\r\n                break;\r\n            case COUNT:\r\n            \t{\r\n                alt54 = 7;\r\n                }\r\n                break;\r\n            case PARAM:\r\n            case NAMED_PARAM:\r\n            \t{\r\n                alt54 = 8;\r\n                }\r\n                break;\r\n            case CASE:\r\n            case CASE2:\r\n            case UNARY_MINUS:\r\n            case BNOT:\r\n            case BOR:\r\n            case BXOR:\r\n            case BAND:\r\n            case PLUS:\r\n            case MINUS:\r\n            case STAR:\r\n            case DIV:\r\n            \t{\r\n                alt54 = 9;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return retval;}\r\n            \t    NoViableAltException nvae_d54s0 =\r\n            \t        new NoViableAltException(\"\", 54, 0, input);\r\n\r\n            \t    throw nvae_d54s0;\r\n            }\r\n\r\n            switch (alt54) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:268:4: c= constant\r\n                    {\r\n                    \tPushFollow(FOLLOW_constant_in_simpleExpr1510);\r\n                    \tc = constant();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(((c != null) ? ((IASTNode)c.Start) : null)); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:269:4: NULL\r\n                    {\r\n                    \tMatch(input,NULL,FOLLOW_NULL_in_simpleExpr1517); if (state.failed) return retval;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"null\"); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:270:4: addrExpr\r\n                    {\r\n                    \tPushFollow(FOLLOW_addrExpr_in_simpleExpr1524);\r\n                    \taddrExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // SqlGenerator.g:271:4: sqlToken\r\n                    {\r\n                    \tPushFollow(FOLLOW_sqlToken_in_simpleExpr1529);\r\n                    \tsqlToken();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 5 :\r\n                    // SqlGenerator.g:272:4: aggregate\r\n                    {\r\n                    \tPushFollow(FOLLOW_aggregate_in_simpleExpr1534);\r\n                    \taggregate();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 6 :\r\n                    // SqlGenerator.g:273:4: methodCall\r\n                    {\r\n                    \tPushFollow(FOLLOW_methodCall_in_simpleExpr1539);\r\n                    \tmethodCall();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 7 :\r\n                    // SqlGenerator.g:274:4: count\r\n                    {\r\n                    \tPushFollow(FOLLOW_count_in_simpleExpr1544);\r\n                    \tcount();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 8 :\r\n                    // SqlGenerator.g:275:4: parameter\r\n                    {\r\n                    \tPushFollow(FOLLOW_parameter_in_simpleExpr1549);\r\n                    \tparameter();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n                case 9 :\r\n                    // SqlGenerator.g:276:4: arithmeticExpr\r\n                    {\r\n                    \tPushFollow(FOLLOW_arithmeticExpr_in_simpleExpr1554);\r\n                    \tarithmeticExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return retval;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 4394
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "arithmeticExpr",
      "SourcesSample": "public void arithmeticExpr() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:294:2: ( additiveExpr | bitwiseExpr | multiplicativeExpr | ^( UNARY_MINUS expr ) | caseExpr )\r\n            int alt55 = 5;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case PLUS:\r\n            case MINUS:\r\n            \t{\r\n                alt55 = 1;\r\n                }\r\n                break;\r\n            case BNOT:\r\n            case BOR:\r\n            case BXOR:\r\n            case BAND:\r\n            \t{\r\n                alt55 = 2;\r\n                }\r\n                break;\r\n            case STAR:\r\n            case DIV:\r\n            \t{\r\n                alt55 = 3;\r\n                }\r\n                break;\r\n            case UNARY_MINUS:\r\n            \t{\r\n                alt55 = 4;\r\n                }\r\n                break;\r\n            case CASE:\r\n            case CASE2:\r\n            \t{\r\n                alt55 = 5;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t    NoViableAltException nvae_d55s0 =\r\n            \t        new NoViableAltException(\"\", 55, 0, input);\r\n\r\n            \t    throw nvae_d55s0;\r\n            }\r\n\r\n            switch (alt55) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:294:4: additiveExpr\r\n                    {\r\n                    \tPushFollow(FOLLOW_additiveExpr_in_arithmeticExpr1628);\r\n                    \tadditiveExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:295:4: bitwiseExpr\r\n                    {\r\n                    \tPushFollow(FOLLOW_bitwiseExpr_in_arithmeticExpr1633);\r\n                    \tbitwiseExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // SqlGenerator.g:296:4: multiplicativeExpr\r\n                    {\r\n                    \tPushFollow(FOLLOW_multiplicativeExpr_in_arithmeticExpr1638);\r\n                    \tmultiplicativeExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // SqlGenerator.g:298:4: ^( UNARY_MINUS expr )\r\n                    {\r\n                    \tMatch(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_arithmeticExpr1645); if (state.failed) return ;\r\n\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   Out(\"-\"); \r\n                    \t}\r\n\r\n                    \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n                    \tPushFollow(FOLLOW_expr_in_arithmeticExpr1649);\r\n                    \texpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 5 :\r\n                    // SqlGenerator.g:299:4: caseExpr\r\n                    {\r\n                    \tPushFollow(FOLLOW_caseExpr_in_arithmeticExpr1655);\r\n                    \tcaseExpr();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 4643
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "selectClause",
      "SourcesSample": "public void selectClause() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:129:2: ( ^( SELECT_CLAUSE ( distinctOrAll )? ( selectColumn )+ ) )\r\n            // SqlGenerator.g:129:4: ^( SELECT_CLAUSE ( distinctOrAll )? ( selectColumn )+ )\r\n            {\r\n            \tMatch(input,SELECT_CLAUSE,FOLLOW_SELECT_CLAUSE_in_selectClause578); if (state.failed) return ;\r\n\r\n            \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t// SqlGenerator.g:129:20: ( distinctOrAll )?\r\n            \tint alt21 = 2;\r\n            \tint LA21_0 = input.LA(1);\r\n\r\n            \tif ( (LA21_0 == ALL || LA21_0 == DISTINCT) )\r\n            \t{\r\n            \t    alt21 = 1;\r\n            \t}\r\n            \tswitch (alt21) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:129:21: distinctOrAll\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_distinctOrAll_in_selectClause581);\r\n            \t        \tdistinctOrAll();\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// SqlGenerator.g:129:37: ( selectColumn )+\r\n            \tint cnt22 = 0;\r\n            \tdo \r\n            \t{\r\n            \t    int alt22 = 2;\r\n            \t    int LA22_0 = input.LA(1);\r\n\r\n            \t    if ( (LA22_0 == COUNT || LA22_0 == DOT || LA22_0 == FALSE || LA22_0 == SELECT || LA22_0 == TRUE || LA22_0 == CASE || LA22_0 == AGGREGATE || (LA22_0 >= CONSTRUCTOR && LA22_0 <= CASE2) || LA22_0 == METHOD_CALL || LA22_0 == UNARY_MINUS || (LA22_0 >= CONSTANT && LA22_0 <= JAVA_CONSTANT) || LA22_0 == PARAM || (LA22_0 >= BNOT && LA22_0 <= DIV) || (LA22_0 >= QUOTED_String && LA22_0 <= IDENT) || LA22_0 == ALIAS_REF || LA22_0 == SQL_TOKEN || LA22_0 == SELECT_EXPR || LA22_0 == NAMED_PARAM) )\r\n            \t    {\r\n            \t        alt22 = 1;\r\n            \t    }\r\n\r\n\r\n            \t    switch (alt22) \r\n            \t\t{\r\n            \t\t\tcase 1 :\r\n            \t\t\t    // SqlGenerator.g:129:39: selectColumn\r\n            \t\t\t    {\r\n            \t\t\t    \tPushFollow(FOLLOW_selectColumn_in_selectClause587);\r\n            \t\t\t    \tselectColumn();\r\n            \t\t\t    \tstate.followingStackPointer--;\r\n            \t\t\t    \tif (state.failed) return ;\r\n\r\n            \t\t\t    }\r\n            \t\t\t    break;\r\n\r\n            \t\t\tdefault:\r\n            \t\t\t    if ( cnt22 >= 1 ) goto loop22;\r\n            \t\t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t\t            EarlyExitException eee22 =\r\n            \t\t                new EarlyExitException(22, input);\r\n            \t\t            throw eee22;\r\n            \t    }\r\n            \t    cnt22++;\r\n            \t} while (true);\r\n\r\n            \tloop22:\r\n            \t\t;\t// Stops C# compiler whining that label 'loop22' has no statements\r\n\r\n\r\n            \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 1633
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "updateStatement",
      "SourcesSample": "public void updateStatement() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:52:2: ( ^( UPDATE ^( FROM fromTable ) setClause ( whereClause )? ) )\r\n            // SqlGenerator.g:52:4: ^( UPDATE ^( FROM fromTable ) setClause ( whereClause )? )\r\n            {\r\n            \tMatch(input,UPDATE,FOLLOW_UPDATE_in_updateStatement212); if (state.failed) return ;\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   Out(\"update \"); \r\n            \t}\r\n\r\n            \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \tMatch(input,FROM,FOLLOW_FROM_in_updateStatement220); if (state.failed) return ;\r\n\r\n            \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \tPushFollow(FOLLOW_fromTable_in_updateStatement222);\r\n            \tfromTable();\r\n            \tstate.followingStackPointer--;\r\n            \tif (state.failed) return ;\r\n\r\n            \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n            \tPushFollow(FOLLOW_setClause_in_updateStatement228);\r\n            \tsetClause();\r\n            \tstate.followingStackPointer--;\r\n            \tif (state.failed) return ;\r\n            \t// SqlGenerator.g:55:3: ( whereClause )?\r\n            \tint alt8 = 2;\r\n            \tint LA8_0 = input.LA(1);\r\n\r\n            \tif ( (LA8_0 == WHERE) )\r\n            \t{\r\n            \t    alt8 = 1;\r\n            \t}\r\n            \tswitch (alt8) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // SqlGenerator.g:55:4: whereClause\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_whereClause_in_updateStatement233);\r\n            \t        \twhereClause();\r\n            \t        \tstate.followingStackPointer--;\r\n            \t        \tif (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n\r\n            \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 709
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "inList",
      "SourcesSample": "public void inList() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:240:2: ( ^( IN_LIST ( parenSelect | simpleExprList ) ) )\r\n            // SqlGenerator.g:240:4: ^( IN_LIST ( parenSelect | simpleExprList ) )\r\n            {\r\n            \tMatch(input,IN_LIST,FOLLOW_IN_LIST_in_inList1322); if (state.failed) return ;\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   Out(\" \"); \r\n            \t}\r\n\r\n            \tif ( input.LA(1) == Token.DOWN )\r\n            \t{\r\n            \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t    // SqlGenerator.g:240:28: ( parenSelect | simpleExprList )\r\n            \t    int alt48 = 2;\r\n            \t    int LA48_0 = input.LA(1);\r\n\r\n            \t    if ( (LA48_0 == SELECT || LA48_0 == UNION) )\r\n            \t    {\r\n            \t        alt48 = 1;\r\n            \t    }\r\n            \t    else if ( (LA48_0 == UP || LA48_0 == COUNT || LA48_0 == DOT || LA48_0 == FALSE || LA48_0 == NULL || LA48_0 == TRUE || LA48_0 == CASE || LA48_0 == AGGREGATE || LA48_0 == CASE2 || LA48_0 == INDEX_OP || LA48_0 == METHOD_CALL || LA48_0 == UNARY_MINUS || (LA48_0 >= CONSTANT && LA48_0 <= JAVA_CONSTANT) || LA48_0 == PARAM || (LA48_0 >= BNOT && LA48_0 <= DIV) || (LA48_0 >= QUOTED_String && LA48_0 <= IDENT) || LA48_0 == ALIAS_REF || LA48_0 == SQL_TOKEN || LA48_0 == NAMED_PARAM) )\r\n            \t    {\r\n            \t        alt48 = 2;\r\n            \t    }\r\n            \t    else \r\n            \t    {\r\n            \t        if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t        NoViableAltException nvae_d48s0 =\r\n            \t            new NoViableAltException(\"\", 48, 0, input);\r\n\r\n            \t        throw nvae_d48s0;\r\n            \t    }\r\n            \t    switch (alt48) \r\n            \t    {\r\n            \t        case 1 :\r\n            \t            // SqlGenerator.g:240:30: parenSelect\r\n            \t            {\r\n            \t            \tPushFollow(FOLLOW_parenSelect_in_inList1328);\r\n            \t            \tparenSelect();\r\n            \t            \tstate.followingStackPointer--;\r\n            \t            \tif (state.failed) return ;\r\n\r\n            \t            }\r\n            \t            break;\r\n            \t        case 2 :\r\n            \t            // SqlGenerator.g:240:44: simpleExprList\r\n            \t            {\r\n            \t            \tPushFollow(FOLLOW_simpleExprList_in_inList1332);\r\n            \t            \tsimpleExprList();\r\n            \t            \tstate.followingStackPointer--;\r\n            \t            \tif (state.failed) return ;\r\n\r\n            \t            }\r\n            \t            break;\r\n\r\n            \t    }\r\n\r\n\r\n            \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n            \t}\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 3817
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "comparisonExpr",
      "SourcesSample": "public void comparisonExpr(bool parens) // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:210:2: ( binaryComparisonExpression | exoticComparisonExpression )\r\n            int alt44 = 2;\r\n            int LA44_0 = input.LA(1);\r\n\r\n            if ( (LA44_0 == EQ || LA44_0 == NE || (LA44_0 >= LT && LA44_0 <= GE)) )\r\n            {\r\n                alt44 = 1;\r\n            }\r\n            else if ( (LA44_0 == BETWEEN || LA44_0 == EXISTS || LA44_0 == IN || LA44_0 == LIKE || (LA44_0 >= IS_NOT_NULL && LA44_0 <= IS_NULL) || (LA44_0 >= NOT_BETWEEN && LA44_0 <= NOT_LIKE)) )\r\n            {\r\n                alt44 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d44s0 =\r\n                    new NoViableAltException(\"\", 44, 0, input);\r\n\r\n                throw nvae_d44s0;\r\n            }\r\n            switch (alt44) \r\n            {\r\n                case 1 :\r\n                    // SqlGenerator.g:210:4: binaryComparisonExpression\r\n                    {\r\n                    \tPushFollow(FOLLOW_binaryComparisonExpression_in_comparisonExpr1060);\r\n                    \tbinaryComparisonExpression();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // SqlGenerator.g:211:4: exoticComparisonExpression\r\n                    {\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   if (parens) Out(\"(\"); \r\n                    \t}\r\n                    \tPushFollow(FOLLOW_exoticComparisonExpression_in_comparisonExpr1067);\r\n                    \texoticComparisonExpression();\r\n                    \tstate.followingStackPointer--;\r\n                    \tif (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t   if (parens) Out(\")\"); \r\n                    \t}\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 3181
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "setClause",
      "SourcesSample": "public void setClause() // throws RecognitionException [1]\r\n    {   \r\n        try \r\n    \t{\r\n            // SqlGenerator.g:77:2: ( ^( SET comparisonExpr[false] ( comparisonExpr[false] )* ) )\r\n            // SqlGenerator.g:77:4: ^( SET comparisonExpr[false] ( comparisonExpr[false] )* )\r\n            {\r\n            \tMatch(input,SET,FOLLOW_SET_in_setClause319); if (state.failed) return ;\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   Out(\" set \"); \r\n            \t}\r\n\r\n            \tMatch(input, Token.DOWN, null); if (state.failed) return ;\r\n            \tPushFollow(FOLLOW_comparisonExpr_in_setClause323);\r\n            \tcomparisonExpr(false);\r\n            \tstate.followingStackPointer--;\r\n            \tif (state.failed) return ;\r\n            \t// SqlGenerator.g:77:51: ( comparisonExpr[false] )*\r\n            \tdo \r\n            \t{\r\n            \t    int alt11 = 2;\r\n            \t    int LA11_0 = input.LA(1);\r\n\r\n            \t    if ( (LA11_0 == BETWEEN || LA11_0 == EXISTS || LA11_0 == IN || LA11_0 == LIKE || (LA11_0 >= IS_NOT_NULL && LA11_0 <= IS_NULL) || (LA11_0 >= NOT_BETWEEN && LA11_0 <= NOT_LIKE) || LA11_0 == EQ || LA11_0 == NE || (LA11_0 >= LT && LA11_0 <= GE)) )\r\n            \t    {\r\n            \t        alt11 = 1;\r\n            \t    }\r\n\r\n\r\n            \t    switch (alt11) \r\n            \t\t{\r\n            \t\t\tcase 1 :\r\n            \t\t\t    // SqlGenerator.g:77:53: comparisonExpr[false]\r\n            \t\t\t    {\r\n            \t\t\t    \tif ( (state.backtracking==0) )\r\n            \t\t\t    \t{\r\n            \t\t\t    \t   Out(\", \"); \r\n            \t\t\t    \t}\r\n            \t\t\t    \tPushFollow(FOLLOW_comparisonExpr_in_setClause330);\r\n            \t\t\t    \tcomparisonExpr(false);\r\n            \t\t\t    \tstate.followingStackPointer--;\r\n            \t\t\t    \tif (state.failed) return ;\r\n\r\n            \t\t\t    }\r\n            \t\t\t    break;\r\n\r\n            \t\t\tdefault:\r\n            \t\t\t    goto loop11;\r\n            \t    }\r\n            \t} while (true);\r\n\r\n            \tloop11:\r\n            \t\t;\t// Stops C# compiler whining that label 'loop11' has no statements\r\n\r\n\r\n            \tMatch(input, Token.UP, null); if (state.failed) return ;\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 933
    },
    {
      "TypeIdentifier": "SqlGenerator",
      "MethodIdentifier": "sqlToken",
      "SourcesSample": "public void sqlToken() // throws RecognitionException [1]\r\n    {   \r\n        IASTNode t = null;\r\n\r\n        try \r\n    \t{\r\n            // SqlGenerator.g:376:2: ( ^(t= SQL_TOKEN ( . )* ) )\r\n            // SqlGenerator.g:376:4: ^(t= SQL_TOKEN ( . )* )\r\n            {\r\n            \tt=(IASTNode)Match(input,SQL_TOKEN,FOLLOW_SQL_TOKEN_in_sqlToken2160); if (state.failed) return ;\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t   Out(t); \r\n            \t}\r\n\r\n            \tif ( input.LA(1) == Token.DOWN )\r\n            \t{\r\n            \t    Match(input, Token.DOWN, null); if (state.failed) return ;\r\n            \t    // SqlGenerator.g:376:30: ( . )*\r\n            \t    do \r\n            \t    {\r\n            \t        int alt74 = 2;\r\n            \t        int LA74_0 = input.LA(1);\r\n\r\n            \t        if ( ((LA74_0 >= ALL && LA74_0 <= BOGUS)) )\r\n            \t        {\r\n            \t            alt74 = 1;\r\n            \t        }\r\n            \t        else if ( (LA74_0 == UP) )\r\n            \t        {\r\n            \t            alt74 = 2;\r\n            \t        }\r\n\r\n\r\n            \t        switch (alt74) \r\n            \t    \t{\r\n            \t    \t\tcase 1 :\r\n            \t    \t\t    // SqlGenerator.g:376:30: .\r\n            \t    \t\t    {\r\n            \t    \t\t    \tMatchAny(input); if (state.failed) return ;\r\n\r\n            \t    \t\t    }\r\n            \t    \t\t    break;\r\n\r\n            \t    \t\tdefault:\r\n            \t    \t\t    goto loop74;\r\n            \t        }\r\n            \t    } while (true);\r\n\r\n            \t    loop74:\r\n            \t    \t;\t// Stops C# compiler whining that label 'loop74' has no statements\r\n\r\n\r\n            \t    Match(input, Token.UP, null); if (state.failed) return ;\r\n            \t}\r\n\r\n            }\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return ;\r\n    }",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\SqlGenerator.cs",
      "SourceLine": 6027
    }
  ],
  [
    {
      "TypeIdentifier": "HqlLexer",
      "MethodIdentifier": "mTokens",
      "SourcesSample": "override public void mTokens() // throws RecognitionException \r\n    {\r\n        // Hql.g:1:8: ( ALL | ANY | AND | AS | ASCENDING | AVG | BETWEEN | CLASS | COUNT | DELETE | DESCENDING | DISTINCT | ELEMENTS | ESCAPE | EXISTS | FALSE | FETCH | FROM | FULL | GROUP | HAVING | IN | INDICES | INNER | INSERT | INTO | IS | JOIN | LEFT | LIKE | MAX | MIN | NEW | NOT | NULL | OR | ORDER | OUTER | PROPERTIES | RIGHT | SELECT | SET | SKIP | SOME | SUM | TAKE | TRUE | UNION | UPDATE | VERSIONED | WHERE | LITERAL_by | CASE | END | ELSE | THEN | WHEN | ON | WITH | BOTH | EMPTY | LEADING | MEMBER | OBJECT | OF | TRAILING | T__133 | T__134 | EQ | LT | GT | SQL_NE | NE | LE | GE | BOR | BXOR | BAND | BNOT | COMMA | OPEN | CLOSE | OPEN_BRACKET | CLOSE_BRACKET | CONCAT | PLUS | MINUS | STAR | DIV | COLON | PARAM | IDENT | QUOTED_String | WS | NUM_INT )\r\n        int alt23 = 95;\r\n        alt23 = dfa23.Predict(input);\r\n        switch (alt23) \r\n        {\r\n            case 1 :\r\n                // Hql.g:1:10: ALL\r\n                {\r\n                \tmALL(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 2 :\r\n                // Hql.g:1:14: ANY\r\n                {\r\n                \tmANY(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 3 :\r\n                // Hql.g:1:18: AND\r\n                {\r\n                \tmAND(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 4 :\r\n                // Hql.g:1:22: AS\r\n                {\r\n                \tmAS(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 5 :\r\n                // Hql.g:1:25: ASCENDING\r\n                {\r\n                \tmASCENDING(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 6 :\r\n                // Hql.g:1:35: AVG\r\n                {\r\n                \tmAVG(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 7 :\r\n                // Hql.g:1:39: BETWEEN\r\n                {\r\n                \tmBETWEEN(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 8 :\r\n                // Hql.g:1:47: CLASS\r\n                {\r\n                \tmCLASS(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 9 :\r\n                // Hql.g:1:53: COUNT\r\n                {\r\n                \tmCOUNT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 10 :\r\n                // Hql.g:1:59: DELETE\r\n                {\r\n                \tmDELETE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 11 :\r\n                // Hql.g:1:66: DESCENDING\r\n                {\r\n                \tmDESCENDING(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 12 :\r\n                // Hql.g:1:77: DISTINCT\r\n                {\r\n                \tmDISTINCT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 13 :\r\n                // Hql.g:1:86: ELEMENTS\r\n                {\r\n                \tmELEMENTS(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 14 :\r\n                // Hql.g:1:95: ESCAPE\r\n                {\r\n                \tmESCAPE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 15 :\r\n                // Hql.g:1:102: EXISTS\r\n                {\r\n                \tmEXISTS(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 16 :\r\n                // Hql.g:1:109: FALSE\r\n                {\r\n                \tmFALSE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 17 :\r\n                // Hql.g:1:115: FETCH\r\n                {\r\n                \tmFETCH(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 18 :\r\n                // Hql.g:1:121: FROM\r\n                {\r\n                \tmFROM(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 19 :\r\n                // Hql.g:1:126: FULL\r\n                {\r\n                \tmFULL(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 20 :\r\n                // Hql.g:1:131: GROUP\r\n                {\r\n                \tmGROUP(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 21 :\r\n                // Hql.g:1:137: HAVING\r\n                {\r\n                \tmHAVING(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 22 :\r\n                // Hql.g:1:144: IN\r\n                {\r\n                \tmIN(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 23 :\r\n                // Hql.g:1:147: INDICES\r\n                {\r\n                \tmINDICES(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 24 :\r\n                // Hql.g:1:155: INNER\r\n                {\r\n                \tmINNER(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 25 :\r\n                // Hql.g:1:161: INSERT\r\n                {\r\n                \tmINSERT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 26 :\r\n                // Hql.g:1:168: INTO\r\n                {\r\n                \tmINTO(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 27 :\r\n                // Hql.g:1:173: IS\r\n                {\r\n                \tmIS(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 28 :\r\n                // Hql.g:1:176: JOIN\r\n                {\r\n                \tmJOIN(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 29 :\r\n                // Hql.g:1:181: LEFT\r\n                {\r\n                \tmLEFT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 30 :\r\n                // Hql.g:1:186: LIKE\r\n                {\r\n                \tmLIKE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 31 :\r\n                // Hql.g:1:191: MAX\r\n                {\r\n                \tmMAX(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 32 :\r\n                // Hql.g:1:195: MIN\r\n                {\r\n                \tmMIN(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 33 :\r\n                // Hql.g:1:199: NEW\r\n                {\r\n                \tmNEW(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 34 :\r\n                // Hql.g:1:203: NOT\r\n                {\r\n                \tmNOT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 35 :\r\n                // Hql.g:1:207: NULL\r\n                {\r\n                \tmNULL(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 36 :\r\n                // Hql.g:1:212: OR\r\n                {\r\n                \tmOR(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 37 :\r\n                // Hql.g:1:215: ORDER\r\n                {\r\n                \tmORDER(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 38 :\r\n                // Hql.g:1:221: OUTER\r\n                {\r\n                \tmOUTER(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 39 :\r\n                // Hql.g:1:227: PROPERTIES\r\n                {\r\n                \tmPROPERTIES(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 40 :\r\n                // Hql.g:1:238: RIGHT\r\n                {\r\n                \tmRIGHT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 41 :\r\n                // Hql.g:1:244: SELECT\r\n                {\r\n                \tmSELECT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 42 :\r\n                // Hql.g:1:251: SET\r\n                {\r\n                \tmSET(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 43 :\r\n                // Hql.g:1:255: SKIP\r\n                {\r\n                \tmSKIP(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 44 :\r\n                // Hql.g:1:260: SOME\r\n                {\r\n                \tmSOME(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 45 :\r\n                // Hql.g:1:265: SUM\r\n                {\r\n                \tmSUM(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 46 :\r\n                // Hql.g:1:269: TAKE\r\n                {\r\n                \tmTAKE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 47 :\r\n                // Hql.g:1:274: TRUE\r\n                {\r\n                \tmTRUE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 48 :\r\n                // Hql.g:1:279: UNION\r\n                {\r\n                \tmUNION(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 49 :\r\n                // Hql.g:1:285: UPDATE\r\n                {\r\n                \tmUPDATE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 50 :\r\n                // Hql.g:1:292: VERSIONED\r\n                {\r\n                \tmVERSIONED(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 51 :\r\n                // Hql.g:1:302: WHERE\r\n                {\r\n                \tmWHERE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 52 :\r\n                // Hql.g:1:308: LITERAL_by\r\n                {\r\n                \tmLITERAL_by(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 53 :\r\n                // Hql.g:1:319: CASE\r\n                {\r\n                \tmCASE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 54 :\r\n                // Hql.g:1:324: END\r\n                {\r\n                \tmEND(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 55 :\r\n                // Hql.g:1:328: ELSE\r\n                {\r\n                \tmELSE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 56 :\r\n                // Hql.g:1:333: THEN\r\n                {\r\n                \tmTHEN(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 57 :\r\n                // Hql.g:1:338: WHEN\r\n                {\r\n                \tmWHEN(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 58 :\r\n                // Hql.g:1:343: ON\r\n                {\r\n                \tmON(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 59 :\r\n                // Hql.g:1:346: WITH\r\n                {\r\n                \tmWITH(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 60 :\r\n                // Hql.g:1:351: BOTH\r\n                {\r\n                \tmBOTH(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 61 :\r\n                // Hql.g:1:356: EMPTY\r\n                {\r\n                \tmEMPTY(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 62 :\r\n                // Hql.g:1:362: LEADING\r\n                {\r\n                \tmLEADING(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 63 :\r\n                // Hql.g:1:370: MEMBER\r\n                {\r\n                \tmMEMBER(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 64 :\r\n                // Hql.g:1:377: OBJECT\r\n                {\r\n                \tmOBJECT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 65 :\r\n                // Hql.g:1:384: OF\r\n                {\r\n                \tmOF(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 66 :\r\n                // Hql.g:1:387: TRAILING\r\n                {\r\n                \tmTRAILING(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 67 :\r\n                // Hql.g:1:396: T__133\r\n                {\r\n                \tmT__133(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 68 :\r\n                // Hql.g:1:403: T__134\r\n                {\r\n                \tmT__134(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 69 :\r\n                // Hql.g:1:410: EQ\r\n                {\r\n                \tmEQ(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 70 :\r\n                // Hql.g:1:413: LT\r\n                {\r\n                \tmLT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 71 :\r\n                // Hql.g:1:416: GT\r\n                {\r\n                \tmGT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 72 :\r\n                // Hql.g:1:419: SQL_NE\r\n                {\r\n                \tmSQL_NE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 73 :\r\n                // Hql.g:1:426: NE\r\n                {\r\n                \tmNE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 74 :\r\n                // Hql.g:1:429: LE\r\n                {\r\n                \tmLE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 75 :\r\n                // Hql.g:1:432: GE\r\n                {\r\n                \tmGE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 76 :\r\n                // Hql.g:1:435: BOR\r\n                {\r\n                \tmBOR(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 77 :\r\n                // Hql.g:1:439: BXOR\r\n                {\r\n                \tmBXOR(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 78 :\r\n                // Hql.g:1:444: BAND\r\n                {\r\n                \tmBAND(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 79 :\r\n                // Hql.g:1:449: BNOT\r\n                {\r\n                \tmBNOT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 80 :\r\n                // Hql.g:1:454: COMMA\r\n                {\r\n                \tmCOMMA(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 81 :\r\n                // Hql.g:1:460: OPEN\r\n                {\r\n                \tmOPEN(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 82 :\r\n                // Hql.g:1:465: CLOSE\r\n                {\r\n                \tmCLOSE(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 83 :\r\n                // Hql.g:1:471: OPEN_BRACKET\r\n                {\r\n                \tmOPEN_BRACKET(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 84 :\r\n                // Hql.g:1:484: CLOSE_BRACKET\r\n                {\r\n                \tmCLOSE_BRACKET(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 85 :\r\n                // Hql.g:1:498: CONCAT\r\n                {\r\n                \tmCONCAT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 86 :\r\n                // Hql.g:1:505: PLUS\r\n                {\r\n                \tmPLUS(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 87 :\r\n                // Hql.g:1:510: MINUS\r\n                {\r\n                \tmMINUS(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 88 :\r\n                // Hql.g:1:516: STAR\r\n                {\r\n                \tmSTAR(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 89 :\r\n                // Hql.g:1:521: DIV\r\n                {\r\n                \tmDIV(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 90 :\r\n                // Hql.g:1:525: COLON\r\n                {\r\n                \tmCOLON(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 91 :\r\n                // Hql.g:1:531: PARAM\r\n                {\r\n                \tmPARAM(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 92 :\r\n                // Hql.g:1:537: IDENT\r\n                {\r\n                \tmIDENT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 93 :\r\n                // Hql.g:1:543: QUOTED_String\r\n                {\r\n                \tmQUOTED_String(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 94 :\r\n                // Hql.g:1:557: WS\r\n                {\r\n                \tmWS(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n            case 95 :\r\n                // Hql.g:1:560: NUM_INT\r\n                {\r\n                \tmNUM_INT(); if (state.failed) return ;\r\n\r\n                }\r\n                break;\r\n\r\n        }\r\n\r\n    }",
      "nStatementSyntax": 97,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlLexer.cs",
      "SourceLine": 3493
    },
    {
      "TypeIdentifier": "HqlLexer",
      "MethodIdentifier": "mNUM_INT",
      "SourcesSample": "public void mNUM_INT() // throws RecognitionException [2]\r\n    {\r\n    \t\ttry\r\n    \t\t{\r\n            int _type = NUM_INT;\r\n    \tint _channel = DEFAULT_TOKEN_CHANNEL;\r\n            IToken f1 = null;\r\n            IToken f2 = null;\r\n            IToken f3 = null;\r\n            IToken f4 = null;\r\n\r\n            bool isDecimal=false; IToken t=null;\r\n            // Hql.g:759:2: ( '.' ( ( '0' .. '9' )+ ( EXPONENT )? (f1= FLOAT_SUFFIX )? )? | ( '0' ( ( 'x' ) ( HEX_DIGIT )+ | ( '0' .. '7' )+ )? | ( '1' .. '9' ) ( '0' .. '9' )* ) ( ( 'l' ) | {...}? ( '.' ( '0' .. '9' )* ( EXPONENT )? (f2= FLOAT_SUFFIX )? | EXPONENT (f3= FLOAT_SUFFIX )? | f4= FLOAT_SUFFIX ) )? )\r\n            int alt20 = 2;\r\n            int LA20_0 = input.LA(1);\r\n\r\n            if ( (LA20_0 == '.') )\r\n            {\r\n                alt20 = 1;\r\n            }\r\n            else if ( ((LA20_0 >= '0' && LA20_0 <= '9')) )\r\n            {\r\n                alt20 = 2;\r\n            }\r\n            else \r\n            {\r\n                if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                NoViableAltException nvae_d20s0 =\r\n                    new NoViableAltException(\"\", 20, 0, input);\r\n\r\n                throw nvae_d20s0;\r\n            }\r\n            switch (alt20) \r\n            {\r\n                case 1 :\r\n                    // Hql.g:759:6: '.' ( ( '0' .. '9' )+ ( EXPONENT )? (f1= FLOAT_SUFFIX )? )?\r\n                    {\r\n                    \tMatch('.'); if (state.failed) return ;\r\n                    \tif ( (state.backtracking==0) )\r\n                    \t{\r\n                    \t  _type = DOT;\r\n                    \t}\r\n                    \t// Hql.g:760:4: ( ( '0' .. '9' )+ ( EXPONENT )? (f1= FLOAT_SUFFIX )? )?\r\n                    \tint alt8 = 2;\r\n                    \tint LA8_0 = input.LA(1);\r\n\r\n                    \tif ( ((LA8_0 >= '0' && LA8_0 <= '9')) )\r\n                    \t{\r\n                    \t    alt8 = 1;\r\n                    \t}\r\n                    \tswitch (alt8) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:760:6: ( '0' .. '9' )+ ( EXPONENT )? (f1= FLOAT_SUFFIX )?\r\n                    \t        {\r\n                    \t        \t// Hql.g:760:6: ( '0' .. '9' )+\r\n                    \t        \tint cnt5 = 0;\r\n                    \t        \tdo \r\n                    \t        \t{\r\n                    \t        \t    int alt5 = 2;\r\n                    \t        \t    int LA5_0 = input.LA(1);\r\n\r\n                    \t        \t    if ( ((LA5_0 >= '0' && LA5_0 <= '9')) )\r\n                    \t        \t    {\r\n                    \t        \t        alt5 = 1;\r\n                    \t        \t    }\r\n\r\n\r\n                    \t        \t    switch (alt5) \r\n                    \t        \t\t{\r\n                    \t        \t\t\tcase 1 :\r\n                    \t        \t\t\t    // Hql.g:760:7: '0' .. '9'\r\n                    \t        \t\t\t    {\r\n                    \t        \t\t\t    \tMatchRange('0','9'); if (state.failed) return ;\r\n\r\n                    \t        \t\t\t    }\r\n                    \t        \t\t\t    break;\r\n\r\n                    \t        \t\t\tdefault:\r\n                    \t        \t\t\t    if ( cnt5 >= 1 ) goto loop5;\r\n                    \t        \t\t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                    \t        \t\t            EarlyExitException eee5 =\r\n                    \t        \t\t                new EarlyExitException(5, input);\r\n                    \t        \t\t            throw eee5;\r\n                    \t        \t    }\r\n                    \t        \t    cnt5++;\r\n                    \t        \t} while (true);\r\n\r\n                    \t        \tloop5:\r\n                    \t        \t\t;\t// Stops C# compiler whining that label 'loop5' has no statements\r\n\r\n                    \t        \t// Hql.g:760:18: ( EXPONENT )?\r\n                    \t        \tint alt6 = 2;\r\n                    \t        \tint LA6_0 = input.LA(1);\r\n\r\n                    \t        \tif ( (LA6_0 == 'e') )\r\n                    \t        \t{\r\n                    \t        \t    alt6 = 1;\r\n                    \t        \t}\r\n                    \t        \tswitch (alt6) \r\n                    \t        \t{\r\n                    \t        \t    case 1 :\r\n                    \t        \t        // Hql.g:760:19: EXPONENT\r\n                    \t        \t        {\r\n                    \t        \t        \tmEXPONENT(); if (state.failed) return ;\r\n\r\n                    \t        \t        }\r\n                    \t        \t        break;\r\n\r\n                    \t        \t}\r\n\r\n                    \t        \t// Hql.g:760:30: (f1= FLOAT_SUFFIX )?\r\n                    \t        \tint alt7 = 2;\r\n                    \t        \tint LA7_0 = input.LA(1);\r\n\r\n                    \t        \tif ( (LA7_0 == 'd' || LA7_0 == 'f' || LA7_0 == 'm') )\r\n                    \t        \t{\r\n                    \t        \t    alt7 = 1;\r\n                    \t        \t}\r\n                    \t        \tswitch (alt7) \r\n                    \t        \t{\r\n                    \t        \t    case 1 :\r\n                    \t        \t        // Hql.g:760:31: f1= FLOAT_SUFFIX\r\n                    \t        \t        {\r\n                    \t        \t        \tint f1Start1034 = CharIndex;\r\n                    \t        \t        \tmFLOAT_SUFFIX(); if (state.failed) return ;\r\n                    \t        \t        \tf1 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, f1Start1034, CharIndex-1);\r\n                    \t        \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t        \t{\r\n                    \t        \t        \t  t=f1;\r\n                    \t        \t        \t}\r\n\r\n                    \t        \t        }\r\n                    \t        \t        break;\r\n\r\n                    \t        \t}\r\n\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n\r\n                    \t        \t  \t\t\t\t\tif (t != null && t.Text.ToUpperInvariant().IndexOf('F')>=0)\r\n                    \t        \t  \t\t\t\t\t{\r\n                    \t        \t  \t\t\t\t\t\t_type = NUM_FLOAT;\r\n                    \t        \t  \t\t\t\t\t}\r\n                    \t        \t  \t\t\t\t\telse if (t != null && t.Text.ToUpperInvariant().IndexOf('M')>=0)\r\n                    \t        \t  \t\t\t\t\t{\r\n                    \t        \t  \t\t\t\t\t\t_type = NUM_DECIMAL;\r\n                    \t        \t  \t\t\t\t\t}\r\n                    \t        \t  \t\t\t\t\telse\r\n                    \t        \t  \t\t\t\t\t{\r\n                    \t        \t  \t\t\t\t\t\t_type = NUM_DOUBLE; // assume double\r\n                    \t        \t  \t\t\t\t\t}\r\n                    \t        \t  \t\t\t\t\r\n                    \t        \t}\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // Hql.g:776:4: ( '0' ( ( 'x' ) ( HEX_DIGIT )+ | ( '0' .. '7' )+ )? | ( '1' .. '9' ) ( '0' .. '9' )* ) ( ( 'l' ) | {...}? ( '.' ( '0' .. '9' )* ( EXPONENT )? (f2= FLOAT_SUFFIX )? | EXPONENT (f3= FLOAT_SUFFIX )? | f4= FLOAT_SUFFIX ) )?\r\n                    {\r\n                    \t// Hql.g:776:4: ( '0' ( ( 'x' ) ( HEX_DIGIT )+ | ( '0' .. '7' )+ )? | ( '1' .. '9' ) ( '0' .. '9' )* )\r\n                    \tint alt13 = 2;\r\n                    \tint LA13_0 = input.LA(1);\r\n\r\n                    \tif ( (LA13_0 == '0') )\r\n                    \t{\r\n                    \t    alt13 = 1;\r\n                    \t}\r\n                    \telse if ( ((LA13_0 >= '1' && LA13_0 <= '9')) )\r\n                    \t{\r\n                    \t    alt13 = 2;\r\n                    \t}\r\n                    \telse \r\n                    \t{\r\n                    \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                    \t    NoViableAltException nvae_d13s0 =\r\n                    \t        new NoViableAltException(\"\", 13, 0, input);\r\n\r\n                    \t    throw nvae_d13s0;\r\n                    \t}\r\n                    \tswitch (alt13) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:776:6: '0' ( ( 'x' ) ( HEX_DIGIT )+ | ( '0' .. '7' )+ )?\r\n                    \t        {\r\n                    \t        \tMatch('0'); if (state.failed) return ;\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n                    \t        \t  isDecimal = true;\r\n                    \t        \t}\r\n                    \t        \t// Hql.g:777:4: ( ( 'x' ) ( HEX_DIGIT )+ | ( '0' .. '7' )+ )?\r\n                    \t        \tint alt11 = 3;\r\n                    \t        \tint LA11_0 = input.LA(1);\r\n\r\n                    \t        \tif ( (LA11_0 == 'x') )\r\n                    \t        \t{\r\n                    \t        \t    alt11 = 1;\r\n                    \t        \t}\r\n                    \t        \telse if ( ((LA11_0 >= '0' && LA11_0 <= '7')) )\r\n                    \t        \t{\r\n                    \t        \t    alt11 = 2;\r\n                    \t        \t}\r\n                    \t        \tswitch (alt11) \r\n                    \t        \t{\r\n                    \t        \t    case 1 :\r\n                    \t        \t        // Hql.g:777:6: ( 'x' ) ( HEX_DIGIT )+\r\n                    \t        \t        {\r\n                    \t        \t        \t// Hql.g:777:6: ( 'x' )\r\n                    \t        \t        \t// Hql.g:777:7: 'x'\r\n                    \t        \t        \t{\r\n                    \t        \t        \t\tMatch('x'); if (state.failed) return ;\r\n\r\n                    \t        \t        \t}\r\n\r\n                    \t        \t        \t// Hql.g:778:5: ( HEX_DIGIT )+\r\n                    \t        \t        \tint cnt9 = 0;\r\n                    \t        \t        \tdo \r\n                    \t        \t        \t{\r\n                    \t        \t        \t    int alt9 = 2;\r\n                    \t        \t        \t    switch ( input.LA(1) ) \r\n                    \t        \t        \t    {\r\n                    \t        \t        \t    case 'e':\r\n                    \t        \t        \t    \t{\r\n                    \t        \t        \t        int LA9_2 = input.LA(2);\r\n\r\n                    \t        \t        \t        if ( ((LA9_2 >= '0' && LA9_2 <= '9')) )\r\n                    \t        \t        \t        {\r\n                    \t        \t        \t            int LA9_5 = input.LA(3);\r\n\r\n                    \t        \t        \t            if ( (!(((isDecimal)))) )\r\n                    \t        \t        \t            {\r\n                    \t        \t        \t                alt9 = 1;\r\n                    \t        \t        \t            }\r\n\r\n\r\n                    \t        \t        \t        }\r\n\r\n                    \t        \t        \t        else \r\n                    \t        \t        \t        {\r\n                    \t        \t        \t            alt9 = 1;\r\n                    \t        \t        \t        }\r\n\r\n                    \t        \t        \t        }\r\n                    \t        \t        \t        break;\r\n                    \t        \t        \t    case 'd':\r\n                    \t        \t        \t    case 'f':\r\n                    \t        \t        \t    \t{\r\n                    \t        \t        \t        int LA9_3 = input.LA(2);\r\n\r\n                    \t        \t        \t        if ( (!(((isDecimal)))) )\r\n                    \t        \t        \t        {\r\n                    \t        \t        \t            alt9 = 1;\r\n                    \t        \t        \t        }\r\n\r\n\r\n                    \t        \t        \t        }\r\n                    \t        \t        \t        break;\r\n                    \t        \t        \t    case '0':\r\n                    \t        \t        \t    case '1':\r\n                    \t        \t        \t    case '2':\r\n                    \t        \t        \t    case '3':\r\n                    \t        \t        \t    case '4':\r\n                    \t        \t        \t    case '5':\r\n                    \t        \t        \t    case '6':\r\n                    \t        \t        \t    case '7':\r\n                    \t        \t        \t    case '8':\r\n                    \t        \t        \t    case '9':\r\n                    \t        \t        \t    case 'a':\r\n                    \t        \t        \t    case 'b':\r\n                    \t        \t        \t    case 'c':\r\n                    \t        \t        \t    \t{\r\n                    \t        \t        \t        alt9 = 1;\r\n                    \t        \t        \t        }\r\n                    \t        \t        \t        break;\r\n\r\n                    \t        \t        \t    }\r\n\r\n                    \t        \t        \t    switch (alt9) \r\n                    \t        \t        \t\t{\r\n                    \t        \t        \t\t\tcase 1 :\r\n                    \t        \t        \t\t\t    // Hql.g:785:7: HEX_DIGIT\r\n                    \t        \t        \t\t\t    {\r\n                    \t        \t        \t\t\t    \tmHEX_DIGIT(); if (state.failed) return ;\r\n\r\n                    \t        \t        \t\t\t    }\r\n                    \t        \t        \t\t\t    break;\r\n\r\n                    \t        \t        \t\t\tdefault:\r\n                    \t        \t        \t\t\t    if ( cnt9 >= 1 ) goto loop9;\r\n                    \t        \t        \t\t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                    \t        \t        \t\t            EarlyExitException eee9 =\r\n                    \t        \t        \t\t                new EarlyExitException(9, input);\r\n                    \t        \t        \t\t            throw eee9;\r\n                    \t        \t        \t    }\r\n                    \t        \t        \t    cnt9++;\r\n                    \t        \t        \t} while (true);\r\n\r\n                    \t        \t        \tloop9:\r\n                    \t        \t        \t\t;\t// Stops C# compiler whining that label 'loop9' has no statements\r\n\r\n\r\n                    \t        \t        }\r\n                    \t        \t        break;\r\n                    \t        \t    case 2 :\r\n                    \t        \t        // Hql.g:787:6: ( '0' .. '7' )+\r\n                    \t        \t        {\r\n                    \t        \t        \t// Hql.g:787:6: ( '0' .. '7' )+\r\n                    \t        \t        \tint cnt10 = 0;\r\n                    \t        \t        \tdo \r\n                    \t        \t        \t{\r\n                    \t        \t        \t    int alt10 = 2;\r\n                    \t        \t        \t    int LA10_0 = input.LA(1);\r\n\r\n                    \t        \t        \t    if ( ((LA10_0 >= '0' && LA10_0 <= '7')) )\r\n                    \t        \t        \t    {\r\n                    \t        \t        \t        alt10 = 1;\r\n                    \t        \t        \t    }\r\n\r\n\r\n                    \t        \t        \t    switch (alt10) \r\n                    \t        \t        \t\t{\r\n                    \t        \t        \t\t\tcase 1 :\r\n                    \t        \t        \t\t\t    // Hql.g:787:7: '0' .. '7'\r\n                    \t        \t        \t\t\t    {\r\n                    \t        \t        \t\t\t    \tMatchRange('0','7'); if (state.failed) return ;\r\n\r\n                    \t        \t        \t\t\t    }\r\n                    \t        \t        \t\t\t    break;\r\n\r\n                    \t        \t        \t\t\tdefault:\r\n                    \t        \t        \t\t\t    if ( cnt10 >= 1 ) goto loop10;\r\n                    \t        \t        \t\t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                    \t        \t        \t\t            EarlyExitException eee10 =\r\n                    \t        \t        \t\t                new EarlyExitException(10, input);\r\n                    \t        \t        \t\t            throw eee10;\r\n                    \t        \t        \t    }\r\n                    \t        \t        \t    cnt10++;\r\n                    \t        \t        \t} while (true);\r\n\r\n                    \t        \t        \tloop10:\r\n                    \t        \t        \t\t;\t// Stops C# compiler whining that label 'loop10' has no statements\r\n\r\n\r\n                    \t        \t        }\r\n                    \t        \t        break;\r\n\r\n                    \t        \t}\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case 2 :\r\n                    \t        // Hql.g:789:5: ( '1' .. '9' ) ( '0' .. '9' )*\r\n                    \t        {\r\n                    \t        \t// Hql.g:789:5: ( '1' .. '9' )\r\n                    \t        \t// Hql.g:789:6: '1' .. '9'\r\n                    \t        \t{\r\n                    \t        \t\tMatchRange('1','9'); if (state.failed) return ;\r\n\r\n                    \t        \t}\r\n\r\n                    \t        \t// Hql.g:789:16: ( '0' .. '9' )*\r\n                    \t        \tdo \r\n                    \t        \t{\r\n                    \t        \t    int alt12 = 2;\r\n                    \t        \t    int LA12_0 = input.LA(1);\r\n\r\n                    \t        \t    if ( ((LA12_0 >= '0' && LA12_0 <= '9')) )\r\n                    \t        \t    {\r\n                    \t        \t        alt12 = 1;\r\n                    \t        \t    }\r\n\r\n\r\n                    \t        \t    switch (alt12) \r\n                    \t        \t\t{\r\n                    \t        \t\t\tcase 1 :\r\n                    \t        \t\t\t    // Hql.g:789:17: '0' .. '9'\r\n                    \t        \t\t\t    {\r\n                    \t        \t\t\t    \tMatchRange('0','9'); if (state.failed) return ;\r\n\r\n                    \t        \t\t\t    }\r\n                    \t        \t\t\t    break;\r\n\r\n                    \t        \t\t\tdefault:\r\n                    \t        \t\t\t    goto loop12;\r\n                    \t        \t    }\r\n                    \t        \t} while (true);\r\n\r\n                    \t        \tloop12:\r\n                    \t        \t\t;\t// Stops C# compiler whining that label 'loop12' has no statements\r\n\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n                    \t        \t  isDecimal=true;\r\n                    \t        \t}\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \t// Hql.g:791:3: ( ( 'l' ) | {...}? ( '.' ( '0' .. '9' )* ( EXPONENT )? (f2= FLOAT_SUFFIX )? | EXPONENT (f3= FLOAT_SUFFIX )? | f4= FLOAT_SUFFIX ) )?\r\n                    \tint alt19 = 3;\r\n                    \tint LA19_0 = input.LA(1);\r\n\r\n                    \tif ( (LA19_0 == 'l') )\r\n                    \t{\r\n                    \t    alt19 = 1;\r\n                    \t}\r\n                    \telse if ( (LA19_0 == '.' || (LA19_0 >= 'd' && LA19_0 <= 'f') || LA19_0 == 'm') )\r\n                    \t{\r\n                    \t    alt19 = 2;\r\n                    \t}\r\n                    \tswitch (alt19) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:791:5: ( 'l' )\r\n                    \t        {\r\n                    \t        \t// Hql.g:791:5: ( 'l' )\r\n                    \t        \t// Hql.g:791:6: 'l'\r\n                    \t        \t{\r\n                    \t        \t\tMatch('l'); if (state.failed) return ;\r\n\r\n                    \t        \t}\r\n\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n                    \t        \t   _type = NUM_LONG; \r\n                    \t        \t}\r\n\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case 2 :\r\n                    \t        // Hql.g:794:5: {...}? ( '.' ( '0' .. '9' )* ( EXPONENT )? (f2= FLOAT_SUFFIX )? | EXPONENT (f3= FLOAT_SUFFIX )? | f4= FLOAT_SUFFIX )\r\n                    \t        {\r\n                    \t        \tif ( !((isDecimal)) ) \r\n                    \t        \t{\r\n                    \t        \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                    \t        \t    throw new FailedPredicateException(input, \"NUM_INT\", \"isDecimal\");\r\n                    \t        \t}\r\n                    \t        \t// Hql.g:795:4: ( '.' ( '0' .. '9' )* ( EXPONENT )? (f2= FLOAT_SUFFIX )? | EXPONENT (f3= FLOAT_SUFFIX )? | f4= FLOAT_SUFFIX )\r\n                    \t        \tint alt18 = 3;\r\n                    \t        \tswitch ( input.LA(1) ) \r\n                    \t        \t{\r\n                    \t        \tcase '.':\r\n                    \t        \t\t{\r\n                    \t        \t    alt18 = 1;\r\n                    \t        \t    }\r\n                    \t        \t    break;\r\n                    \t        \tcase 'e':\r\n                    \t        \t\t{\r\n                    \t        \t    alt18 = 2;\r\n                    \t        \t    }\r\n                    \t        \t    break;\r\n                    \t        \tcase 'd':\r\n                    \t        \tcase 'f':\r\n                    \t        \tcase 'm':\r\n                    \t        \t\t{\r\n                    \t        \t    alt18 = 3;\r\n                    \t        \t    }\r\n                    \t        \t    break;\r\n                    \t        \t\tdefault:\r\n                    \t        \t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n                    \t        \t\t    NoViableAltException nvae_d18s0 =\r\n                    \t        \t\t        new NoViableAltException(\"\", 18, 0, input);\r\n\r\n                    \t        \t\t    throw nvae_d18s0;\r\n                    \t        \t}\r\n\r\n                    \t        \tswitch (alt18) \r\n                    \t        \t{\r\n                    \t        \t    case 1 :\r\n                    \t        \t        // Hql.g:795:8: '.' ( '0' .. '9' )* ( EXPONENT )? (f2= FLOAT_SUFFIX )?\r\n                    \t        \t        {\r\n                    \t        \t        \tMatch('.'); if (state.failed) return ;\r\n                    \t        \t        \t// Hql.g:795:12: ( '0' .. '9' )*\r\n                    \t        \t        \tdo \r\n                    \t        \t        \t{\r\n                    \t        \t        \t    int alt14 = 2;\r\n                    \t        \t        \t    int LA14_0 = input.LA(1);\r\n\r\n                    \t        \t        \t    if ( ((LA14_0 >= '0' && LA14_0 <= '9')) )\r\n                    \t        \t        \t    {\r\n                    \t        \t        \t        alt14 = 1;\r\n                    \t        \t        \t    }\r\n\r\n\r\n                    \t        \t        \t    switch (alt14) \r\n                    \t        \t        \t\t{\r\n                    \t        \t        \t\t\tcase 1 :\r\n                    \t        \t        \t\t\t    // Hql.g:795:13: '0' .. '9'\r\n                    \t        \t        \t\t\t    {\r\n                    \t        \t        \t\t\t    \tMatchRange('0','9'); if (state.failed) return ;\r\n\r\n                    \t        \t        \t\t\t    }\r\n                    \t        \t        \t\t\t    break;\r\n\r\n                    \t        \t        \t\t\tdefault:\r\n                    \t        \t        \t\t\t    goto loop14;\r\n                    \t        \t        \t    }\r\n                    \t        \t        \t} while (true);\r\n\r\n                    \t        \t        \tloop14:\r\n                    \t        \t        \t\t;\t// Stops C# compiler whining that label 'loop14' has no statements\r\n\r\n                    \t        \t        \t// Hql.g:795:24: ( EXPONENT )?\r\n                    \t        \t        \tint alt15 = 2;\r\n                    \t        \t        \tint LA15_0 = input.LA(1);\r\n\r\n                    \t        \t        \tif ( (LA15_0 == 'e') )\r\n                    \t        \t        \t{\r\n                    \t        \t        \t    alt15 = 1;\r\n                    \t        \t        \t}\r\n                    \t        \t        \tswitch (alt15) \r\n                    \t        \t        \t{\r\n                    \t        \t        \t    case 1 :\r\n                    \t        \t        \t        // Hql.g:795:25: EXPONENT\r\n                    \t        \t        \t        {\r\n                    \t        \t        \t        \tmEXPONENT(); if (state.failed) return ;\r\n\r\n                    \t        \t        \t        }\r\n                    \t        \t        \t        break;\r\n\r\n                    \t        \t        \t}\r\n\r\n                    \t        \t        \t// Hql.g:795:36: (f2= FLOAT_SUFFIX )?\r\n                    \t        \t        \tint alt16 = 2;\r\n                    \t        \t        \tint LA16_0 = input.LA(1);\r\n\r\n                    \t        \t        \tif ( (LA16_0 == 'd' || LA16_0 == 'f' || LA16_0 == 'm') )\r\n                    \t        \t        \t{\r\n                    \t        \t        \t    alt16 = 1;\r\n                    \t        \t        \t}\r\n                    \t        \t        \tswitch (alt16) \r\n                    \t        \t        \t{\r\n                    \t        \t        \t    case 1 :\r\n                    \t        \t        \t        // Hql.g:795:37: f2= FLOAT_SUFFIX\r\n                    \t        \t        \t        {\r\n                    \t        \t        \t        \tint f2Start1236 = CharIndex;\r\n                    \t        \t        \t        \tmFLOAT_SUFFIX(); if (state.failed) return ;\r\n                    \t        \t        \t        \tf2 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, f2Start1236, CharIndex-1);\r\n                    \t        \t        \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t        \t        \t{\r\n                    \t        \t        \t        \t  t=f2;\r\n                    \t        \t        \t        \t}\r\n\r\n                    \t        \t        \t        }\r\n                    \t        \t        \t        break;\r\n\r\n                    \t        \t        \t}\r\n\r\n\r\n                    \t        \t        }\r\n                    \t        \t        break;\r\n                    \t        \t    case 2 :\r\n                    \t        \t        // Hql.g:796:8: EXPONENT (f3= FLOAT_SUFFIX )?\r\n                    \t        \t        {\r\n                    \t        \t        \tmEXPONENT(); if (state.failed) return ;\r\n                    \t        \t        \t// Hql.g:796:17: (f3= FLOAT_SUFFIX )?\r\n                    \t        \t        \tint alt17 = 2;\r\n                    \t        \t        \tint LA17_0 = input.LA(1);\r\n\r\n                    \t        \t        \tif ( (LA17_0 == 'd' || LA17_0 == 'f' || LA17_0 == 'm') )\r\n                    \t        \t        \t{\r\n                    \t        \t        \t    alt17 = 1;\r\n                    \t        \t        \t}\r\n                    \t        \t        \tswitch (alt17) \r\n                    \t        \t        \t{\r\n                    \t        \t        \t    case 1 :\r\n                    \t        \t        \t        // Hql.g:796:18: f3= FLOAT_SUFFIX\r\n                    \t        \t        \t        {\r\n                    \t        \t        \t        \tint f3Start1254 = CharIndex;\r\n                    \t        \t        \t        \tmFLOAT_SUFFIX(); if (state.failed) return ;\r\n                    \t        \t        \t        \tf3 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, f3Start1254, CharIndex-1);\r\n                    \t        \t        \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t        \t        \t{\r\n                    \t        \t        \t        \t  t=f3;\r\n                    \t        \t        \t        \t}\r\n\r\n                    \t        \t        \t        }\r\n                    \t        \t        \t        break;\r\n\r\n                    \t        \t        \t}\r\n\r\n\r\n                    \t        \t        }\r\n                    \t        \t        break;\r\n                    \t        \t    case 3 :\r\n                    \t        \t        // Hql.g:797:8: f4= FLOAT_SUFFIX\r\n                    \t        \t        {\r\n                    \t        \t        \tint f4Start1269 = CharIndex;\r\n                    \t        \t        \tmFLOAT_SUFFIX(); if (state.failed) return ;\r\n                    \t        \t        \tf4 = new CommonToken(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, f4Start1269, CharIndex-1);\r\n                    \t        \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t        \t{\r\n                    \t        \t        \t  t=f4;\r\n                    \t        \t        \t}\r\n\r\n                    \t        \t        }\r\n                    \t        \t        break;\r\n\r\n                    \t        \t}\r\n\r\n                    \t        \tif ( (state.backtracking==0) )\r\n                    \t        \t{\r\n\r\n                    \t        \t  \t\t\t\tif (t != null && t.Text.ToUpperInvariant().IndexOf('F') >= 0)\r\n                    \t        \t  \t\t\t\t{\r\n                    \t        \t  \t\t\t\t\t_type = NUM_FLOAT;\r\n                    \t        \t  \t\t\t\t}\r\n                    \t        \t  \t\t\t\telse if (t != null && t.Text.ToUpperInvariant().IndexOf('M')>=0)\r\n                    \t        \t  \t\t\t\t{\r\n                    \t        \t  \t\t\t\t\t_type = NUM_DECIMAL;\r\n                    \t        \t  \t\t\t\t}\r\n                    \t        \t  \t\t\t\telse\r\n                    \t        \t  \t\t\t\t{\r\n                    \t        \t  \t\t\t\t\t_type = NUM_DOUBLE; // assume double\r\n                    \t        \t  \t\t\t\t}\r\n                    \t        \t  \t\t\t\r\n                    \t        \t}\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n            state.type = _type;\r\n            state.channel = _channel;\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n    }",
      "nStatementSyntax": 88,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlLexer.cs",
      "SourceLine": 2695
    },
    {
      "TypeIdentifier": "HqlLexer",
      "MethodIdentifier": "mEXPONENT",
      "SourcesSample": "public void mEXPONENT() // throws RecognitionException [2]\r\n    {\r\n    \t\ttry\r\n    \t\t{\r\n            // Hql.g:825:2: ( ( 'e' ) ( '+' | '-' )? ( '0' .. '9' )+ )\r\n            // Hql.g:825:4: ( 'e' ) ( '+' | '-' )? ( '0' .. '9' )+\r\n            {\r\n            \t// Hql.g:825:4: ( 'e' )\r\n            \t// Hql.g:825:5: 'e'\r\n            \t{\r\n            \t\tMatch('e'); if (state.failed) return ;\r\n\r\n            \t}\r\n\r\n            \t// Hql.g:825:10: ( '+' | '-' )?\r\n            \tint alt21 = 2;\r\n            \tint LA21_0 = input.LA(1);\r\n\r\n            \tif ( (LA21_0 == '+' || LA21_0 == '-') )\r\n            \t{\r\n            \t    alt21 = 1;\r\n            \t}\r\n            \tswitch (alt21) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:\r\n            \t        {\r\n            \t        \tif ( input.LA(1) == '+' || input.LA(1) == '-' ) \r\n            \t        \t{\r\n            \t        \t    input.Consume();\r\n            \t        \tstate.failed = false;\r\n            \t        \t}\r\n            \t        \telse \r\n            \t        \t{\r\n            \t        \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t        \t    MismatchedSetException mse = new MismatchedSetException(null,input);\r\n            \t        \t    Recover(mse);\r\n            \t        \t    throw mse;}\r\n\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// Hql.g:825:21: ( '0' .. '9' )+\r\n            \tint cnt22 = 0;\r\n            \tdo \r\n            \t{\r\n            \t    int alt22 = 2;\r\n            \t    int LA22_0 = input.LA(1);\r\n\r\n            \t    if ( ((LA22_0 >= '0' && LA22_0 <= '9')) )\r\n            \t    {\r\n            \t        alt22 = 1;\r\n            \t    }\r\n\r\n\r\n            \t    switch (alt22) \r\n            \t\t{\r\n            \t\t\tcase 1 :\r\n            \t\t\t    // Hql.g:825:22: '0' .. '9'\r\n            \t\t\t    {\r\n            \t\t\t    \tMatchRange('0','9'); if (state.failed) return ;\r\n\r\n            \t\t\t    }\r\n            \t\t\t    break;\r\n\r\n            \t\t\tdefault:\r\n            \t\t\t    if ( cnt22 >= 1 ) goto loop22;\r\n            \t\t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t\t            EarlyExitException eee22 =\r\n            \t\t                new EarlyExitException(22, input);\r\n            \t\t            throw eee22;\r\n            \t    }\r\n            \t    cnt22++;\r\n            \t} while (true);\r\n\r\n            \tloop22:\r\n            \t\t;\t// Stops C# compiler whining that label 'loop22' has no statements\r\n\r\n\r\n            }\r\n\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n    }",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlLexer.cs",
      "SourceLine": 3372
    },
    {
      "TypeIdentifier": "HqlLexer",
      "MethodIdentifier": "mWS",
      "SourcesSample": "public void mWS() // throws RecognitionException [2]\r\n    {\r\n    \t\ttry\r\n    \t\t{\r\n            int _type = WS;\r\n    \tint _channel = DEFAULT_TOKEN_CHANNEL;\r\n            // Hql.g:746:5: ( ( ' ' | '\\\\t' | '\\\\r' '\\\\n' | '\\\\n' | '\\\\r' ) )\r\n            // Hql.g:746:9: ( ' ' | '\\\\t' | '\\\\r' '\\\\n' | '\\\\n' | '\\\\r' )\r\n            {\r\n            \t// Hql.g:746:9: ( ' ' | '\\\\t' | '\\\\r' '\\\\n' | '\\\\n' | '\\\\r' )\r\n            \tint alt4 = 5;\r\n            \tswitch ( input.LA(1) ) \r\n            \t{\r\n            \tcase ' ':\r\n            \t\t{\r\n            \t    alt4 = 1;\r\n            \t    }\r\n            \t    break;\r\n            \tcase '\\t':\r\n            \t\t{\r\n            \t    alt4 = 2;\r\n            \t    }\r\n            \t    break;\r\n            \tcase '\\r':\r\n            \t\t{\r\n            \t    int LA4_3 = input.LA(2);\r\n\r\n            \t    if ( (LA4_3 == '\\n') )\r\n            \t    {\r\n            \t        alt4 = 3;\r\n            \t    }\r\n            \t    else \r\n            \t    {\r\n            \t        alt4 = 5;}\r\n            \t    }\r\n            \t    break;\r\n            \tcase '\\n':\r\n            \t\t{\r\n            \t    alt4 = 4;\r\n            \t    }\r\n            \t    break;\r\n            \t\tdefault:\r\n            \t\t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t\t    NoViableAltException nvae_d4s0 =\r\n            \t\t        new NoViableAltException(\"\", 4, 0, input);\r\n\r\n            \t\t    throw nvae_d4s0;\r\n            \t}\r\n\r\n            \tswitch (alt4) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:746:13: ' '\r\n            \t        {\r\n            \t        \tMatch(' '); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 2 :\r\n            \t        // Hql.g:747:7: '\\\\t'\r\n            \t        {\r\n            \t        \tMatch('\\t'); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 3 :\r\n            \t        // Hql.g:748:7: '\\\\r' '\\\\n'\r\n            \t        {\r\n            \t        \tMatch('\\r'); if (state.failed) return ;\r\n            \t        \tMatch('\\n'); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 4 :\r\n            \t        // Hql.g:749:7: '\\\\n'\r\n            \t        {\r\n            \t        \tMatch('\\n'); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 5 :\r\n            \t        // Hql.g:750:7: '\\\\r'\r\n            \t        {\r\n            \t        \tMatch('\\r'); if (state.failed) return ;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \tif ( (state.backtracking==0) )\r\n            \t{\r\n            \t  Skip();\r\n            \t}\r\n\r\n            }\r\n\r\n            state.type = _type;\r\n            state.channel = _channel;\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n    }",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlLexer.cs",
      "SourceLine": 2588
    },
    {
      "TypeIdentifier": "HqlLexer",
      "MethodIdentifier": "mQUOTED_String",
      "SourcesSample": "public void mQUOTED_String() // throws RecognitionException [2]\r\n    {\r\n    \t\ttry\r\n    \t\t{\r\n            int _type = QUOTED_String;\r\n    \tint _channel = DEFAULT_TOKEN_CHANNEL;\r\n            // Hql.g:737:4: ( '\\\\'' ( ( ESCqs )=> ESCqs | ~ '\\\\'' )* '\\\\'' )\r\n            // Hql.g:737:6: '\\\\'' ( ( ESCqs )=> ESCqs | ~ '\\\\'' )* '\\\\''\r\n            {\r\n            \tMatch('\\''); if (state.failed) return ;\r\n            \t// Hql.g:737:11: ( ( ESCqs )=> ESCqs | ~ '\\\\'' )*\r\n            \tdo \r\n            \t{\r\n            \t    int alt3 = 3;\r\n            \t    int LA3_0 = input.LA(1);\r\n\r\n            \t    if ( (LA3_0 == '\\'') )\r\n            \t    {\r\n            \t        int LA3_1 = input.LA(2);\r\n\r\n            \t        if ( (LA3_1 == '\\'') && (synpred1_Hql()) )\r\n            \t        {\r\n            \t            alt3 = 1;\r\n            \t        }\r\n\r\n\r\n            \t    }\r\n            \t    else if ( ((LA3_0 >= '\\u0000' && LA3_0 <= '&') || (LA3_0 >= '(' && LA3_0 <= '\\uFFFF')) )\r\n            \t    {\r\n            \t        alt3 = 2;\r\n            \t    }\r\n\r\n\r\n            \t    switch (alt3) \r\n            \t\t{\r\n            \t\t\tcase 1 :\r\n            \t\t\t    // Hql.g:737:13: ( ESCqs )=> ESCqs\r\n            \t\t\t    {\r\n            \t\t\t    \tmESCqs(); if (state.failed) return ;\r\n\r\n            \t\t\t    }\r\n            \t\t\t    break;\r\n            \t\t\tcase 2 :\r\n            \t\t\t    // Hql.g:737:31: ~ '\\\\''\r\n            \t\t\t    {\r\n            \t\t\t    \tif ( (input.LA(1) >= '\\u0000' && input.LA(1) <= '&') || (input.LA(1) >= '(' && input.LA(1) <= '\\uFFFF') ) \r\n            \t\t\t    \t{\r\n            \t\t\t    \t    input.Consume();\r\n            \t\t\t    \tstate.failed = false;\r\n            \t\t\t    \t}\r\n            \t\t\t    \telse \r\n            \t\t\t    \t{\r\n            \t\t\t    \t    if ( state.backtracking > 0 ) {state.failed = true; return ;}\r\n            \t\t\t    \t    MismatchedSetException mse = new MismatchedSetException(null,input);\r\n            \t\t\t    \t    Recover(mse);\r\n            \t\t\t    \t    throw mse;}\r\n\r\n\r\n            \t\t\t    }\r\n            \t\t\t    break;\r\n\r\n            \t\t\tdefault:\r\n            \t\t\t    goto loop3;\r\n            \t    }\r\n            \t} while (true);\r\n\r\n            \tloop3:\r\n            \t\t;\t// Stops C# compiler whining that label 'loop3' has no statements\r\n\r\n            \tMatch('\\''); if (state.failed) return ;\r\n\r\n            }\r\n\r\n            state.type = _type;\r\n            state.channel = _channel;\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n    }",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlLexer.cs",
      "SourceLine": 2485
    }
  ],
  [
    {
      "TypeIdentifier": "HqlParser",
      "MethodIdentifier": "fromJoin",
      "SourcesSample": "public HqlParser.fromJoin_return fromJoin() // throws RecognitionException [1]\r\n    {   \r\n        HqlParser.fromJoin_return retval = new HqlParser.fromJoin_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IToken set63 = null;\r\n        IToken OUTER64 = null;\r\n        IToken FULL65 = null;\r\n        IToken INNER66 = null;\r\n        IToken JOIN67 = null;\r\n        IToken FETCH68 = null;\r\n        IToken set73 = null;\r\n        IToken OUTER74 = null;\r\n        IToken FULL75 = null;\r\n        IToken INNER76 = null;\r\n        IToken JOIN77 = null;\r\n        IToken FETCH78 = null;\r\n        IToken ELEMENTS79 = null;\r\n        IToken OPEN80 = null;\r\n        IToken CLOSE82 = null;\r\n        HqlParser.path_return path69 = default(HqlParser.path_return);\r\n\r\n        HqlParser.asAlias_return asAlias70 = default(HqlParser.asAlias_return);\r\n\r\n        HqlParser.propertyFetch_return propertyFetch71 = default(HqlParser.propertyFetch_return);\r\n\r\n        HqlParser.withClause_return withClause72 = default(HqlParser.withClause_return);\r\n\r\n        HqlParser.path_return path81 = default(HqlParser.path_return);\r\n\r\n        HqlParser.asAlias_return asAlias83 = default(HqlParser.asAlias_return);\r\n\r\n        HqlParser.propertyFetch_return propertyFetch84 = default(HqlParser.propertyFetch_return);\r\n\r\n        HqlParser.withClause_return withClause85 = default(HqlParser.withClause_return);\r\n\r\n\r\n        IASTNode set63_tree=null;\r\n        IASTNode OUTER64_tree=null;\r\n        IASTNode FULL65_tree=null;\r\n        IASTNode INNER66_tree=null;\r\n        IASTNode JOIN67_tree=null;\r\n        IASTNode FETCH68_tree=null;\r\n        IASTNode set73_tree=null;\r\n        IASTNode OUTER74_tree=null;\r\n        IASTNode FULL75_tree=null;\r\n        IASTNode INNER76_tree=null;\r\n        IASTNode JOIN77_tree=null;\r\n        IASTNode FETCH78_tree=null;\r\n        IASTNode ELEMENTS79_tree=null;\r\n        IASTNode OPEN80_tree=null;\r\n        IASTNode CLOSE82_tree=null;\r\n\r\n        try \r\n    \t{\r\n            // Hql.g:246:2: ( ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )? | ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ( FETCH )? ELEMENTS OPEN path CLOSE ( asAlias )? ( propertyFetch )? ( withClause )? )\r\n            int alt32 = 2;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case LEFT:\r\n            case RIGHT:\r\n            \t{\r\n                int LA32_1 = input.LA(2);\r\n\r\n                if ( (LA32_1 == OUTER) )\r\n                {\r\n                    int LA32_5 = input.LA(3);\r\n\r\n                    if ( (LA32_5 == JOIN) )\r\n                    {\r\n                        switch ( input.LA(4) ) \r\n                        {\r\n                        case FETCH:\r\n                        \t{\r\n                            int LA32_6 = input.LA(5);\r\n\r\n                            if ( (LA32_6 == ELEMENTS) )\r\n                            {\r\n                                alt32 = 2;\r\n                            }\r\n                            else if ( (LA32_6 == IDENT) )\r\n                            {\r\n                                alt32 = 1;\r\n                            }\r\n                            else \r\n                            {\r\n                                NoViableAltException nvae_d32s6 =\r\n                                    new NoViableAltException(\"\", 32, 6, input);\r\n\r\n                                throw nvae_d32s6;\r\n                            }\r\n                            }\r\n                            break;\r\n                        case ELEMENTS:\r\n                        \t{\r\n                            alt32 = 2;\r\n                            }\r\n                            break;\r\n                        case IDENT:\r\n                        \t{\r\n                            alt32 = 1;\r\n                            }\r\n                            break;\r\n                        \tdefault:\r\n                        \t    NoViableAltException nvae_d32s4 =\r\n                        \t        new NoViableAltException(\"\", 32, 4, input);\r\n\r\n                        \t    throw nvae_d32s4;\r\n                        }\r\n\r\n                    }\r\n                    else \r\n                    {\r\n                        NoViableAltException nvae_d32s5 =\r\n                            new NoViableAltException(\"\", 32, 5, input);\r\n\r\n                        throw nvae_d32s5;\r\n                    }\r\n                }\r\n                else if ( (LA32_1 == JOIN) )\r\n                {\r\n                    switch ( input.LA(3) ) \r\n                    {\r\n                    case FETCH:\r\n                    \t{\r\n                        int LA32_6 = input.LA(4);\r\n\r\n                        if ( (LA32_6 == ELEMENTS) )\r\n                        {\r\n                            alt32 = 2;\r\n                        }\r\n                        else if ( (LA32_6 == IDENT) )\r\n                        {\r\n                            alt32 = 1;\r\n                        }\r\n                        else \r\n                        {\r\n                            NoViableAltException nvae_d32s6 =\r\n                                new NoViableAltException(\"\", 32, 6, input);\r\n\r\n                            throw nvae_d32s6;\r\n                        }\r\n                        }\r\n                        break;\r\n                    case ELEMENTS:\r\n                    \t{\r\n                        alt32 = 2;\r\n                        }\r\n                        break;\r\n                    case IDENT:\r\n                    \t{\r\n                        alt32 = 1;\r\n                        }\r\n                        break;\r\n                    \tdefault:\r\n                    \t    NoViableAltException nvae_d32s4 =\r\n                    \t        new NoViableAltException(\"\", 32, 4, input);\r\n\r\n                    \t    throw nvae_d32s4;\r\n                    }\r\n\r\n                }\r\n                else \r\n                {\r\n                    NoViableAltException nvae_d32s1 =\r\n                        new NoViableAltException(\"\", 32, 1, input);\r\n\r\n                    throw nvae_d32s1;\r\n                }\r\n                }\r\n                break;\r\n            case FULL:\r\n            \t{\r\n                int LA32_2 = input.LA(2);\r\n\r\n                if ( (LA32_2 == JOIN) )\r\n                {\r\n                    switch ( input.LA(3) ) \r\n                    {\r\n                    case FETCH:\r\n                    \t{\r\n                        int LA32_6 = input.LA(4);\r\n\r\n                        if ( (LA32_6 == ELEMENTS) )\r\n                        {\r\n                            alt32 = 2;\r\n                        }\r\n                        else if ( (LA32_6 == IDENT) )\r\n                        {\r\n                            alt32 = 1;\r\n                        }\r\n                        else \r\n                        {\r\n                            NoViableAltException nvae_d32s6 =\r\n                                new NoViableAltException(\"\", 32, 6, input);\r\n\r\n                            throw nvae_d32s6;\r\n                        }\r\n                        }\r\n                        break;\r\n                    case ELEMENTS:\r\n                    \t{\r\n                        alt32 = 2;\r\n                        }\r\n                        break;\r\n                    case IDENT:\r\n                    \t{\r\n                        alt32 = 1;\r\n                        }\r\n                        break;\r\n                    \tdefault:\r\n                    \t    NoViableAltException nvae_d32s4 =\r\n                    \t        new NoViableAltException(\"\", 32, 4, input);\r\n\r\n                    \t    throw nvae_d32s4;\r\n                    }\r\n\r\n                }\r\n                else \r\n                {\r\n                    NoViableAltException nvae_d32s2 =\r\n                        new NoViableAltException(\"\", 32, 2, input);\r\n\r\n                    throw nvae_d32s2;\r\n                }\r\n                }\r\n                break;\r\n            case INNER:\r\n            \t{\r\n                int LA32_3 = input.LA(2);\r\n\r\n                if ( (LA32_3 == JOIN) )\r\n                {\r\n                    switch ( input.LA(3) ) \r\n                    {\r\n                    case FETCH:\r\n                    \t{\r\n                        int LA32_6 = input.LA(4);\r\n\r\n                        if ( (LA32_6 == ELEMENTS) )\r\n                        {\r\n                            alt32 = 2;\r\n                        }\r\n                        else if ( (LA32_6 == IDENT) )\r\n                        {\r\n                            alt32 = 1;\r\n                        }\r\n                        else \r\n                        {\r\n                            NoViableAltException nvae_d32s6 =\r\n                                new NoViableAltException(\"\", 32, 6, input);\r\n\r\n                            throw nvae_d32s6;\r\n                        }\r\n                        }\r\n                        break;\r\n                    case ELEMENTS:\r\n                    \t{\r\n                        alt32 = 2;\r\n                        }\r\n                        break;\r\n                    case IDENT:\r\n                    \t{\r\n                        alt32 = 1;\r\n                        }\r\n                        break;\r\n                    \tdefault:\r\n                    \t    NoViableAltException nvae_d32s4 =\r\n                    \t        new NoViableAltException(\"\", 32, 4, input);\r\n\r\n                    \t    throw nvae_d32s4;\r\n                    }\r\n\r\n                }\r\n                else \r\n                {\r\n                    NoViableAltException nvae_d32s3 =\r\n                        new NoViableAltException(\"\", 32, 3, input);\r\n\r\n                    throw nvae_d32s3;\r\n                }\r\n                }\r\n                break;\r\n            case JOIN:\r\n            \t{\r\n                switch ( input.LA(2) ) \r\n                {\r\n                case FETCH:\r\n                \t{\r\n                    int LA32_6 = input.LA(3);\r\n\r\n                    if ( (LA32_6 == ELEMENTS) )\r\n                    {\r\n                        alt32 = 2;\r\n                    }\r\n                    else if ( (LA32_6 == IDENT) )\r\n                    {\r\n                        alt32 = 1;\r\n                    }\r\n                    else \r\n                    {\r\n                        NoViableAltException nvae_d32s6 =\r\n                            new NoViableAltException(\"\", 32, 6, input);\r\n\r\n                        throw nvae_d32s6;\r\n                    }\r\n                    }\r\n                    break;\r\n                case ELEMENTS:\r\n                \t{\r\n                    alt32 = 2;\r\n                    }\r\n                    break;\r\n                case IDENT:\r\n                \t{\r\n                    alt32 = 1;\r\n                    }\r\n                    break;\r\n                \tdefault:\r\n                \t    NoViableAltException nvae_d32s4 =\r\n                \t        new NoViableAltException(\"\", 32, 4, input);\r\n\r\n                \t    throw nvae_d32s4;\r\n                }\r\n\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    NoViableAltException nvae_d32s0 =\r\n            \t        new NoViableAltException(\"\", 32, 0, input);\r\n\r\n            \t    throw nvae_d32s0;\r\n            }\r\n\r\n            switch (alt32) \r\n            {\r\n                case 1 :\r\n                    // Hql.g:246:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ( FETCH )? path ( asAlias )? ( propertyFetch )? ( withClause )?\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \t// Hql.g:246:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )?\r\n                    \tint alt21 = 4;\r\n                    \tswitch ( input.LA(1) ) \r\n                    \t{\r\n                    \t    case LEFT:\r\n                    \t    case RIGHT:\r\n                    \t    \t{\r\n                    \t        alt21 = 1;\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case FULL:\r\n                    \t    \t{\r\n                    \t        alt21 = 2;\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case INNER:\r\n                    \t    \t{\r\n                    \t        alt21 = 3;\r\n                    \t        }\r\n                    \t        break;\r\n                    \t}\r\n\r\n                    \tswitch (alt21) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:246:6: ( ( LEFT | RIGHT ) ( OUTER )? )\r\n                    \t        {\r\n                    \t        \t// Hql.g:246:6: ( ( LEFT | RIGHT ) ( OUTER )? )\r\n                    \t        \t// Hql.g:246:8: ( LEFT | RIGHT ) ( OUTER )?\r\n                    \t        \t{\r\n                    \t        \t\tset63 = (IToken)input.LT(1);\r\n                    \t        \t\tif ( input.LA(1) == LEFT || input.LA(1) == RIGHT ) \r\n                    \t        \t\t{\r\n                    \t        \t\t    input.Consume();\r\n                    \t        \t\t    adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set63));\r\n                    \t        \t\t    state.errorRecovery = false;\r\n                    \t        \t\t}\r\n                    \t        \t\telse \r\n                    \t        \t\t{\r\n                    \t        \t\t    MismatchedSetException mse = new MismatchedSetException(null,input);\r\n                    \t        \t\t    throw mse;\r\n                    \t        \t\t}\r\n\r\n                    \t        \t\t// Hql.g:246:25: ( OUTER )?\r\n                    \t        \t\tint alt20 = 2;\r\n                    \t        \t\tint LA20_0 = input.LA(1);\r\n\r\n                    \t        \t\tif ( (LA20_0 == OUTER) )\r\n                    \t        \t\t{\r\n                    \t        \t\t    alt20 = 1;\r\n                    \t        \t\t}\r\n                    \t        \t\tswitch (alt20) \r\n                    \t        \t\t{\r\n                    \t        \t\t    case 1 :\r\n                    \t        \t\t        // Hql.g:246:26: OUTER\r\n                    \t        \t\t        {\r\n                    \t        \t\t        \tOUTER64=(IToken)Match(input,OUTER,FOLLOW_OUTER_in_fromJoin1180); \r\n                    \t        \t\t        \t\tOUTER64_tree = (IASTNode)adaptor.Create(OUTER64);\r\n                    \t        \t\t        \t\tadaptor.AddChild(root_0, OUTER64_tree);\r\n\r\n\r\n                    \t        \t\t        }\r\n                    \t        \t\t        break;\r\n\r\n                    \t        \t\t}\r\n\r\n\r\n                    \t        \t}\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case 2 :\r\n                    \t        // Hql.g:246:38: FULL\r\n                    \t        {\r\n                    \t        \tFULL65=(IToken)Match(input,FULL,FOLLOW_FULL_in_fromJoin1188); \r\n                    \t        \t\tFULL65_tree = (IASTNode)adaptor.Create(FULL65);\r\n                    \t        \t\tadaptor.AddChild(root_0, FULL65_tree);\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case 3 :\r\n                    \t        // Hql.g:246:45: INNER\r\n                    \t        {\r\n                    \t        \tINNER66=(IToken)Match(input,INNER,FOLLOW_INNER_in_fromJoin1192); \r\n                    \t        \t\tINNER66_tree = (IASTNode)adaptor.Create(INNER66);\r\n                    \t        \t\tadaptor.AddChild(root_0, INNER66_tree);\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tJOIN67=(IToken)Match(input,JOIN,FOLLOW_JOIN_in_fromJoin1197); \r\n                    \t\tJOIN67_tree = (IASTNode)adaptor.Create(JOIN67);\r\n                    \t\troot_0 = (IASTNode)adaptor.BecomeRoot(JOIN67_tree, root_0);\r\n\r\n                    \t// Hql.g:246:60: ( FETCH )?\r\n                    \tint alt22 = 2;\r\n                    \tint LA22_0 = input.LA(1);\r\n\r\n                    \tif ( (LA22_0 == FETCH) )\r\n                    \t{\r\n                    \t    alt22 = 1;\r\n                    \t}\r\n                    \tswitch (alt22) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:246:61: FETCH\r\n                    \t        {\r\n                    \t        \tFETCH68=(IToken)Match(input,FETCH,FOLLOW_FETCH_in_fromJoin1201); \r\n                    \t        \t\tFETCH68_tree = (IASTNode)adaptor.Create(FETCH68);\r\n                    \t        \t\tadaptor.AddChild(root_0, FETCH68_tree);\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tPushFollow(FOLLOW_path_in_fromJoin1205);\r\n                    \tpath69 = path();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tadaptor.AddChild(root_0, path69.Tree);\r\n                    \t// Hql.g:246:74: ( asAlias )?\r\n                    \tint alt23 = 2;\r\n                    \tint LA23_0 = input.LA(1);\r\n\r\n                    \tif ( (LA23_0 == AS || LA23_0 == IDENT) )\r\n                    \t{\r\n                    \t    alt23 = 1;\r\n                    \t}\r\n                    \tswitch (alt23) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:246:75: asAlias\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_asAlias_in_fromJoin1208);\r\n                    \t        \tasAlias70 = asAlias();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_0, asAlias70.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \t// Hql.g:246:85: ( propertyFetch )?\r\n                    \tint alt24 = 2;\r\n                    \tint LA24_0 = input.LA(1);\r\n\r\n                    \tif ( (LA24_0 == FETCH) )\r\n                    \t{\r\n                    \t    alt24 = 1;\r\n                    \t}\r\n                    \tswitch (alt24) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:246:86: propertyFetch\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_propertyFetch_in_fromJoin1213);\r\n                    \t        \tpropertyFetch71 = propertyFetch();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_0, propertyFetch71.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \t// Hql.g:246:102: ( withClause )?\r\n                    \tint alt25 = 2;\r\n                    \tint LA25_0 = input.LA(1);\r\n\r\n                    \tif ( (LA25_0 == WITH) )\r\n                    \t{\r\n                    \t    alt25 = 1;\r\n                    \t}\r\n                    \tswitch (alt25) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:246:103: withClause\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_withClause_in_fromJoin1218);\r\n                    \t        \twithClause72 = withClause();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_0, withClause72.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // Hql.g:247:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )? JOIN ( FETCH )? ELEMENTS OPEN path CLOSE ( asAlias )? ( propertyFetch )? ( withClause )?\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \t// Hql.g:247:4: ( ( ( LEFT | RIGHT ) ( OUTER )? ) | FULL | INNER )?\r\n                    \tint alt27 = 4;\r\n                    \tswitch ( input.LA(1) ) \r\n                    \t{\r\n                    \t    case LEFT:\r\n                    \t    case RIGHT:\r\n                    \t    \t{\r\n                    \t        alt27 = 1;\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case FULL:\r\n                    \t    \t{\r\n                    \t        alt27 = 2;\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case INNER:\r\n                    \t    \t{\r\n                    \t        alt27 = 3;\r\n                    \t        }\r\n                    \t        break;\r\n                    \t}\r\n\r\n                    \tswitch (alt27) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:247:6: ( ( LEFT | RIGHT ) ( OUTER )? )\r\n                    \t        {\r\n                    \t        \t// Hql.g:247:6: ( ( LEFT | RIGHT ) ( OUTER )? )\r\n                    \t        \t// Hql.g:247:8: ( LEFT | RIGHT ) ( OUTER )?\r\n                    \t        \t{\r\n                    \t        \t\tset73 = (IToken)input.LT(1);\r\n                    \t        \t\tif ( input.LA(1) == LEFT || input.LA(1) == RIGHT ) \r\n                    \t        \t\t{\r\n                    \t        \t\t    input.Consume();\r\n                    \t        \t\t    adaptor.AddChild(root_0, (IASTNode)adaptor.Create(set73));\r\n                    \t        \t\t    state.errorRecovery = false;\r\n                    \t        \t\t}\r\n                    \t        \t\telse \r\n                    \t        \t\t{\r\n                    \t        \t\t    MismatchedSetException mse = new MismatchedSetException(null,input);\r\n                    \t        \t\t    throw mse;\r\n                    \t        \t\t}\r\n\r\n                    \t        \t\t// Hql.g:247:25: ( OUTER )?\r\n                    \t        \t\tint alt26 = 2;\r\n                    \t        \t\tint LA26_0 = input.LA(1);\r\n\r\n                    \t        \t\tif ( (LA26_0 == OUTER) )\r\n                    \t        \t\t{\r\n                    \t        \t\t    alt26 = 1;\r\n                    \t        \t\t}\r\n                    \t        \t\tswitch (alt26) \r\n                    \t        \t\t{\r\n                    \t        \t\t    case 1 :\r\n                    \t        \t\t        // Hql.g:247:26: OUTER\r\n                    \t        \t\t        {\r\n                    \t        \t\t        \tOUTER74=(IToken)Match(input,OUTER,FOLLOW_OUTER_in_fromJoin1240); \r\n                    \t        \t\t        \t\tOUTER74_tree = (IASTNode)adaptor.Create(OUTER74);\r\n                    \t        \t\t        \t\tadaptor.AddChild(root_0, OUTER74_tree);\r\n\r\n\r\n                    \t        \t\t        }\r\n                    \t        \t\t        break;\r\n\r\n                    \t        \t\t}\r\n\r\n\r\n                    \t        \t}\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case 2 :\r\n                    \t        // Hql.g:247:38: FULL\r\n                    \t        {\r\n                    \t        \tFULL75=(IToken)Match(input,FULL,FOLLOW_FULL_in_fromJoin1248); \r\n                    \t        \t\tFULL75_tree = (IASTNode)adaptor.Create(FULL75);\r\n                    \t        \t\tadaptor.AddChild(root_0, FULL75_tree);\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case 3 :\r\n                    \t        // Hql.g:247:45: INNER\r\n                    \t        {\r\n                    \t        \tINNER76=(IToken)Match(input,INNER,FOLLOW_INNER_in_fromJoin1252); \r\n                    \t        \t\tINNER76_tree = (IASTNode)adaptor.Create(INNER76);\r\n                    \t        \t\tadaptor.AddChild(root_0, INNER76_tree);\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tJOIN77=(IToken)Match(input,JOIN,FOLLOW_JOIN_in_fromJoin1257); \r\n                    \t\tJOIN77_tree = (IASTNode)adaptor.Create(JOIN77);\r\n                    \t\troot_0 = (IASTNode)adaptor.BecomeRoot(JOIN77_tree, root_0);\r\n\r\n                    \t// Hql.g:247:60: ( FETCH )?\r\n                    \tint alt28 = 2;\r\n                    \tint LA28_0 = input.LA(1);\r\n\r\n                    \tif ( (LA28_0 == FETCH) )\r\n                    \t{\r\n                    \t    alt28 = 1;\r\n                    \t}\r\n                    \tswitch (alt28) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:247:61: FETCH\r\n                    \t        {\r\n                    \t        \tFETCH78=(IToken)Match(input,FETCH,FOLLOW_FETCH_in_fromJoin1261); \r\n                    \t        \t\tFETCH78_tree = (IASTNode)adaptor.Create(FETCH78);\r\n                    \t        \t\tadaptor.AddChild(root_0, FETCH78_tree);\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tELEMENTS79=(IToken)Match(input,ELEMENTS,FOLLOW_ELEMENTS_in_fromJoin1265); \r\n                    \tOPEN80=(IToken)Match(input,OPEN,FOLLOW_OPEN_in_fromJoin1268); \r\n                    \tPushFollow(FOLLOW_path_in_fromJoin1271);\r\n                    \tpath81 = path();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tadaptor.AddChild(root_0, path81.Tree);\r\n                    \tCLOSE82=(IToken)Match(input,CLOSE,FOLLOW_CLOSE_in_fromJoin1273); \r\n                    \t// Hql.g:247:97: ( asAlias )?\r\n                    \tint alt29 = 2;\r\n                    \tint LA29_0 = input.LA(1);\r\n\r\n                    \tif ( (LA29_0 == AS || LA29_0 == IDENT) )\r\n                    \t{\r\n                    \t    alt29 = 1;\r\n                    \t}\r\n                    \tswitch (alt29) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:247:98: asAlias\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_asAlias_in_fromJoin1277);\r\n                    \t        \tasAlias83 = asAlias();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_0, asAlias83.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \t// Hql.g:247:108: ( propertyFetch )?\r\n                    \tint alt30 = 2;\r\n                    \tint LA30_0 = input.LA(1);\r\n\r\n                    \tif ( (LA30_0 == FETCH) )\r\n                    \t{\r\n                    \t    alt30 = 1;\r\n                    \t}\r\n                    \tswitch (alt30) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:247:109: propertyFetch\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_propertyFetch_in_fromJoin1282);\r\n                    \t        \tpropertyFetch84 = propertyFetch();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_0, propertyFetch84.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \t// Hql.g:247:125: ( withClause )?\r\n                    \tint alt31 = 2;\r\n                    \tint LA31_0 = input.LA(1);\r\n\r\n                    \tif ( (LA31_0 == WITH) )\r\n                    \t{\r\n                    \t    alt31 = 1;\r\n                    \t}\r\n                    \tswitch (alt31) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:247:126: withClause\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_withClause_in_fromJoin1287);\r\n                    \t        \twithClause85 = withClause();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_0, withClause85.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n            retval.Stop = input.LT(-1);\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n            \tadaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n    \t// Conversion of the second argument necessary, but harmless\r\n    \tretval.Tree = (IASTNode)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);\r\n\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 49,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlParser.cs",
      "SourceLine": 2460
    },
    {
      "TypeIdentifier": "HqlParser",
      "MethodIdentifier": "caseExpression",
      "SourcesSample": "public HqlParser.caseExpression_return caseExpression() // throws RecognitionException [1]\r\n    {   \r\n        HqlParser.caseExpression_return retval = new HqlParser.caseExpression_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IToken CASE207 = null;\r\n        IToken END210 = null;\r\n        IToken CASE211 = null;\r\n        IToken END215 = null;\r\n        HqlParser.whenClause_return whenClause208 = default(HqlParser.whenClause_return);\r\n\r\n        HqlParser.elseClause_return elseClause209 = default(HqlParser.elseClause_return);\r\n\r\n        HqlParser.unaryExpression_return unaryExpression212 = default(HqlParser.unaryExpression_return);\r\n\r\n        HqlParser.altWhenClause_return altWhenClause213 = default(HqlParser.altWhenClause_return);\r\n\r\n        HqlParser.elseClause_return elseClause214 = default(HqlParser.elseClause_return);\r\n\r\n\r\n        IASTNode CASE207_tree=null;\r\n        IASTNode END210_tree=null;\r\n        IASTNode CASE211_tree=null;\r\n        IASTNode END215_tree=null;\r\n        RewriteRuleTokenStream stream_END = new RewriteRuleTokenStream(adaptor,\"token END\");\r\n        RewriteRuleTokenStream stream_CASE = new RewriteRuleTokenStream(adaptor,\"token CASE\");\r\n        RewriteRuleSubtreeStream stream_whenClause = new RewriteRuleSubtreeStream(adaptor,\"rule whenClause\");\r\n        RewriteRuleSubtreeStream stream_unaryExpression = new RewriteRuleSubtreeStream(adaptor,\"rule unaryExpression\");\r\n        RewriteRuleSubtreeStream stream_altWhenClause = new RewriteRuleSubtreeStream(adaptor,\"rule altWhenClause\");\r\n        RewriteRuleSubtreeStream stream_elseClause = new RewriteRuleSubtreeStream(adaptor,\"rule elseClause\");\r\n        try \r\n    \t{\r\n            // Hql.g:518:2: ( CASE ( whenClause )+ ( elseClause )? END -> ^( CASE ( whenClause )+ ( elseClause )? ) | CASE unaryExpression ( altWhenClause )+ ( elseClause )? END -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? ) )\r\n            int alt79 = 2;\r\n            int LA79_0 = input.LA(1);\r\n\r\n            if ( (LA79_0 == CASE) )\r\n            {\r\n                int LA79_1 = input.LA(2);\r\n\r\n                if ( ((LA79_1 >= ALL && LA79_1 <= ANY) || LA79_1 == AVG || LA79_1 == COUNT || LA79_1 == ELEMENTS || (LA79_1 >= EXISTS && LA79_1 <= FALSE) || LA79_1 == INDICES || (LA79_1 >= MAX && LA79_1 <= MIN) || LA79_1 == NULL || (LA79_1 >= SOME && LA79_1 <= SUM) || LA79_1 == TRUE || LA79_1 == CASE || LA79_1 == EMPTY || (LA79_1 >= NUM_INT && LA79_1 <= NUM_LONG) || LA79_1 == OPEN || (LA79_1 >= COLON && LA79_1 <= PARAM) || (LA79_1 >= PLUS && LA79_1 <= MINUS) || (LA79_1 >= QUOTED_String && LA79_1 <= IDENT)) )\r\n                {\r\n                    alt79 = 2;\r\n                }\r\n                else if ( (LA79_1 == WHEN) )\r\n                {\r\n                    alt79 = 1;\r\n                }\r\n                else \r\n                {\r\n                    NoViableAltException nvae_d79s1 =\r\n                        new NoViableAltException(\"\", 79, 1, input);\r\n\r\n                    throw nvae_d79s1;\r\n                }\r\n            }\r\n            else \r\n            {\r\n                NoViableAltException nvae_d79s0 =\r\n                    new NoViableAltException(\"\", 79, 0, input);\r\n\r\n                throw nvae_d79s0;\r\n            }\r\n            switch (alt79) \r\n            {\r\n                case 1 :\r\n                    // Hql.g:518:4: CASE ( whenClause )+ ( elseClause )? END\r\n                    {\r\n                    \tCASE207=(IToken)Match(input,CASE,FOLLOW_CASE_in_caseExpression2588);  \r\n                    \tstream_CASE.Add(CASE207);\r\n\r\n                    \t// Hql.g:518:9: ( whenClause )+\r\n                    \tint cnt75 = 0;\r\n                    \tdo \r\n                    \t{\r\n                    \t    int alt75 = 2;\r\n                    \t    int LA75_0 = input.LA(1);\r\n\r\n                    \t    if ( (LA75_0 == WHEN) )\r\n                    \t    {\r\n                    \t        alt75 = 1;\r\n                    \t    }\r\n\r\n\r\n                    \t    switch (alt75) \r\n                    \t\t{\r\n                    \t\t\tcase 1 :\r\n                    \t\t\t    // Hql.g:518:10: whenClause\r\n                    \t\t\t    {\r\n                    \t\t\t    \tPushFollow(FOLLOW_whenClause_in_caseExpression2591);\r\n                    \t\t\t    \twhenClause208 = whenClause();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n\r\n                    \t\t\t    \tstream_whenClause.Add(whenClause208.Tree);\r\n\r\n                    \t\t\t    }\r\n                    \t\t\t    break;\r\n\r\n                    \t\t\tdefault:\r\n                    \t\t\t    if ( cnt75 >= 1 ) goto loop75;\r\n                    \t\t            EarlyExitException eee75 =\r\n                    \t\t                new EarlyExitException(75, input);\r\n                    \t\t            throw eee75;\r\n                    \t    }\r\n                    \t    cnt75++;\r\n                    \t} while (true);\r\n\r\n                    \tloop75:\r\n                    \t\t;\t// Stops C# compiler whining that label 'loop75' has no statements\r\n\r\n                    \t// Hql.g:518:23: ( elseClause )?\r\n                    \tint alt76 = 2;\r\n                    \tint LA76_0 = input.LA(1);\r\n\r\n                    \tif ( (LA76_0 == ELSE) )\r\n                    \t{\r\n                    \t    alt76 = 1;\r\n                    \t}\r\n                    \tswitch (alt76) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:518:24: elseClause\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_elseClause_in_caseExpression2596);\r\n                    \t        \telseClause209 = elseClause();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tstream_elseClause.Add(elseClause209.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tEND210=(IToken)Match(input,END,FOLLOW_END_in_caseExpression2600);  \r\n                    \tstream_END.Add(END210);\r\n\r\n\r\n\r\n                    \t// AST REWRITE\r\n                    \t// elements:          whenClause, CASE, elseClause\r\n                    \t// token labels:      \r\n                    \t// rule labels:       retval\r\n                    \t// token list labels: \r\n                    \t// rule list labels:  \r\n                    \t// wildcard labels: \r\n                    \tretval.Tree = root_0;\r\n                    \tRewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval!=null ? retval.Tree : null);\r\n\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n                    \t// 519:3: -> ^( CASE ( whenClause )+ ( elseClause )? )\r\n                    \t{\r\n                    \t    // Hql.g:519:6: ^( CASE ( whenClause )+ ( elseClause )? )\r\n                    \t    {\r\n                    \t    IASTNode root_1 = (IASTNode)adaptor.GetNilNode();\r\n                    \t    root_1 = (IASTNode)adaptor.BecomeRoot(stream_CASE.NextNode(), root_1);\r\n\r\n                    \t    if ( !(stream_whenClause.HasNext()) ) {\r\n                    \t        throw new RewriteEarlyExitException();\r\n                    \t    }\r\n                    \t    while ( stream_whenClause.HasNext() )\r\n                    \t    {\r\n                    \t        adaptor.AddChild(root_1, stream_whenClause.NextTree());\r\n\r\n                    \t    }\r\n                    \t    stream_whenClause.Reset();\r\n                    \t    // Hql.g:519:25: ( elseClause )?\r\n                    \t    if ( stream_elseClause.HasNext() )\r\n                    \t    {\r\n                    \t        adaptor.AddChild(root_1, stream_elseClause.NextTree());\r\n\r\n                    \t    }\r\n                    \t    stream_elseClause.Reset();\r\n\r\n                    \t    adaptor.AddChild(root_0, root_1);\r\n                    \t    }\r\n\r\n                    \t}\r\n\r\n                    \tretval.Tree = root_0;retval.Tree = root_0;\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // Hql.g:520:4: CASE unaryExpression ( altWhenClause )+ ( elseClause )? END\r\n                    {\r\n                    \tCASE211=(IToken)Match(input,CASE,FOLLOW_CASE_in_caseExpression2620);  \r\n                    \tstream_CASE.Add(CASE211);\r\n\r\n                    \tPushFollow(FOLLOW_unaryExpression_in_caseExpression2622);\r\n                    \tunaryExpression212 = unaryExpression();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tstream_unaryExpression.Add(unaryExpression212.Tree);\r\n                    \t// Hql.g:520:25: ( altWhenClause )+\r\n                    \tint cnt77 = 0;\r\n                    \tdo \r\n                    \t{\r\n                    \t    int alt77 = 2;\r\n                    \t    int LA77_0 = input.LA(1);\r\n\r\n                    \t    if ( (LA77_0 == WHEN) )\r\n                    \t    {\r\n                    \t        alt77 = 1;\r\n                    \t    }\r\n\r\n\r\n                    \t    switch (alt77) \r\n                    \t\t{\r\n                    \t\t\tcase 1 :\r\n                    \t\t\t    // Hql.g:520:26: altWhenClause\r\n                    \t\t\t    {\r\n                    \t\t\t    \tPushFollow(FOLLOW_altWhenClause_in_caseExpression2625);\r\n                    \t\t\t    \taltWhenClause213 = altWhenClause();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n\r\n                    \t\t\t    \tstream_altWhenClause.Add(altWhenClause213.Tree);\r\n\r\n                    \t\t\t    }\r\n                    \t\t\t    break;\r\n\r\n                    \t\t\tdefault:\r\n                    \t\t\t    if ( cnt77 >= 1 ) goto loop77;\r\n                    \t\t            EarlyExitException eee77 =\r\n                    \t\t                new EarlyExitException(77, input);\r\n                    \t\t            throw eee77;\r\n                    \t    }\r\n                    \t    cnt77++;\r\n                    \t} while (true);\r\n\r\n                    \tloop77:\r\n                    \t\t;\t// Stops C# compiler whining that label 'loop77' has no statements\r\n\r\n                    \t// Hql.g:520:42: ( elseClause )?\r\n                    \tint alt78 = 2;\r\n                    \tint LA78_0 = input.LA(1);\r\n\r\n                    \tif ( (LA78_0 == ELSE) )\r\n                    \t{\r\n                    \t    alt78 = 1;\r\n                    \t}\r\n                    \tswitch (alt78) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:520:43: elseClause\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_elseClause_in_caseExpression2630);\r\n                    \t        \telseClause214 = elseClause();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tstream_elseClause.Add(elseClause214.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tEND215=(IToken)Match(input,END,FOLLOW_END_in_caseExpression2634);  \r\n                    \tstream_END.Add(END215);\r\n\r\n\r\n\r\n                    \t// AST REWRITE\r\n                    \t// elements:          elseClause, altWhenClause, unaryExpression\r\n                    \t// token labels:      \r\n                    \t// rule labels:       retval\r\n                    \t// token list labels: \r\n                    \t// rule list labels:  \r\n                    \t// wildcard labels: \r\n                    \tretval.Tree = root_0;\r\n                    \tRewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval!=null ? retval.Tree : null);\r\n\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n                    \t// 521:3: -> ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? )\r\n                    \t{\r\n                    \t    // Hql.g:521:6: ^( CASE2 unaryExpression ( altWhenClause )+ ( elseClause )? )\r\n                    \t    {\r\n                    \t    IASTNode root_1 = (IASTNode)adaptor.GetNilNode();\r\n                    \t    root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(CASE2, \"CASE2\"), root_1);\r\n\r\n                    \t    adaptor.AddChild(root_1, stream_unaryExpression.NextTree());\r\n                    \t    if ( !(stream_altWhenClause.HasNext()) ) {\r\n                    \t        throw new RewriteEarlyExitException();\r\n                    \t    }\r\n                    \t    while ( stream_altWhenClause.HasNext() )\r\n                    \t    {\r\n                    \t        adaptor.AddChild(root_1, stream_altWhenClause.NextTree());\r\n\r\n                    \t    }\r\n                    \t    stream_altWhenClause.Reset();\r\n                    \t    // Hql.g:521:45: ( elseClause )?\r\n                    \t    if ( stream_elseClause.HasNext() )\r\n                    \t    {\r\n                    \t        adaptor.AddChild(root_1, stream_elseClause.NextTree());\r\n\r\n                    \t    }\r\n                    \t    stream_elseClause.Reset();\r\n\r\n                    \t    adaptor.AddChild(root_0, root_1);\r\n                    \t    }\r\n\r\n                    \t}\r\n\r\n                    \tretval.Tree = root_0;retval.Tree = root_0;\r\n                    }\r\n                    break;\r\n\r\n            }\r\n            retval.Stop = input.LT(-1);\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n            \tadaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n    \t// Conversion of the second argument necessary, but harmless\r\n    \tretval.Tree = (IASTNode)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);\r\n\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 23,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlParser.cs",
      "SourceLine": 7944
    },
    {
      "TypeIdentifier": "HqlParser",
      "MethodIdentifier": "relationalExpression",
      "SourcesSample": "public HqlParser.relationalExpression_return relationalExpression() // throws RecognitionException [1]\r\n    {   \r\n        HqlParser.relationalExpression_return retval = new HqlParser.relationalExpression_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IToken n = null;\r\n        IToken i = null;\r\n        IToken b = null;\r\n        IToken l = null;\r\n        IToken LT167 = null;\r\n        IToken GT168 = null;\r\n        IToken LE169 = null;\r\n        IToken GE170 = null;\r\n        IToken MEMBER176 = null;\r\n        IToken OF177 = null;\r\n        HqlParser.path_return p = default(HqlParser.path_return);\r\n\r\n        HqlParser.concatenation_return concatenation166 = default(HqlParser.concatenation_return);\r\n\r\n        HqlParser.bitwiseNotExpression_return bitwiseNotExpression171 = default(HqlParser.bitwiseNotExpression_return);\r\n\r\n        HqlParser.inList_return inList172 = default(HqlParser.inList_return);\r\n\r\n        HqlParser.betweenList_return betweenList173 = default(HqlParser.betweenList_return);\r\n\r\n        HqlParser.concatenation_return concatenation174 = default(HqlParser.concatenation_return);\r\n\r\n        HqlParser.likeEscape_return likeEscape175 = default(HqlParser.likeEscape_return);\r\n\r\n\r\n        IASTNode n_tree=null;\r\n        IASTNode i_tree=null;\r\n        IASTNode b_tree=null;\r\n        IASTNode l_tree=null;\r\n        IASTNode LT167_tree=null;\r\n        IASTNode GT168_tree=null;\r\n        IASTNode LE169_tree=null;\r\n        IASTNode GE170_tree=null;\r\n        IASTNode MEMBER176_tree=null;\r\n        IASTNode OF177_tree=null;\r\n\r\n        try \r\n    \t{\r\n            // Hql.g:420:2: ( concatenation ( ( ( ( LT | GT | LE | GE ) bitwiseNotExpression )* ) | (n= NOT )? ( (i= IN inList ) | (b= BETWEEN betweenList ) | (l= LIKE concatenation likeEscape ) | ( MEMBER ( OF )? p= path ) ) ) )\r\n            // Hql.g:420:4: concatenation ( ( ( ( LT | GT | LE | GE ) bitwiseNotExpression )* ) | (n= NOT )? ( (i= IN inList ) | (b= BETWEEN betweenList ) | (l= LIKE concatenation likeEscape ) | ( MEMBER ( OF )? p= path ) ) )\r\n            {\r\n            \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n            \tPushFollow(FOLLOW_concatenation_in_relationalExpression2071);\r\n            \tconcatenation166 = concatenation();\r\n            \tstate.followingStackPointer--;\r\n\r\n            \tadaptor.AddChild(root_0, concatenation166.Tree);\r\n            \t// Hql.g:420:18: ( ( ( ( LT | GT | LE | GE ) bitwiseNotExpression )* ) | (n= NOT )? ( (i= IN inList ) | (b= BETWEEN betweenList ) | (l= LIKE concatenation likeEscape ) | ( MEMBER ( OF )? p= path ) ) )\r\n            \tint alt62 = 2;\r\n            \tint LA62_0 = input.LA(1);\r\n\r\n            \tif ( (LA62_0 == EOF || (LA62_0 >= AND && LA62_0 <= ASCENDING) || LA62_0 == DESCENDING || (LA62_0 >= FROM && LA62_0 <= HAVING) || LA62_0 == INNER || (LA62_0 >= IS && LA62_0 <= LEFT) || (LA62_0 >= OR && LA62_0 <= ORDER) || LA62_0 == RIGHT || LA62_0 == SKIP || LA62_0 == TAKE || LA62_0 == UNION || LA62_0 == WHERE || (LA62_0 >= END && LA62_0 <= WHEN) || (LA62_0 >= COMMA && LA62_0 <= EQ) || LA62_0 == CLOSE || (LA62_0 >= NE && LA62_0 <= GE) || LA62_0 == CLOSE_BRACKET || (LA62_0 >= 133 && LA62_0 <= 134)) )\r\n            \t{\r\n            \t    alt62 = 1;\r\n            \t}\r\n            \telse if ( (LA62_0 == BETWEEN || LA62_0 == IN || LA62_0 == LIKE || LA62_0 == NOT || LA62_0 == MEMBER) )\r\n            \t{\r\n            \t    alt62 = 2;\r\n            \t}\r\n            \telse \r\n            \t{\r\n            \t    NoViableAltException nvae_d62s0 =\r\n            \t        new NoViableAltException(\"\", 62, 0, input);\r\n\r\n            \t    throw nvae_d62s0;\r\n            \t}\r\n            \tswitch (alt62) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:421:3: ( ( ( LT | GT | LE | GE ) bitwiseNotExpression )* )\r\n            \t        {\r\n            \t        \t// Hql.g:421:3: ( ( ( LT | GT | LE | GE ) bitwiseNotExpression )* )\r\n            \t        \t// Hql.g:421:5: ( ( LT | GT | LE | GE ) bitwiseNotExpression )*\r\n            \t        \t{\r\n            \t        \t\t// Hql.g:421:5: ( ( LT | GT | LE | GE ) bitwiseNotExpression )*\r\n            \t        \t\tdo \r\n            \t        \t\t{\r\n            \t        \t\t    int alt58 = 2;\r\n            \t        \t\t    int LA58_0 = input.LA(1);\r\n\r\n            \t        \t\t    if ( ((LA58_0 >= LT && LA58_0 <= GE)) )\r\n            \t        \t\t    {\r\n            \t        \t\t        alt58 = 1;\r\n            \t        \t\t    }\r\n\r\n\r\n            \t        \t\t    switch (alt58) \r\n            \t        \t\t\t{\r\n            \t        \t\t\t\tcase 1 :\r\n            \t        \t\t\t\t    // Hql.g:421:7: ( LT | GT | LE | GE ) bitwiseNotExpression\r\n            \t        \t\t\t\t    {\r\n            \t        \t\t\t\t    \t// Hql.g:421:7: ( LT | GT | LE | GE )\r\n            \t        \t\t\t\t    \tint alt57 = 4;\r\n            \t        \t\t\t\t    \tswitch ( input.LA(1) ) \r\n            \t        \t\t\t\t    \t{\r\n            \t        \t\t\t\t    \tcase LT:\r\n            \t        \t\t\t\t    \t\t{\r\n            \t        \t\t\t\t    \t    alt57 = 1;\r\n            \t        \t\t\t\t    \t    }\r\n            \t        \t\t\t\t    \t    break;\r\n            \t        \t\t\t\t    \tcase GT:\r\n            \t        \t\t\t\t    \t\t{\r\n            \t        \t\t\t\t    \t    alt57 = 2;\r\n            \t        \t\t\t\t    \t    }\r\n            \t        \t\t\t\t    \t    break;\r\n            \t        \t\t\t\t    \tcase LE:\r\n            \t        \t\t\t\t    \t\t{\r\n            \t        \t\t\t\t    \t    alt57 = 3;\r\n            \t        \t\t\t\t    \t    }\r\n            \t        \t\t\t\t    \t    break;\r\n            \t        \t\t\t\t    \tcase GE:\r\n            \t        \t\t\t\t    \t\t{\r\n            \t        \t\t\t\t    \t    alt57 = 4;\r\n            \t        \t\t\t\t    \t    }\r\n            \t        \t\t\t\t    \t    break;\r\n            \t        \t\t\t\t    \t\tdefault:\r\n            \t        \t\t\t\t    \t\t    NoViableAltException nvae_d57s0 =\r\n            \t        \t\t\t\t    \t\t        new NoViableAltException(\"\", 57, 0, input);\r\n\r\n            \t        \t\t\t\t    \t\t    throw nvae_d57s0;\r\n            \t        \t\t\t\t    \t}\r\n\r\n            \t        \t\t\t\t    \tswitch (alt57) \r\n            \t        \t\t\t\t    \t{\r\n            \t        \t\t\t\t    \t    case 1 :\r\n            \t        \t\t\t\t    \t        // Hql.g:421:9: LT\r\n            \t        \t\t\t\t    \t        {\r\n            \t        \t\t\t\t    \t        \tLT167=(IToken)Match(input,LT,FOLLOW_LT_in_relationalExpression2083); \r\n            \t        \t\t\t\t    \t        \t\tLT167_tree = (IASTNode)adaptor.Create(LT167);\r\n            \t        \t\t\t\t    \t        \t\troot_0 = (IASTNode)adaptor.BecomeRoot(LT167_tree, root_0);\r\n\r\n\r\n            \t        \t\t\t\t    \t        }\r\n            \t        \t\t\t\t    \t        break;\r\n            \t        \t\t\t\t    \t    case 2 :\r\n            \t        \t\t\t\t    \t        // Hql.g:421:15: GT\r\n            \t        \t\t\t\t    \t        {\r\n            \t        \t\t\t\t    \t        \tGT168=(IToken)Match(input,GT,FOLLOW_GT_in_relationalExpression2088); \r\n            \t        \t\t\t\t    \t        \t\tGT168_tree = (IASTNode)adaptor.Create(GT168);\r\n            \t        \t\t\t\t    \t        \t\troot_0 = (IASTNode)adaptor.BecomeRoot(GT168_tree, root_0);\r\n\r\n\r\n            \t        \t\t\t\t    \t        }\r\n            \t        \t\t\t\t    \t        break;\r\n            \t        \t\t\t\t    \t    case 3 :\r\n            \t        \t\t\t\t    \t        // Hql.g:421:21: LE\r\n            \t        \t\t\t\t    \t        {\r\n            \t        \t\t\t\t    \t        \tLE169=(IToken)Match(input,LE,FOLLOW_LE_in_relationalExpression2093); \r\n            \t        \t\t\t\t    \t        \t\tLE169_tree = (IASTNode)adaptor.Create(LE169);\r\n            \t        \t\t\t\t    \t        \t\troot_0 = (IASTNode)adaptor.BecomeRoot(LE169_tree, root_0);\r\n\r\n\r\n            \t        \t\t\t\t    \t        }\r\n            \t        \t\t\t\t    \t        break;\r\n            \t        \t\t\t\t    \t    case 4 :\r\n            \t        \t\t\t\t    \t        // Hql.g:421:27: GE\r\n            \t        \t\t\t\t    \t        {\r\n            \t        \t\t\t\t    \t        \tGE170=(IToken)Match(input,GE,FOLLOW_GE_in_relationalExpression2098); \r\n            \t        \t\t\t\t    \t        \t\tGE170_tree = (IASTNode)adaptor.Create(GE170);\r\n            \t        \t\t\t\t    \t        \t\troot_0 = (IASTNode)adaptor.BecomeRoot(GE170_tree, root_0);\r\n\r\n\r\n            \t        \t\t\t\t    \t        }\r\n            \t        \t\t\t\t    \t        break;\r\n\r\n            \t        \t\t\t\t    \t}\r\n\r\n            \t        \t\t\t\t    \tPushFollow(FOLLOW_bitwiseNotExpression_in_relationalExpression2103);\r\n            \t        \t\t\t\t    \tbitwiseNotExpression171 = bitwiseNotExpression();\r\n            \t        \t\t\t\t    \tstate.followingStackPointer--;\r\n\r\n            \t        \t\t\t\t    \tadaptor.AddChild(root_0, bitwiseNotExpression171.Tree);\r\n\r\n            \t        \t\t\t\t    }\r\n            \t        \t\t\t\t    break;\r\n\r\n            \t        \t\t\t\tdefault:\r\n            \t        \t\t\t\t    goto loop58;\r\n            \t        \t\t    }\r\n            \t        \t\t} while (true);\r\n\r\n            \t        \t\tloop58:\r\n            \t        \t\t\t;\t// Stops C# compiler whining that label 'loop58' has no statements\r\n\r\n\r\n            \t        \t}\r\n\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 2 :\r\n            \t        // Hql.g:423:5: (n= NOT )? ( (i= IN inList ) | (b= BETWEEN betweenList ) | (l= LIKE concatenation likeEscape ) | ( MEMBER ( OF )? p= path ) )\r\n            \t        {\r\n            \t        \t// Hql.g:423:5: (n= NOT )?\r\n            \t        \tint alt59 = 2;\r\n            \t        \tint LA59_0 = input.LA(1);\r\n\r\n            \t        \tif ( (LA59_0 == NOT) )\r\n            \t        \t{\r\n            \t        \t    alt59 = 1;\r\n            \t        \t}\r\n            \t        \tswitch (alt59) \r\n            \t        \t{\r\n            \t        \t    case 1 :\r\n            \t        \t        // Hql.g:423:6: n= NOT\r\n            \t        \t        {\r\n            \t        \t        \tn=(IToken)Match(input,NOT,FOLLOW_NOT_in_relationalExpression2120); \r\n\r\n            \t        \t        }\r\n            \t        \t        break;\r\n\r\n            \t        \t}\r\n\r\n            \t        \t// Hql.g:423:15: ( (i= IN inList ) | (b= BETWEEN betweenList ) | (l= LIKE concatenation likeEscape ) | ( MEMBER ( OF )? p= path ) )\r\n            \t        \tint alt61 = 4;\r\n            \t        \tswitch ( input.LA(1) ) \r\n            \t        \t{\r\n            \t        \tcase IN:\r\n            \t        \t\t{\r\n            \t        \t    alt61 = 1;\r\n            \t        \t    }\r\n            \t        \t    break;\r\n            \t        \tcase BETWEEN:\r\n            \t        \t\t{\r\n            \t        \t    alt61 = 2;\r\n            \t        \t    }\r\n            \t        \t    break;\r\n            \t        \tcase LIKE:\r\n            \t        \t\t{\r\n            \t        \t    alt61 = 3;\r\n            \t        \t    }\r\n            \t        \t    break;\r\n            \t        \tcase MEMBER:\r\n            \t        \t\t{\r\n            \t        \t    alt61 = 4;\r\n            \t        \t    }\r\n            \t        \t    break;\r\n            \t        \t\tdefault:\r\n            \t        \t\t    NoViableAltException nvae_d61s0 =\r\n            \t        \t\t        new NoViableAltException(\"\", 61, 0, input);\r\n\r\n            \t        \t\t    throw nvae_d61s0;\r\n            \t        \t}\r\n\r\n            \t        \tswitch (alt61) \r\n            \t        \t{\r\n            \t        \t    case 1 :\r\n            \t        \t        // Hql.g:426:4: (i= IN inList )\r\n            \t        \t        {\r\n            \t        \t        \t// Hql.g:426:4: (i= IN inList )\r\n            \t        \t        \t// Hql.g:426:5: i= IN inList\r\n            \t        \t        \t{\r\n            \t        \t        \t\ti=(IToken)Match(input,IN,FOLLOW_IN_in_relationalExpression2141); \r\n            \t        \t        \t\t\ti_tree = (IASTNode)adaptor.Create(i);\r\n            \t        \t        \t\t\troot_0 = (IASTNode)adaptor.BecomeRoot(i_tree, root_0);\r\n\r\n\r\n            \t        \t        \t\t\t\t\t\t\ti.Type = (n == null) ? IN : NOT_IN;\r\n            \t        \t        \t\t\t\t\t\t\ti.Text = (n == null) ? \"in\" : \"not in\";\r\n            \t        \t        \t\t\t\t\t\t\r\n            \t        \t        \t\tPushFollow(FOLLOW_inList_in_relationalExpression2150);\r\n            \t        \t        \t\tinList172 = inList();\r\n            \t        \t        \t\tstate.followingStackPointer--;\r\n\r\n            \t        \t        \t\tadaptor.AddChild(root_0, inList172.Tree);\r\n\r\n            \t        \t        \t}\r\n\r\n\r\n            \t        \t        }\r\n            \t        \t        break;\r\n            \t        \t    case 2 :\r\n            \t        \t        // Hql.g:431:6: (b= BETWEEN betweenList )\r\n            \t        \t        {\r\n            \t        \t        \t// Hql.g:431:6: (b= BETWEEN betweenList )\r\n            \t        \t        \t// Hql.g:431:7: b= BETWEEN betweenList\r\n            \t        \t        \t{\r\n            \t        \t        \t\tb=(IToken)Match(input,BETWEEN,FOLLOW_BETWEEN_in_relationalExpression2161); \r\n            \t        \t        \t\t\tb_tree = (IASTNode)adaptor.Create(b);\r\n            \t        \t        \t\t\troot_0 = (IASTNode)adaptor.BecomeRoot(b_tree, root_0);\r\n\r\n\r\n            \t        \t        \t\t\t\t\t\t\tb.Type = (n == null) ? BETWEEN : NOT_BETWEEN;\r\n            \t        \t        \t\t\t\t\t\t\tb.Text = (n == null) ? \"between\" : \"not between\";\r\n            \t        \t        \t\t\t\t\t\t\r\n            \t        \t        \t\tPushFollow(FOLLOW_betweenList_in_relationalExpression2170);\r\n            \t        \t        \t\tbetweenList173 = betweenList();\r\n            \t        \t        \t\tstate.followingStackPointer--;\r\n\r\n            \t        \t        \t\tadaptor.AddChild(root_0, betweenList173.Tree);\r\n\r\n            \t        \t        \t}\r\n\r\n\r\n            \t        \t        }\r\n            \t        \t        break;\r\n            \t        \t    case 3 :\r\n            \t        \t        // Hql.g:436:6: (l= LIKE concatenation likeEscape )\r\n            \t        \t        {\r\n            \t        \t        \t// Hql.g:436:6: (l= LIKE concatenation likeEscape )\r\n            \t        \t        \t// Hql.g:436:7: l= LIKE concatenation likeEscape\r\n            \t        \t        \t{\r\n            \t        \t        \t\tl=(IToken)Match(input,LIKE,FOLLOW_LIKE_in_relationalExpression2182); \r\n            \t        \t        \t\t\tl_tree = (IASTNode)adaptor.Create(l);\r\n            \t        \t        \t\t\troot_0 = (IASTNode)adaptor.BecomeRoot(l_tree, root_0);\r\n\r\n\r\n            \t        \t        \t\t\t\t\t\t\tl.Type = (n == null) ? LIKE : NOT_LIKE;\r\n            \t        \t        \t\t\t\t\t\t\tl.Text = (n == null) ? \"like\" : \"not like\";\r\n            \t        \t        \t\t\t\t\t\t\r\n            \t        \t        \t\tPushFollow(FOLLOW_concatenation_in_relationalExpression2191);\r\n            \t        \t        \t\tconcatenation174 = concatenation();\r\n            \t        \t        \t\tstate.followingStackPointer--;\r\n\r\n            \t        \t        \t\tadaptor.AddChild(root_0, concatenation174.Tree);\r\n            \t        \t        \t\tPushFollow(FOLLOW_likeEscape_in_relationalExpression2193);\r\n            \t        \t        \t\tlikeEscape175 = likeEscape();\r\n            \t        \t        \t\tstate.followingStackPointer--;\r\n\r\n            \t        \t        \t\tadaptor.AddChild(root_0, likeEscape175.Tree);\r\n\r\n            \t        \t        \t}\r\n\r\n\r\n            \t        \t        }\r\n            \t        \t        break;\r\n            \t        \t    case 4 :\r\n            \t        \t        // Hql.g:441:6: ( MEMBER ( OF )? p= path )\r\n            \t        \t        {\r\n            \t        \t        \t// Hql.g:441:6: ( MEMBER ( OF )? p= path )\r\n            \t        \t        \t// Hql.g:441:7: MEMBER ( OF )? p= path\r\n            \t        \t        \t{\r\n            \t        \t        \t\tMEMBER176=(IToken)Match(input,MEMBER,FOLLOW_MEMBER_in_relationalExpression2202); \r\n            \t        \t        \t\t// Hql.g:441:15: ( OF )?\r\n            \t        \t        \t\tint alt60 = 2;\r\n            \t        \t        \t\tint LA60_0 = input.LA(1);\r\n\r\n            \t        \t        \t\tif ( (LA60_0 == OF) )\r\n            \t        \t        \t\t{\r\n            \t        \t        \t\t    alt60 = 1;\r\n            \t        \t        \t\t}\r\n            \t        \t        \t\tswitch (alt60) \r\n            \t        \t        \t\t{\r\n            \t        \t        \t\t    case 1 :\r\n            \t        \t        \t\t        // Hql.g:441:16: OF\r\n            \t        \t        \t\t        {\r\n            \t        \t        \t\t        \tOF177=(IToken)Match(input,OF,FOLLOW_OF_in_relationalExpression2206); \r\n\r\n            \t        \t        \t\t        }\r\n            \t        \t        \t\t        break;\r\n\r\n            \t        \t        \t\t}\r\n\r\n            \t        \t        \t\tPushFollow(FOLLOW_path_in_relationalExpression2213);\r\n            \t        \t        \t\tp = path();\r\n            \t        \t        \t\tstate.followingStackPointer--;\r\n\r\n\r\n            \t        \t        \t\t\t\t\t\troot_0 = ProcessMemberOf(n,((p != null) ? ((IASTNode)p.Tree) : null), root_0);\r\n            \t        \t        \t\t\t\t\t  \r\n\r\n            \t        \t        \t}\r\n\r\n\r\n            \t        \t        }\r\n            \t        \t        break;\r\n\r\n            \t        \t}\r\n\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n\r\n            }\r\n\r\n            retval.Stop = input.LT(-1);\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n            \tadaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n    \t// Conversion of the second argument necessary, but harmless\r\n    \tretval.Tree = (IASTNode)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);\r\n\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlParser.cs",
      "SourceLine": 6140
    },
    {
      "TypeIdentifier": "HqlParser",
      "MethodIdentifier": "identPrimary",
      "SourcesSample": "public HqlParser.identPrimary_return identPrimary() // throws RecognitionException [1]\r\n    {   \r\n        HqlParser.identPrimary_return retval = new HqlParser.identPrimary_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IToken o = null;\r\n        IToken op = null;\r\n        IToken DOT259 = null;\r\n        IToken CLOSE262 = null;\r\n        HqlParser.identifier_return identifier258 = default(HqlParser.identifier_return);\r\n\r\n        HqlParser.identifier_return identifier260 = default(HqlParser.identifier_return);\r\n\r\n        HqlParser.exprList_return exprList261 = default(HqlParser.exprList_return);\r\n\r\n        HqlParser.aggregate_return aggregate263 = default(HqlParser.aggregate_return);\r\n\r\n\r\n        IASTNode o_tree=null;\r\n        IASTNode op_tree=null;\r\n        IASTNode DOT259_tree=null;\r\n        IASTNode CLOSE262_tree=null;\r\n\r\n        try \r\n    \t{\r\n            // Hql.g:580:2: ( identifier ( options {greedy=true; } : DOT ( identifier | o= OBJECT ) )* ( (op= OPEN exprList CLOSE ) )? | aggregate )\r\n            int alt93 = 2;\r\n            int LA93_0 = input.LA(1);\r\n\r\n            if ( (LA93_0 == IDENT) )\r\n            {\r\n                alt93 = 1;\r\n            }\r\n            else if ( (LA93_0 == AVG || LA93_0 == COUNT || LA93_0 == ELEMENTS || LA93_0 == INDICES || (LA93_0 >= MAX && LA93_0 <= MIN) || LA93_0 == SUM) )\r\n            {\r\n                alt93 = 2;\r\n            }\r\n            else \r\n            {\r\n                NoViableAltException nvae_d93s0 =\r\n                    new NoViableAltException(\"\", 93, 0, input);\r\n\r\n                throw nvae_d93s0;\r\n            }\r\n            switch (alt93) \r\n            {\r\n                case 1 :\r\n                    // Hql.g:580:4: identifier ( options {greedy=true; } : DOT ( identifier | o= OBJECT ) )* ( (op= OPEN exprList CLOSE ) )?\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \tPushFollow(FOLLOW_identifier_in_identPrimary3030);\r\n                    \tidentifier258 = identifier();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tadaptor.AddChild(root_0, identifier258.Tree);\r\n                    \t HandleDotIdent(); \r\n                    \t// Hql.g:581:4: ( options {greedy=true; } : DOT ( identifier | o= OBJECT ) )*\r\n                    \tdo \r\n                    \t{\r\n                    \t    int alt91 = 2;\r\n                    \t    int LA91_0 = input.LA(1);\r\n\r\n                    \t    if ( (LA91_0 == DOT) )\r\n                    \t    {\r\n                    \t        int LA91_2 = input.LA(2);\r\n\r\n                    \t        if ( (LA91_2 == OBJECT || LA91_2 == IDENT) )\r\n                    \t        {\r\n                    \t            alt91 = 1;\r\n                    \t        }\r\n\r\n\r\n                    \t    }\r\n\r\n\r\n                    \t    switch (alt91) \r\n                    \t\t{\r\n                    \t\t\tcase 1 :\r\n                    \t\t\t    // Hql.g:581:31: DOT ( identifier | o= OBJECT )\r\n                    \t\t\t    {\r\n                    \t\t\t    \tDOT259=(IToken)Match(input,DOT,FOLLOW_DOT_in_identPrimary3048); \r\n                    \t\t\t    \t\tDOT259_tree = (IASTNode)adaptor.Create(DOT259);\r\n                    \t\t\t    \t\troot_0 = (IASTNode)adaptor.BecomeRoot(DOT259_tree, root_0);\r\n\r\n                    \t\t\t    \t// Hql.g:581:36: ( identifier | o= OBJECT )\r\n                    \t\t\t    \tint alt90 = 2;\r\n                    \t\t\t    \tint LA90_0 = input.LA(1);\r\n\r\n                    \t\t\t    \tif ( (LA90_0 == IDENT) )\r\n                    \t\t\t    \t{\r\n                    \t\t\t    \t    alt90 = 1;\r\n                    \t\t\t    \t}\r\n                    \t\t\t    \telse if ( (LA90_0 == OBJECT) )\r\n                    \t\t\t    \t{\r\n                    \t\t\t    \t    alt90 = 2;\r\n                    \t\t\t    \t}\r\n                    \t\t\t    \telse \r\n                    \t\t\t    \t{\r\n                    \t\t\t    \t    NoViableAltException nvae_d90s0 =\r\n                    \t\t\t    \t        new NoViableAltException(\"\", 90, 0, input);\r\n\r\n                    \t\t\t    \t    throw nvae_d90s0;\r\n                    \t\t\t    \t}\r\n                    \t\t\t    \tswitch (alt90) \r\n                    \t\t\t    \t{\r\n                    \t\t\t    \t    case 1 :\r\n                    \t\t\t    \t        // Hql.g:581:38: identifier\r\n                    \t\t\t    \t        {\r\n                    \t\t\t    \t        \tPushFollow(FOLLOW_identifier_in_identPrimary3053);\r\n                    \t\t\t    \t        \tidentifier260 = identifier();\r\n                    \t\t\t    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t\t\t    \t        \tadaptor.AddChild(root_0, identifier260.Tree);\r\n\r\n                    \t\t\t    \t        }\r\n                    \t\t\t    \t        break;\r\n                    \t\t\t    \t    case 2 :\r\n                    \t\t\t    \t        // Hql.g:581:51: o= OBJECT\r\n                    \t\t\t    \t        {\r\n                    \t\t\t    \t        \to=(IToken)Match(input,OBJECT,FOLLOW_OBJECT_in_identPrimary3059); \r\n                    \t\t\t    \t        \t\to_tree = (IASTNode)adaptor.Create(o);\r\n                    \t\t\t    \t        \t\tadaptor.AddChild(root_0, o_tree);\r\n\r\n                    \t\t\t    \t        \t o.Type = IDENT; \r\n\r\n                    \t\t\t    \t        }\r\n                    \t\t\t    \t        break;\r\n\r\n                    \t\t\t    \t}\r\n\r\n\r\n                    \t\t\t    }\r\n                    \t\t\t    break;\r\n\r\n                    \t\t\tdefault:\r\n                    \t\t\t    goto loop91;\r\n                    \t    }\r\n                    \t} while (true);\r\n\r\n                    \tloop91:\r\n                    \t\t;\t// Stops C# compiler whining that label 'loop91' has no statements\r\n\r\n                    \t// Hql.g:582:4: ( (op= OPEN exprList CLOSE ) )?\r\n                    \tint alt92 = 2;\r\n                    \tint LA92_0 = input.LA(1);\r\n\r\n                    \tif ( (LA92_0 == OPEN) )\r\n                    \t{\r\n                    \t    alt92 = 1;\r\n                    \t}\r\n                    \tswitch (alt92) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:582:6: (op= OPEN exprList CLOSE )\r\n                    \t        {\r\n                    \t        \t// Hql.g:582:6: (op= OPEN exprList CLOSE )\r\n                    \t        \t// Hql.g:582:8: op= OPEN exprList CLOSE\r\n                    \t        \t{\r\n                    \t        \t\top=(IToken)Match(input,OPEN,FOLLOW_OPEN_in_identPrimary3077); \r\n                    \t        \t\t\top_tree = (IASTNode)adaptor.Create(op);\r\n                    \t        \t\t\troot_0 = (IASTNode)adaptor.BecomeRoot(op_tree, root_0);\r\n\r\n                    \t        \t\t op.Type = METHOD_CALL;\r\n                    \t        \t\tPushFollow(FOLLOW_exprList_in_identPrimary3082);\r\n                    \t        \t\texprList261 = exprList();\r\n                    \t        \t\tstate.followingStackPointer--;\r\n\r\n                    \t        \t\tadaptor.AddChild(root_0, exprList261.Tree);\r\n                    \t        \t\tCLOSE262=(IToken)Match(input,CLOSE,FOLLOW_CLOSE_in_identPrimary3084); \r\n\r\n                    \t        \t}\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // Hql.g:585:4: aggregate\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \tPushFollow(FOLLOW_aggregate_in_identPrimary3100);\r\n                    \taggregate263 = aggregate();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tadaptor.AddChild(root_0, aggregate263.Tree);\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n            retval.Stop = input.LT(-1);\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n            \tadaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n    \t// Conversion of the second argument necessary, but harmless\r\n    \tretval.Tree = (IASTNode)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);\r\n\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlParser.cs",
      "SourceLine": 9422
    },
    {
      "TypeIdentifier": "HqlParser",
      "MethodIdentifier": "queryRule",
      "SourcesSample": "public HqlParser.queryRule_return queryRule() // throws RecognitionException [1]\r\n    {   \r\n        HqlParser.queryRule_return retval = new HqlParser.queryRule_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        HqlParser.selectFrom_return selectFrom38 = default(HqlParser.selectFrom_return);\r\n\r\n        HqlParser.whereClause_return whereClause39 = default(HqlParser.whereClause_return);\r\n\r\n        HqlParser.groupByClause_return groupByClause40 = default(HqlParser.groupByClause_return);\r\n\r\n        HqlParser.havingClause_return havingClause41 = default(HqlParser.havingClause_return);\r\n\r\n        HqlParser.orderByClause_return orderByClause42 = default(HqlParser.orderByClause_return);\r\n\r\n        HqlParser.skipClause_return skipClause43 = default(HqlParser.skipClause_return);\r\n\r\n        HqlParser.takeClause_return takeClause44 = default(HqlParser.takeClause_return);\r\n\r\n\r\n\r\n        try \r\n    \t{\r\n            // Hql.g:202:2: ( selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )? )\r\n            // Hql.g:202:4: selectFrom ( whereClause )? ( groupByClause )? ( havingClause )? ( orderByClause )? ( skipClause )? ( takeClause )?\r\n            {\r\n            \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n            \tPushFollow(FOLLOW_selectFrom_in_queryRule916);\r\n            \tselectFrom38 = selectFrom();\r\n            \tstate.followingStackPointer--;\r\n\r\n            \tadaptor.AddChild(root_0, selectFrom38.Tree);\r\n            \t// Hql.g:203:3: ( whereClause )?\r\n            \tint alt9 = 2;\r\n            \tint LA9_0 = input.LA(1);\r\n\r\n            \tif ( (LA9_0 == WHERE) )\r\n            \t{\r\n            \t    alt9 = 1;\r\n            \t}\r\n            \tswitch (alt9) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:203:4: whereClause\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_whereClause_in_queryRule921);\r\n            \t        \twhereClause39 = whereClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_0, whereClause39.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// Hql.g:204:3: ( groupByClause )?\r\n            \tint alt10 = 2;\r\n            \tint LA10_0 = input.LA(1);\r\n\r\n            \tif ( (LA10_0 == GROUP) )\r\n            \t{\r\n            \t    alt10 = 1;\r\n            \t}\r\n            \tswitch (alt10) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:204:4: groupByClause\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_groupByClause_in_queryRule928);\r\n            \t        \tgroupByClause40 = groupByClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_0, groupByClause40.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// Hql.g:205:3: ( havingClause )?\r\n            \tint alt11 = 2;\r\n            \tint LA11_0 = input.LA(1);\r\n\r\n            \tif ( (LA11_0 == HAVING) )\r\n            \t{\r\n            \t    alt11 = 1;\r\n            \t}\r\n            \tswitch (alt11) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:205:4: havingClause\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_havingClause_in_queryRule935);\r\n            \t        \thavingClause41 = havingClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_0, havingClause41.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// Hql.g:206:3: ( orderByClause )?\r\n            \tint alt12 = 2;\r\n            \tint LA12_0 = input.LA(1);\r\n\r\n            \tif ( (LA12_0 == ORDER) )\r\n            \t{\r\n            \t    alt12 = 1;\r\n            \t}\r\n            \tswitch (alt12) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:206:4: orderByClause\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_orderByClause_in_queryRule942);\r\n            \t        \torderByClause42 = orderByClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_0, orderByClause42.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// Hql.g:207:3: ( skipClause )?\r\n            \tint alt13 = 2;\r\n            \tint LA13_0 = input.LA(1);\r\n\r\n            \tif ( (LA13_0 == SKIP) )\r\n            \t{\r\n            \t    alt13 = 1;\r\n            \t}\r\n            \tswitch (alt13) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:207:4: skipClause\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_skipClause_in_queryRule949);\r\n            \t        \tskipClause43 = skipClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_0, skipClause43.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// Hql.g:208:3: ( takeClause )?\r\n            \tint alt14 = 2;\r\n            \tint LA14_0 = input.LA(1);\r\n\r\n            \tif ( (LA14_0 == TAKE) )\r\n            \t{\r\n            \t    alt14 = 1;\r\n            \t}\r\n            \tswitch (alt14) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:208:4: takeClause\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_takeClause_in_queryRule956);\r\n            \t        \ttakeClause44 = takeClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_0, takeClause44.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n\r\n            }\r\n\r\n            retval.Stop = input.LT(-1);\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n            \tadaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n    \t// Conversion of the second argument necessary, but harmless\r\n    \tretval.Tree = (IASTNode)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);\r\n\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlParser.cs",
      "SourceLine": 1589
    },
    {
      "TypeIdentifier": "HqlParser",
      "MethodIdentifier": "exprList",
      "SourcesSample": "public HqlParser.exprList_return exprList() // throws RecognitionException [1]\r\n    {   \r\n        HqlParser.exprList_return retval = new HqlParser.exprList_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IToken f = null;\r\n        IToken f2 = null;\r\n        IToken TRAILING287 = null;\r\n        IToken LEADING288 = null;\r\n        IToken BOTH289 = null;\r\n        IToken COMMA291 = null;\r\n        IToken AS294 = null;\r\n        HqlParser.expression_return expression290 = default(HqlParser.expression_return);\r\n\r\n        HqlParser.expression_return expression292 = default(HqlParser.expression_return);\r\n\r\n        HqlParser.expression_return expression293 = default(HqlParser.expression_return);\r\n\r\n        HqlParser.identifier_return identifier295 = default(HqlParser.identifier_return);\r\n\r\n        HqlParser.expression_return expression296 = default(HqlParser.expression_return);\r\n\r\n\r\n        IASTNode f_tree=null;\r\n        IASTNode f2_tree=null;\r\n        IASTNode TRAILING287_tree=null;\r\n        IASTNode LEADING288_tree=null;\r\n        IASTNode BOTH289_tree=null;\r\n        IASTNode COMMA291_tree=null;\r\n        IASTNode AS294_tree=null;\r\n\r\n        try \r\n    \t{\r\n            // Hql.g:625:2: ( ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA expression )+ | f= FROM expression | AS identifier )? | f2= FROM expression )? )\r\n            // Hql.g:625:4: ( TRAILING | LEADING | BOTH )? ( expression ( ( COMMA expression )+ | f= FROM expression | AS identifier )? | f2= FROM expression )?\r\n            {\r\n            \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n            \t// Hql.g:625:4: ( TRAILING | LEADING | BOTH )?\r\n            \tint alt103 = 4;\r\n            \tswitch ( input.LA(1) ) \r\n            \t{\r\n            \t    case TRAILING:\r\n            \t    \t{\r\n            \t        alt103 = 1;\r\n            \t        }\r\n            \t        break;\r\n            \t    case LEADING:\r\n            \t    \t{\r\n            \t        alt103 = 2;\r\n            \t        }\r\n            \t        break;\r\n            \t    case BOTH:\r\n            \t    \t{\r\n            \t        alt103 = 3;\r\n            \t        }\r\n            \t        break;\r\n            \t}\r\n\r\n            \tswitch (alt103) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:625:5: TRAILING\r\n            \t        {\r\n            \t        \tTRAILING287=(IToken)Match(input,TRAILING,FOLLOW_TRAILING_in_exprList3387); \r\n            \t        \t\tTRAILING287_tree = (IASTNode)adaptor.Create(TRAILING287);\r\n            \t        \t\tadaptor.AddChild(root_0, TRAILING287_tree);\r\n\r\n            \t        \tTRAILING287.Type = IDENT;\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 2 :\r\n            \t        // Hql.g:626:10: LEADING\r\n            \t        {\r\n            \t        \tLEADING288=(IToken)Match(input,LEADING,FOLLOW_LEADING_in_exprList3400); \r\n            \t        \t\tLEADING288_tree = (IASTNode)adaptor.Create(LEADING288);\r\n            \t        \t\tadaptor.AddChild(root_0, LEADING288_tree);\r\n\r\n            \t        \tLEADING288.Type = IDENT;\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 3 :\r\n            \t        // Hql.g:627:10: BOTH\r\n            \t        {\r\n            \t        \tBOTH289=(IToken)Match(input,BOTH,FOLLOW_BOTH_in_exprList3413); \r\n            \t        \t\tBOTH289_tree = (IASTNode)adaptor.Create(BOTH289);\r\n            \t        \t\tadaptor.AddChild(root_0, BOTH289_tree);\r\n\r\n            \t        \tBOTH289.Type = IDENT;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// Hql.g:629:4: ( expression ( ( COMMA expression )+ | f= FROM expression | AS identifier )? | f2= FROM expression )?\r\n            \tint alt106 = 3;\r\n            \tint LA106_0 = input.LA(1);\r\n\r\n            \tif ( ((LA106_0 >= ALL && LA106_0 <= ANY) || LA106_0 == AVG || LA106_0 == COUNT || LA106_0 == ELEMENTS || (LA106_0 >= EXISTS && LA106_0 <= FALSE) || LA106_0 == INDICES || (LA106_0 >= MAX && LA106_0 <= MIN) || (LA106_0 >= NOT && LA106_0 <= NULL) || (LA106_0 >= SOME && LA106_0 <= SUM) || LA106_0 == TRUE || LA106_0 == CASE || LA106_0 == EMPTY || (LA106_0 >= NUM_INT && LA106_0 <= NUM_LONG) || LA106_0 == OPEN || (LA106_0 >= COLON && LA106_0 <= PARAM) || LA106_0 == BNOT || (LA106_0 >= PLUS && LA106_0 <= MINUS) || (LA106_0 >= QUOTED_String && LA106_0 <= IDENT)) )\r\n            \t{\r\n            \t    alt106 = 1;\r\n            \t}\r\n            \telse if ( (LA106_0 == FROM) )\r\n            \t{\r\n            \t    alt106 = 2;\r\n            \t}\r\n            \tswitch (alt106) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // Hql.g:630:5: expression ( ( COMMA expression )+ | f= FROM expression | AS identifier )?\r\n            \t        {\r\n            \t        \tPushFollow(FOLLOW_expression_in_exprList3437);\r\n            \t        \texpression290 = expression();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_0, expression290.Tree);\r\n            \t        \t// Hql.g:630:16: ( ( COMMA expression )+ | f= FROM expression | AS identifier )?\r\n            \t        \tint alt105 = 4;\r\n            \t        \tswitch ( input.LA(1) ) \r\n            \t        \t{\r\n            \t        \t    case COMMA:\r\n            \t        \t    \t{\r\n            \t        \t        alt105 = 1;\r\n            \t        \t        }\r\n            \t        \t        break;\r\n            \t        \t    case FROM:\r\n            \t        \t    \t{\r\n            \t        \t        alt105 = 2;\r\n            \t        \t        }\r\n            \t        \t        break;\r\n            \t        \t    case AS:\r\n            \t        \t    \t{\r\n            \t        \t        alt105 = 3;\r\n            \t        \t        }\r\n            \t        \t        break;\r\n            \t        \t}\r\n\r\n            \t        \tswitch (alt105) \r\n            \t        \t{\r\n            \t        \t    case 1 :\r\n            \t        \t        // Hql.g:630:18: ( COMMA expression )+\r\n            \t        \t        {\r\n            \t        \t        \t// Hql.g:630:18: ( COMMA expression )+\r\n            \t        \t        \tint cnt104 = 0;\r\n            \t        \t        \tdo \r\n            \t        \t        \t{\r\n            \t        \t        \t    int alt104 = 2;\r\n            \t        \t        \t    int LA104_0 = input.LA(1);\r\n\r\n            \t        \t        \t    if ( (LA104_0 == COMMA) )\r\n            \t        \t        \t    {\r\n            \t        \t        \t        alt104 = 1;\r\n            \t        \t        \t    }\r\n\r\n\r\n            \t        \t        \t    switch (alt104) \r\n            \t        \t        \t\t{\r\n            \t        \t        \t\t\tcase 1 :\r\n            \t        \t        \t\t\t    // Hql.g:630:19: COMMA expression\r\n            \t        \t        \t\t\t    {\r\n            \t        \t        \t\t\t    \tCOMMA291=(IToken)Match(input,COMMA,FOLLOW_COMMA_in_exprList3442); \r\n            \t        \t        \t\t\t    \tPushFollow(FOLLOW_expression_in_exprList3445);\r\n            \t        \t        \t\t\t    \texpression292 = expression();\r\n            \t        \t        \t\t\t    \tstate.followingStackPointer--;\r\n\r\n            \t        \t        \t\t\t    \tadaptor.AddChild(root_0, expression292.Tree);\r\n\r\n            \t        \t        \t\t\t    }\r\n            \t        \t        \t\t\t    break;\r\n\r\n            \t        \t        \t\t\tdefault:\r\n            \t        \t        \t\t\t    if ( cnt104 >= 1 ) goto loop104;\r\n            \t        \t        \t\t            EarlyExitException eee104 =\r\n            \t        \t        \t\t                new EarlyExitException(104, input);\r\n            \t        \t        \t\t            throw eee104;\r\n            \t        \t        \t    }\r\n            \t        \t        \t    cnt104++;\r\n            \t        \t        \t} while (true);\r\n\r\n            \t        \t        \tloop104:\r\n            \t        \t        \t\t;\t// Stops C# compiler whining that label 'loop104' has no statements\r\n\r\n\r\n            \t        \t        }\r\n            \t        \t        break;\r\n            \t        \t    case 2 :\r\n            \t        \t        // Hql.g:631:9: f= FROM expression\r\n            \t        \t        {\r\n            \t        \t        \tf=(IToken)Match(input,FROM,FOLLOW_FROM_in_exprList3460); \r\n            \t        \t        \t\tf_tree = (IASTNode)adaptor.Create(f);\r\n            \t        \t        \t\tadaptor.AddChild(root_0, f_tree);\r\n\r\n            \t        \t        \tPushFollow(FOLLOW_expression_in_exprList3462);\r\n            \t        \t        \texpression293 = expression();\r\n            \t        \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \t        \tadaptor.AddChild(root_0, expression293.Tree);\r\n            \t        \t        \tf.Type = IDENT;\r\n\r\n            \t        \t        }\r\n            \t        \t        break;\r\n            \t        \t    case 3 :\r\n            \t        \t        // Hql.g:632:9: AS identifier\r\n            \t        \t        {\r\n            \t        \t        \tAS294=(IToken)Match(input,AS,FOLLOW_AS_in_exprList3474); \r\n            \t        \t        \tPushFollow(FOLLOW_identifier_in_exprList3477);\r\n            \t        \t        \tidentifier295 = identifier();\r\n            \t        \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \t        \tadaptor.AddChild(root_0, identifier295.Tree);\r\n\r\n            \t        \t        }\r\n            \t        \t        break;\r\n\r\n            \t        \t}\r\n\r\n\r\n            \t        }\r\n            \t        break;\r\n            \t    case 2 :\r\n            \t        // Hql.g:633:7: f2= FROM expression\r\n            \t        {\r\n            \t        \tf2=(IToken)Match(input,FROM,FOLLOW_FROM_in_exprList3491); \r\n            \t        \t\tf2_tree = (IASTNode)adaptor.Create(f2);\r\n            \t        \t\tadaptor.AddChild(root_0, f2_tree);\r\n\r\n            \t        \tPushFollow(FOLLOW_expression_in_exprList3493);\r\n            \t        \texpression296 = expression();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_0, expression296.Tree);\r\n            \t        \tf2.Type = IDENT;\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n\r\n            }\r\n\r\n            retval.Stop = input.LT(-1);\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n            \tadaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);\r\n\r\n               IASTNode root = (IASTNode) adaptor.Create(EXPR_LIST, \"exprList\");\r\n               root.AddChild((IASTNode)retval.Tree);\r\n               retval.Tree = root;\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n    \t// Conversion of the second argument necessary, but harmless\r\n    \tretval.Tree = (IASTNode)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);\r\n\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlParser.cs",
      "SourceLine": 10467
    },
    {
      "TypeIdentifier": "HqlParser",
      "MethodIdentifier": "primaryExpression",
      "SourcesSample": "public HqlParser.primaryExpression_return primaryExpression() // throws RecognitionException [1]\r\n    {   \r\n        HqlParser.primaryExpression_return retval = new HqlParser.primaryExpression_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IToken DOT243 = null;\r\n        IToken string_literal244 = null;\r\n        IToken COLON246 = null;\r\n        IToken OPEN248 = null;\r\n        IToken CLOSE251 = null;\r\n        IToken PARAM252 = null;\r\n        IToken NUM_INT253 = null;\r\n        HqlParser.identPrimary_return identPrimary242 = default(HqlParser.identPrimary_return);\r\n\r\n        HqlParser.constant_return constant245 = default(HqlParser.constant_return);\r\n\r\n        HqlParser.identifier_return identifier247 = default(HqlParser.identifier_return);\r\n\r\n        HqlParser.expressionOrVector_return expressionOrVector249 = default(HqlParser.expressionOrVector_return);\r\n\r\n        HqlParser.subQuery_return subQuery250 = default(HqlParser.subQuery_return);\r\n\r\n\r\n        IASTNode DOT243_tree=null;\r\n        IASTNode string_literal244_tree=null;\r\n        IASTNode COLON246_tree=null;\r\n        IASTNode OPEN248_tree=null;\r\n        IASTNode CLOSE251_tree=null;\r\n        IASTNode PARAM252_tree=null;\r\n        IASTNode NUM_INT253_tree=null;\r\n\r\n        try \r\n    \t{\r\n            // Hql.g:556:2: ( identPrimary ( options {greedy=true; } : DOT 'class' )? | constant | COLON identifier | OPEN ( expressionOrVector | subQuery ) CLOSE | PARAM ( NUM_INT )? )\r\n            int alt87 = 5;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case AVG:\r\n            case COUNT:\r\n            case ELEMENTS:\r\n            case INDICES:\r\n            case MAX:\r\n            case MIN:\r\n            case SUM:\r\n            case IDENT:\r\n            \t{\r\n                alt87 = 1;\r\n                }\r\n                break;\r\n            case FALSE:\r\n            case NULL:\r\n            case TRUE:\r\n            case EMPTY:\r\n            case NUM_INT:\r\n            case NUM_DOUBLE:\r\n            case NUM_DECIMAL:\r\n            case NUM_FLOAT:\r\n            case NUM_LONG:\r\n            case QUOTED_String:\r\n            \t{\r\n                alt87 = 2;\r\n                }\r\n                break;\r\n            case COLON:\r\n            \t{\r\n                alt87 = 3;\r\n                }\r\n                break;\r\n            case OPEN:\r\n            \t{\r\n                alt87 = 4;\r\n                }\r\n                break;\r\n            case PARAM:\r\n            \t{\r\n                alt87 = 5;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    NoViableAltException nvae_d87s0 =\r\n            \t        new NoViableAltException(\"\", 87, 0, input);\r\n\r\n            \t    throw nvae_d87s0;\r\n            }\r\n\r\n            switch (alt87) \r\n            {\r\n                case 1 :\r\n                    // Hql.g:556:6: identPrimary ( options {greedy=true; } : DOT 'class' )?\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \tPushFollow(FOLLOW_identPrimary_in_primaryExpression2874);\r\n                    \tidentPrimary242 = identPrimary();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tadaptor.AddChild(root_0, identPrimary242.Tree);\r\n                    \t// Hql.g:556:19: ( options {greedy=true; } : DOT 'class' )?\r\n                    \tint alt84 = 2;\r\n                    \tint LA84_0 = input.LA(1);\r\n\r\n                    \tif ( (LA84_0 == DOT) )\r\n                    \t{\r\n                    \t    int LA84_1 = input.LA(2);\r\n\r\n                    \t    if ( (LA84_1 == CLASS) )\r\n                    \t    {\r\n                    \t        alt84 = 1;\r\n                    \t    }\r\n                    \t}\r\n                    \tswitch (alt84) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:556:46: DOT 'class'\r\n                    \t        {\r\n                    \t        \tDOT243=(IToken)Match(input,DOT,FOLLOW_DOT_in_primaryExpression2887); \r\n                    \t        \t\tDOT243_tree = (IASTNode)adaptor.Create(DOT243);\r\n                    \t        \t\troot_0 = (IASTNode)adaptor.BecomeRoot(DOT243_tree, root_0);\r\n\r\n                    \t        \tstring_literal244=(IToken)Match(input,CLASS,FOLLOW_CLASS_in_primaryExpression2890); \r\n                    \t        \t\tstring_literal244_tree = (IASTNode)adaptor.Create(string_literal244);\r\n                    \t        \t\tadaptor.AddChild(root_0, string_literal244_tree);\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // Hql.g:557:6: constant\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \tPushFollow(FOLLOW_constant_in_primaryExpression2900);\r\n                    \tconstant245 = constant();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tadaptor.AddChild(root_0, constant245.Tree);\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // Hql.g:558:6: COLON identifier\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \tCOLON246=(IToken)Match(input,COLON,FOLLOW_COLON_in_primaryExpression2907); \r\n                    \t\tCOLON246_tree = (IASTNode)adaptor.Create(COLON246);\r\n                    \t\troot_0 = (IASTNode)adaptor.BecomeRoot(COLON246_tree, root_0);\r\n\r\n                    \tPushFollow(FOLLOW_identifier_in_primaryExpression2910);\r\n                    \tidentifier247 = identifier();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tadaptor.AddChild(root_0, identifier247.Tree);\r\n\r\n                    }\r\n                    break;\r\n                case 4 :\r\n                    // Hql.g:560:6: OPEN ( expressionOrVector | subQuery ) CLOSE\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \tOPEN248=(IToken)Match(input,OPEN,FOLLOW_OPEN_in_primaryExpression2919); \r\n                    \t// Hql.g:560:12: ( expressionOrVector | subQuery )\r\n                    \tint alt85 = 2;\r\n                    \tint LA85_0 = input.LA(1);\r\n\r\n                    \tif ( ((LA85_0 >= ALL && LA85_0 <= ANY) || LA85_0 == AVG || LA85_0 == COUNT || LA85_0 == ELEMENTS || (LA85_0 >= EXISTS && LA85_0 <= FALSE) || LA85_0 == INDICES || (LA85_0 >= MAX && LA85_0 <= MIN) || (LA85_0 >= NOT && LA85_0 <= NULL) || (LA85_0 >= SOME && LA85_0 <= SUM) || LA85_0 == TRUE || LA85_0 == CASE || LA85_0 == EMPTY || (LA85_0 >= NUM_INT && LA85_0 <= NUM_LONG) || LA85_0 == OPEN || (LA85_0 >= COLON && LA85_0 <= PARAM) || LA85_0 == BNOT || (LA85_0 >= PLUS && LA85_0 <= MINUS) || (LA85_0 >= QUOTED_String && LA85_0 <= IDENT)) )\r\n                    \t{\r\n                    \t    alt85 = 1;\r\n                    \t}\r\n                    \telse if ( (LA85_0 == EOF || LA85_0 == FROM || (LA85_0 >= GROUP && LA85_0 <= HAVING) || LA85_0 == ORDER || LA85_0 == SELECT || LA85_0 == SKIP || LA85_0 == TAKE || LA85_0 == UNION || LA85_0 == WHERE || LA85_0 == CLOSE) )\r\n                    \t{\r\n                    \t    alt85 = 2;\r\n                    \t}\r\n                    \telse \r\n                    \t{\r\n                    \t    NoViableAltException nvae_d85s0 =\r\n                    \t        new NoViableAltException(\"\", 85, 0, input);\r\n\r\n                    \t    throw nvae_d85s0;\r\n                    \t}\r\n                    \tswitch (alt85) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:560:13: expressionOrVector\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_expressionOrVector_in_primaryExpression2923);\r\n                    \t        \texpressionOrVector249 = expressionOrVector();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_0, expressionOrVector249.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n                    \t    case 2 :\r\n                    \t        // Hql.g:560:34: subQuery\r\n                    \t        {\r\n                    \t        \tPushFollow(FOLLOW_subQuery_in_primaryExpression2927);\r\n                    \t        \tsubQuery250 = subQuery();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_0, subQuery250.Tree);\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n                    \tCLOSE251=(IToken)Match(input,CLOSE,FOLLOW_CLOSE_in_primaryExpression2930); \r\n\r\n                    }\r\n                    break;\r\n                case 5 :\r\n                    // Hql.g:561:6: PARAM ( NUM_INT )?\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \tPARAM252=(IToken)Match(input,PARAM,FOLLOW_PARAM_in_primaryExpression2938); \r\n                    \t\tPARAM252_tree = (IASTNode)adaptor.Create(PARAM252);\r\n                    \t\troot_0 = (IASTNode)adaptor.BecomeRoot(PARAM252_tree, root_0);\r\n\r\n                    \t// Hql.g:561:13: ( NUM_INT )?\r\n                    \tint alt86 = 2;\r\n                    \tint LA86_0 = input.LA(1);\r\n\r\n                    \tif ( (LA86_0 == NUM_INT) )\r\n                    \t{\r\n                    \t    alt86 = 1;\r\n                    \t}\r\n                    \tswitch (alt86) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // Hql.g:561:14: NUM_INT\r\n                    \t        {\r\n                    \t        \tNUM_INT253=(IToken)Match(input,NUM_INT,FOLLOW_NUM_INT_in_primaryExpression2942); \r\n                    \t        \t\tNUM_INT253_tree = (IASTNode)adaptor.Create(NUM_INT253);\r\n                    \t        \t\tadaptor.AddChild(root_0, NUM_INT253_tree);\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n            retval.Stop = input.LT(-1);\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n            \tadaptor.SetTokenBoundaries(retval.Tree, (IToken) retval.Start, (IToken) retval.Stop);\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n    \t// Conversion of the second argument necessary, but harmless\r\n    \tretval.Tree = (IASTNode)adaptor.ErrorNode(input, (IToken) retval.Start, input.LT(-1), re);\r\n\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlParser.cs",
      "SourceLine": 8908
    }
  ],
  [
    {
      "TypeIdentifier": "HqlSqlWalker",
      "MethodIdentifier": "unionedQuery",
      "SourcesSample": "public HqlSqlWalker.unionedQuery_return unionedQuery() // throws RecognitionException [1]\r\n    {   \r\n        HqlSqlWalker.unionedQuery_return retval = new HqlSqlWalker.unionedQuery_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IASTNode _first_0 = null;\r\n        IASTNode _last = null;\r\n\r\n        IASTNode QUERY25 = null;\r\n        IASTNode SELECT_FROM26 = null;\r\n        HqlSqlWalker.fromClause_return f = default(HqlSqlWalker.fromClause_return);\r\n\r\n        HqlSqlWalker.selectClause_return s = default(HqlSqlWalker.selectClause_return);\r\n\r\n        HqlSqlWalker.whereClause_return w = default(HqlSqlWalker.whereClause_return);\r\n\r\n        HqlSqlWalker.groupClause_return g = default(HqlSqlWalker.groupClause_return);\r\n\r\n        HqlSqlWalker.havingClause_return h = default(HqlSqlWalker.havingClause_return);\r\n\r\n        HqlSqlWalker.orderClause_return o = default(HqlSqlWalker.orderClause_return);\r\n\r\n        HqlSqlWalker.skipClause_return sk = default(HqlSqlWalker.skipClause_return);\r\n\r\n        HqlSqlWalker.takeClause_return tk = default(HqlSqlWalker.takeClause_return);\r\n\r\n\r\n        IASTNode QUERY25_tree=null;\r\n        IASTNode SELECT_FROM26_tree=null;\r\n        RewriteRuleNodeStream stream_SELECT_FROM = new RewriteRuleNodeStream(adaptor,\"token SELECT_FROM\");\r\n        RewriteRuleNodeStream stream_QUERY = new RewriteRuleNodeStream(adaptor,\"token QUERY\");\r\n        RewriteRuleSubtreeStream stream_whereClause = new RewriteRuleSubtreeStream(adaptor,\"rule whereClause\");\r\n        RewriteRuleSubtreeStream stream_skipClause = new RewriteRuleSubtreeStream(adaptor,\"rule skipClause\");\r\n        RewriteRuleSubtreeStream stream_orderClause = new RewriteRuleSubtreeStream(adaptor,\"rule orderClause\");\r\n        RewriteRuleSubtreeStream stream_groupClause = new RewriteRuleSubtreeStream(adaptor,\"rule groupClause\");\r\n        RewriteRuleSubtreeStream stream_havingClause = new RewriteRuleSubtreeStream(adaptor,\"rule havingClause\");\r\n        RewriteRuleSubtreeStream stream_fromClause = new RewriteRuleSubtreeStream(adaptor,\"rule fromClause\");\r\n        RewriteRuleSubtreeStream stream_selectClause = new RewriteRuleSubtreeStream(adaptor,\"rule selectClause\");\r\n        RewriteRuleSubtreeStream stream_takeClause = new RewriteRuleSubtreeStream(adaptor,\"rule takeClause\");\r\n        try \r\n    \t{\r\n            // HqlSqlWalker.g:126:2: ( ^( QUERY ^( SELECT_FROM f= fromClause (s= selectClause )? ) (w= whereClause )? (g= groupClause )? (h= havingClause )? (o= orderClause )? (sk= skipClause )? (tk= takeClause )? ) -> ^( SELECT ( $s)? $f ( $w)? ( $g)? ( $h)? ( $o)? ( $sk)? ( $tk)? ) )\r\n            // HqlSqlWalker.g:126:4: ^( QUERY ^( SELECT_FROM f= fromClause (s= selectClause )? ) (w= whereClause )? (g= groupClause )? (h= havingClause )? (o= orderClause )? (sk= skipClause )? (tk= takeClause )? )\r\n            {\r\n            \t_last = (IASTNode)input.LT(1);\r\n            \t{\r\n            \tIASTNode _save_last_1 = _last;\r\n            \tIASTNode _first_1 = null;\r\n            \tIASTNode root_1 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n            \tQUERY25=(IASTNode)Match(input,QUERY,FOLLOW_QUERY_in_unionedQuery503);  \r\n            \tstream_QUERY.Add(QUERY25);\r\n\r\n\r\n            \t BeforeStatement( \"select\", SELECT ); \r\n\r\n            \tMatch(input, Token.DOWN, null); \r\n            \t_last = (IASTNode)input.LT(1);\r\n            \t{\r\n            \tIASTNode _save_last_2 = _last;\r\n            \tIASTNode _first_2 = null;\r\n            \tIASTNode root_2 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n            \tSELECT_FROM26=(IASTNode)Match(input,SELECT_FROM,FOLLOW_SELECT_FROM_in_unionedQuery515);  \r\n            \tstream_SELECT_FROM.Add(SELECT_FROM26);\r\n\r\n\r\n\r\n            \tMatch(input, Token.DOWN, null); \r\n            \t_last = (IASTNode)input.LT(1);\r\n            \tPushFollow(FOLLOW_fromClause_in_unionedQuery523);\r\n            \tf = fromClause();\r\n            \tstate.followingStackPointer--;\r\n\r\n            \tstream_fromClause.Add(f.Tree);\r\n            \t// HqlSqlWalker.g:130:5: (s= selectClause )?\r\n            \tint alt9 = 2;\r\n            \tint LA9_0 = input.LA(1);\r\n\r\n            \tif ( (LA9_0 == SELECT) )\r\n            \t{\r\n            \t    alt9 = 1;\r\n            \t}\r\n            \tswitch (alt9) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:130:6: s= selectClause\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tPushFollow(FOLLOW_selectClause_in_unionedQuery532);\r\n            \t        \ts = selectClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tstream_selectClause.Add(s.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n\r\n            \tMatch(input, Token.UP, null); adaptor.AddChild(root_1, root_2);_last = _save_last_2;\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:132:4: (w= whereClause )?\r\n            \tint alt10 = 2;\r\n            \tint LA10_0 = input.LA(1);\r\n\r\n            \tif ( (LA10_0 == WHERE) )\r\n            \t{\r\n            \t    alt10 = 1;\r\n            \t}\r\n            \tswitch (alt10) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:132:5: w= whereClause\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tPushFollow(FOLLOW_whereClause_in_unionedQuery547);\r\n            \t        \tw = whereClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tstream_whereClause.Add(w.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:133:4: (g= groupClause )?\r\n            \tint alt11 = 2;\r\n            \tint LA11_0 = input.LA(1);\r\n\r\n            \tif ( (LA11_0 == GROUP) )\r\n            \t{\r\n            \t    alt11 = 1;\r\n            \t}\r\n            \tswitch (alt11) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:133:5: g= groupClause\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tPushFollow(FOLLOW_groupClause_in_unionedQuery557);\r\n            \t        \tg = groupClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tstream_groupClause.Add(g.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:134:4: (h= havingClause )?\r\n            \tint alt12 = 2;\r\n            \tint LA12_0 = input.LA(1);\r\n\r\n            \tif ( (LA12_0 == HAVING) )\r\n            \t{\r\n            \t    alt12 = 1;\r\n            \t}\r\n            \tswitch (alt12) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:134:5: h= havingClause\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tPushFollow(FOLLOW_havingClause_in_unionedQuery567);\r\n            \t        \th = havingClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tstream_havingClause.Add(h.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:135:4: (o= orderClause )?\r\n            \tint alt13 = 2;\r\n            \tint LA13_0 = input.LA(1);\r\n\r\n            \tif ( (LA13_0 == ORDER) )\r\n            \t{\r\n            \t    alt13 = 1;\r\n            \t}\r\n            \tswitch (alt13) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:135:5: o= orderClause\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tPushFollow(FOLLOW_orderClause_in_unionedQuery577);\r\n            \t        \to = orderClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tstream_orderClause.Add(o.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:136:4: (sk= skipClause )?\r\n            \tint alt14 = 2;\r\n            \tint LA14_0 = input.LA(1);\r\n\r\n            \tif ( (LA14_0 == SKIP) )\r\n            \t{\r\n            \t    alt14 = 1;\r\n            \t}\r\n            \tswitch (alt14) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:136:5: sk= skipClause\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tPushFollow(FOLLOW_skipClause_in_unionedQuery587);\r\n            \t        \tsk = skipClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tstream_skipClause.Add(sk.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:137:4: (tk= takeClause )?\r\n            \tint alt15 = 2;\r\n            \tint LA15_0 = input.LA(1);\r\n\r\n            \tif ( (LA15_0 == TAKE) )\r\n            \t{\r\n            \t    alt15 = 1;\r\n            \t}\r\n            \tswitch (alt15) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:137:5: tk= takeClause\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tPushFollow(FOLLOW_takeClause_in_unionedQuery597);\r\n            \t        \ttk = takeClause();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tstream_takeClause.Add(tk.Tree);\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n\r\n            \tMatch(input, Token.UP, null); adaptor.AddChild(root_0, root_1);_last = _save_last_1;\r\n            \t}\r\n\r\n\r\n\r\n            \t// AST REWRITE\r\n            \t// elements:          sk, o, h, g, s, tk, w, f\r\n            \t// token labels:      \r\n            \t// rule labels:       f, w, g, sk, retval, s, o, tk, h\r\n            \t// token list labels: \r\n            \t// rule list labels:  \r\n            \t// wildcard labels: \r\n            \tretval.Tree = root_0;\r\n            \tRewriteRuleSubtreeStream stream_f = new RewriteRuleSubtreeStream(adaptor, \"rule f\", f!=null ? f.Tree : null);\r\n            \tRewriteRuleSubtreeStream stream_w = new RewriteRuleSubtreeStream(adaptor, \"rule w\", w!=null ? w.Tree : null);\r\n            \tRewriteRuleSubtreeStream stream_g = new RewriteRuleSubtreeStream(adaptor, \"rule g\", g!=null ? g.Tree : null);\r\n            \tRewriteRuleSubtreeStream stream_sk = new RewriteRuleSubtreeStream(adaptor, \"rule sk\", sk!=null ? sk.Tree : null);\r\n            \tRewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, \"rule retval\", retval!=null ? retval.Tree : null);\r\n            \tRewriteRuleSubtreeStream stream_s = new RewriteRuleSubtreeStream(adaptor, \"rule s\", s!=null ? s.Tree : null);\r\n            \tRewriteRuleSubtreeStream stream_o = new RewriteRuleSubtreeStream(adaptor, \"rule o\", o!=null ? o.Tree : null);\r\n            \tRewriteRuleSubtreeStream stream_tk = new RewriteRuleSubtreeStream(adaptor, \"rule tk\", tk!=null ? tk.Tree : null);\r\n            \tRewriteRuleSubtreeStream stream_h = new RewriteRuleSubtreeStream(adaptor, \"rule h\", h!=null ? h.Tree : null);\r\n\r\n            \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n            \t// 139:2: -> ^( SELECT ( $s)? $f ( $w)? ( $g)? ( $h)? ( $o)? ( $sk)? ( $tk)? )\r\n            \t{\r\n            \t    // HqlSqlWalker.g:139:5: ^( SELECT ( $s)? $f ( $w)? ( $g)? ( $h)? ( $o)? ( $sk)? ( $tk)? )\r\n            \t    {\r\n            \t    IASTNode root_1 = (IASTNode)adaptor.GetNilNode();\r\n            \t    root_1 = (IASTNode)adaptor.BecomeRoot((IASTNode)adaptor.Create(SELECT, \"SELECT\"), root_1);\r\n\r\n            \t    // HqlSqlWalker.g:139:14: ( $s)?\r\n            \t    if ( stream_s.HasNext() )\r\n            \t    {\r\n            \t        adaptor.AddChild(root_1, stream_s.NextTree());\r\n\r\n            \t    }\r\n            \t    stream_s.Reset();\r\n            \t    adaptor.AddChild(root_1, stream_f.NextTree());\r\n            \t    // HqlSqlWalker.g:139:21: ( $w)?\r\n            \t    if ( stream_w.HasNext() )\r\n            \t    {\r\n            \t        adaptor.AddChild(root_1, stream_w.NextTree());\r\n\r\n            \t    }\r\n            \t    stream_w.Reset();\r\n            \t    // HqlSqlWalker.g:139:25: ( $g)?\r\n            \t    if ( stream_g.HasNext() )\r\n            \t    {\r\n            \t        adaptor.AddChild(root_1, stream_g.NextTree());\r\n\r\n            \t    }\r\n            \t    stream_g.Reset();\r\n            \t    // HqlSqlWalker.g:139:29: ( $h)?\r\n            \t    if ( stream_h.HasNext() )\r\n            \t    {\r\n            \t        adaptor.AddChild(root_1, stream_h.NextTree());\r\n\r\n            \t    }\r\n            \t    stream_h.Reset();\r\n            \t    // HqlSqlWalker.g:139:33: ( $o)?\r\n            \t    if ( stream_o.HasNext() )\r\n            \t    {\r\n            \t        adaptor.AddChild(root_1, stream_o.NextTree());\r\n\r\n            \t    }\r\n            \t    stream_o.Reset();\r\n            \t    // HqlSqlWalker.g:139:37: ( $sk)?\r\n            \t    if ( stream_sk.HasNext() )\r\n            \t    {\r\n            \t        adaptor.AddChild(root_1, stream_sk.NextTree());\r\n\r\n            \t    }\r\n            \t    stream_sk.Reset();\r\n            \t    // HqlSqlWalker.g:139:42: ( $tk)?\r\n            \t    if ( stream_tk.HasNext() )\r\n            \t    {\r\n            \t        adaptor.AddChild(root_1, stream_tk.NextTree());\r\n\r\n            \t    }\r\n            \t    stream_tk.Reset();\r\n\r\n            \t    adaptor.AddChild(root_0, root_1);\r\n            \t    }\r\n\r\n            \t}\r\n\r\n            \tretval.Tree = root_0;\r\n            }\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n\r\n\r\n            \t\t// Antlr note: #x_in refers to the input AST, #x refers to the output AST\r\n            \t\tBeforeStatementCompletion( \"select\" );\r\n            \t\tProcessQuery( ((s != null) ? ((IASTNode)s.Tree) : null), ((IASTNode)retval.Tree) );\r\n            \t\tAfterStatementCompletion( \"select\" );\r\n            \t\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 22,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlSqlWalker.cs",
      "SourceLine": 1586
    },
    {
      "TypeIdentifier": "HqlSqlWalker",
      "MethodIdentifier": "caseExpr",
      "SourcesSample": "public HqlSqlWalker.caseExpr_return caseExpr() // throws RecognitionException [1]\r\n    {   \r\n        HqlSqlWalker.caseExpr_return retval = new HqlSqlWalker.caseExpr_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IASTNode _first_0 = null;\r\n        IASTNode _last = null;\r\n\r\n        IASTNode CASE181 = null;\r\n        IASTNode WHEN182 = null;\r\n        IASTNode ELSE185 = null;\r\n        IASTNode CASE2187 = null;\r\n        IASTNode WHEN189 = null;\r\n        IASTNode ELSE192 = null;\r\n        HqlSqlWalker.logicalExpr_return logicalExpr183 = default(HqlSqlWalker.logicalExpr_return);\r\n\r\n        HqlSqlWalker.expr_return expr184 = default(HqlSqlWalker.expr_return);\r\n\r\n        HqlSqlWalker.expr_return expr186 = default(HqlSqlWalker.expr_return);\r\n\r\n        HqlSqlWalker.expr_return expr188 = default(HqlSqlWalker.expr_return);\r\n\r\n        HqlSqlWalker.expr_return expr190 = default(HqlSqlWalker.expr_return);\r\n\r\n        HqlSqlWalker.expr_return expr191 = default(HqlSqlWalker.expr_return);\r\n\r\n        HqlSqlWalker.expr_return expr193 = default(HqlSqlWalker.expr_return);\r\n\r\n\r\n        IASTNode CASE181_tree=null;\r\n        IASTNode WHEN182_tree=null;\r\n        IASTNode ELSE185_tree=null;\r\n        IASTNode CASE2187_tree=null;\r\n        IASTNode WHEN189_tree=null;\r\n        IASTNode ELSE192_tree=null;\r\n\r\n        try \r\n    \t{\r\n            // HqlSqlWalker.g:404:2: ( ^( CASE ( ^( WHEN logicalExpr expr ) )+ ( ^( ELSE expr ) )? ) | ^( CASE2 expr ( ^( WHEN expr expr ) )+ ( ^( ELSE expr ) )? ) )\r\n            int alt60 = 2;\r\n            int LA60_0 = input.LA(1);\r\n\r\n            if ( (LA60_0 == CASE) )\r\n            {\r\n                alt60 = 1;\r\n            }\r\n            else if ( (LA60_0 == CASE2) )\r\n            {\r\n                alt60 = 2;\r\n            }\r\n            else \r\n            {\r\n                NoViableAltException nvae_d60s0 =\r\n                    new NoViableAltException(\"\", 60, 0, input);\r\n\r\n                throw nvae_d60s0;\r\n            }\r\n            switch (alt60) \r\n            {\r\n                case 1 :\r\n                    // HqlSqlWalker.g:404:4: ^( CASE ( ^( WHEN logicalExpr expr ) )+ ( ^( ELSE expr ) )? )\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \t_last = (IASTNode)input.LT(1);\r\n                    \t{\r\n                    \tIASTNode _save_last_1 = _last;\r\n                    \tIASTNode _first_1 = null;\r\n                    \tIASTNode root_1 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n                    \tCASE181=(IASTNode)Match(input,CASE,FOLLOW_CASE_in_caseExpr2082); \r\n                    \t\tCASE181_tree = (IASTNode)adaptor.DupNode(CASE181);\r\n\r\n                    \t\troot_1 = (IASTNode)adaptor.BecomeRoot(CASE181_tree, root_1);\r\n\r\n\r\n                    \t _inCase = true; \r\n\r\n                    \tMatch(input, Token.DOWN, null); \r\n                    \t// HqlSqlWalker.g:404:31: ( ^( WHEN logicalExpr expr ) )+\r\n                    \tint cnt56 = 0;\r\n                    \tdo \r\n                    \t{\r\n                    \t    int alt56 = 2;\r\n                    \t    int LA56_0 = input.LA(1);\r\n\r\n                    \t    if ( (LA56_0 == WHEN) )\r\n                    \t    {\r\n                    \t        alt56 = 1;\r\n                    \t    }\r\n\r\n\r\n                    \t    switch (alt56) \r\n                    \t\t{\r\n                    \t\t\tcase 1 :\r\n                    \t\t\t    // HqlSqlWalker.g:404:32: ^( WHEN logicalExpr expr )\r\n                    \t\t\t    {\r\n                    \t\t\t    \t_last = (IASTNode)input.LT(1);\r\n                    \t\t\t    \t{\r\n                    \t\t\t    \tIASTNode _save_last_2 = _last;\r\n                    \t\t\t    \tIASTNode _first_2 = null;\r\n                    \t\t\t    \tIASTNode root_2 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n                    \t\t\t    \tWHEN182=(IASTNode)Match(input,WHEN,FOLLOW_WHEN_in_caseExpr2088); \r\n                    \t\t\t    \t\tWHEN182_tree = (IASTNode)adaptor.DupNode(WHEN182);\r\n\r\n                    \t\t\t    \t\troot_2 = (IASTNode)adaptor.BecomeRoot(WHEN182_tree, root_2);\r\n\r\n\r\n\r\n                    \t\t\t    \tMatch(input, Token.DOWN, null); \r\n                    \t\t\t    \t_last = (IASTNode)input.LT(1);\r\n                    \t\t\t    \tPushFollow(FOLLOW_logicalExpr_in_caseExpr2090);\r\n                    \t\t\t    \tlogicalExpr183 = logicalExpr();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n\r\n                    \t\t\t    \tadaptor.AddChild(root_2, logicalExpr183.Tree);\r\n                    \t\t\t    \t_last = (IASTNode)input.LT(1);\r\n                    \t\t\t    \tPushFollow(FOLLOW_expr_in_caseExpr2092);\r\n                    \t\t\t    \texpr184 = expr();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n\r\n                    \t\t\t    \tadaptor.AddChild(root_2, expr184.Tree);\r\n\r\n                    \t\t\t    \tMatch(input, Token.UP, null); adaptor.AddChild(root_1, root_2);_last = _save_last_2;\r\n                    \t\t\t    \t}\r\n\r\n\r\n                    \t\t\t    }\r\n                    \t\t\t    break;\r\n\r\n                    \t\t\tdefault:\r\n                    \t\t\t    if ( cnt56 >= 1 ) goto loop56;\r\n                    \t\t            EarlyExitException eee56 =\r\n                    \t\t                new EarlyExitException(56, input);\r\n                    \t\t            throw eee56;\r\n                    \t    }\r\n                    \t    cnt56++;\r\n                    \t} while (true);\r\n\r\n                    \tloop56:\r\n                    \t\t;\t// Stops C# compiler whining that label 'loop56' has no statements\r\n\r\n                    \t// HqlSqlWalker.g:404:59: ( ^( ELSE expr ) )?\r\n                    \tint alt57 = 2;\r\n                    \tint LA57_0 = input.LA(1);\r\n\r\n                    \tif ( (LA57_0 == ELSE) )\r\n                    \t{\r\n                    \t    alt57 = 1;\r\n                    \t}\r\n                    \tswitch (alt57) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // HqlSqlWalker.g:404:60: ^( ELSE expr )\r\n                    \t        {\r\n                    \t        \t_last = (IASTNode)input.LT(1);\r\n                    \t        \t{\r\n                    \t        \tIASTNode _save_last_2 = _last;\r\n                    \t        \tIASTNode _first_2 = null;\r\n                    \t        \tIASTNode root_2 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n                    \t        \tELSE185=(IASTNode)Match(input,ELSE,FOLLOW_ELSE_in_caseExpr2099); \r\n                    \t        \t\tELSE185_tree = (IASTNode)adaptor.DupNode(ELSE185);\r\n\r\n                    \t        \t\troot_2 = (IASTNode)adaptor.BecomeRoot(ELSE185_tree, root_2);\r\n\r\n\r\n\r\n                    \t        \tMatch(input, Token.DOWN, null); \r\n                    \t        \t_last = (IASTNode)input.LT(1);\r\n                    \t        \tPushFollow(FOLLOW_expr_in_caseExpr2101);\r\n                    \t        \texpr186 = expr();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_2, expr186.Tree);\r\n\r\n                    \t        \tMatch(input, Token.UP, null); adaptor.AddChild(root_1, root_2);_last = _save_last_2;\r\n                    \t        \t}\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    \tMatch(input, Token.UP, null); adaptor.AddChild(root_0, root_1);_last = _save_last_1;\r\n                    \t}\r\n\r\n                    \t _inCase = false; \r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // HqlSqlWalker.g:405:4: ^( CASE2 expr ( ^( WHEN expr expr ) )+ ( ^( ELSE expr ) )? )\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \t_last = (IASTNode)input.LT(1);\r\n                    \t{\r\n                    \tIASTNode _save_last_1 = _last;\r\n                    \tIASTNode _first_1 = null;\r\n                    \tIASTNode root_1 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n                    \tCASE2187=(IASTNode)Match(input,CASE2,FOLLOW_CASE2_in_caseExpr2113); \r\n                    \t\tCASE2187_tree = (IASTNode)adaptor.DupNode(CASE2187);\r\n\r\n                    \t\troot_1 = (IASTNode)adaptor.BecomeRoot(CASE2187_tree, root_1);\r\n\r\n\r\n                    \t _inCase = true; \r\n\r\n                    \tMatch(input, Token.DOWN, null); \r\n                    \t_last = (IASTNode)input.LT(1);\r\n                    \tPushFollow(FOLLOW_expr_in_caseExpr2117);\r\n                    \texpr188 = expr();\r\n                    \tstate.followingStackPointer--;\r\n\r\n                    \tadaptor.AddChild(root_1, expr188.Tree);\r\n                    \t// HqlSqlWalker.g:405:37: ( ^( WHEN expr expr ) )+\r\n                    \tint cnt58 = 0;\r\n                    \tdo \r\n                    \t{\r\n                    \t    int alt58 = 2;\r\n                    \t    int LA58_0 = input.LA(1);\r\n\r\n                    \t    if ( (LA58_0 == WHEN) )\r\n                    \t    {\r\n                    \t        alt58 = 1;\r\n                    \t    }\r\n\r\n\r\n                    \t    switch (alt58) \r\n                    \t\t{\r\n                    \t\t\tcase 1 :\r\n                    \t\t\t    // HqlSqlWalker.g:405:38: ^( WHEN expr expr )\r\n                    \t\t\t    {\r\n                    \t\t\t    \t_last = (IASTNode)input.LT(1);\r\n                    \t\t\t    \t{\r\n                    \t\t\t    \tIASTNode _save_last_2 = _last;\r\n                    \t\t\t    \tIASTNode _first_2 = null;\r\n                    \t\t\t    \tIASTNode root_2 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n                    \t\t\t    \tWHEN189=(IASTNode)Match(input,WHEN,FOLLOW_WHEN_in_caseExpr2121); \r\n                    \t\t\t    \t\tWHEN189_tree = (IASTNode)adaptor.DupNode(WHEN189);\r\n\r\n                    \t\t\t    \t\troot_2 = (IASTNode)adaptor.BecomeRoot(WHEN189_tree, root_2);\r\n\r\n\r\n\r\n                    \t\t\t    \tMatch(input, Token.DOWN, null); \r\n                    \t\t\t    \t_last = (IASTNode)input.LT(1);\r\n                    \t\t\t    \tPushFollow(FOLLOW_expr_in_caseExpr2123);\r\n                    \t\t\t    \texpr190 = expr();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n\r\n                    \t\t\t    \tadaptor.AddChild(root_2, expr190.Tree);\r\n                    \t\t\t    \t_last = (IASTNode)input.LT(1);\r\n                    \t\t\t    \tPushFollow(FOLLOW_expr_in_caseExpr2125);\r\n                    \t\t\t    \texpr191 = expr();\r\n                    \t\t\t    \tstate.followingStackPointer--;\r\n\r\n                    \t\t\t    \tadaptor.AddChild(root_2, expr191.Tree);\r\n\r\n                    \t\t\t    \tMatch(input, Token.UP, null); adaptor.AddChild(root_1, root_2);_last = _save_last_2;\r\n                    \t\t\t    \t}\r\n\r\n\r\n                    \t\t\t    }\r\n                    \t\t\t    break;\r\n\r\n                    \t\t\tdefault:\r\n                    \t\t\t    if ( cnt58 >= 1 ) goto loop58;\r\n                    \t\t            EarlyExitException eee58 =\r\n                    \t\t                new EarlyExitException(58, input);\r\n                    \t\t            throw eee58;\r\n                    \t    }\r\n                    \t    cnt58++;\r\n                    \t} while (true);\r\n\r\n                    \tloop58:\r\n                    \t\t;\t// Stops C# compiler whining that label 'loop58' has no statements\r\n\r\n                    \t// HqlSqlWalker.g:405:58: ( ^( ELSE expr ) )?\r\n                    \tint alt59 = 2;\r\n                    \tint LA59_0 = input.LA(1);\r\n\r\n                    \tif ( (LA59_0 == ELSE) )\r\n                    \t{\r\n                    \t    alt59 = 1;\r\n                    \t}\r\n                    \tswitch (alt59) \r\n                    \t{\r\n                    \t    case 1 :\r\n                    \t        // HqlSqlWalker.g:405:59: ^( ELSE expr )\r\n                    \t        {\r\n                    \t        \t_last = (IASTNode)input.LT(1);\r\n                    \t        \t{\r\n                    \t        \tIASTNode _save_last_2 = _last;\r\n                    \t        \tIASTNode _first_2 = null;\r\n                    \t        \tIASTNode root_2 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n                    \t        \tELSE192=(IASTNode)Match(input,ELSE,FOLLOW_ELSE_in_caseExpr2132); \r\n                    \t        \t\tELSE192_tree = (IASTNode)adaptor.DupNode(ELSE192);\r\n\r\n                    \t        \t\troot_2 = (IASTNode)adaptor.BecomeRoot(ELSE192_tree, root_2);\r\n\r\n\r\n\r\n                    \t        \tMatch(input, Token.DOWN, null); \r\n                    \t        \t_last = (IASTNode)input.LT(1);\r\n                    \t        \tPushFollow(FOLLOW_expr_in_caseExpr2134);\r\n                    \t        \texpr193 = expr();\r\n                    \t        \tstate.followingStackPointer--;\r\n\r\n                    \t        \tadaptor.AddChild(root_2, expr193.Tree);\r\n\r\n                    \t        \tMatch(input, Token.UP, null); adaptor.AddChild(root_1, root_2);_last = _save_last_2;\r\n                    \t        \t}\r\n\r\n\r\n                    \t        }\r\n                    \t        break;\r\n\r\n                    \t}\r\n\r\n\r\n                    \tMatch(input, Token.UP, null); adaptor.AddChild(root_0, root_1);_last = _save_last_1;\r\n                    \t}\r\n\r\n                    \t _inCase = false; \r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 16,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlSqlWalker.cs",
      "SourceLine": 7626
    },
    {
      "TypeIdentifier": "HqlSqlWalker",
      "MethodIdentifier": "joinElement",
      "SourcesSample": "public HqlSqlWalker.joinElement_return joinElement() // throws RecognitionException [1]\r\n    {   \r\n        HqlSqlWalker.joinElement_return retval = new HqlSqlWalker.joinElement_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IASTNode _first_0 = null;\r\n        IASTNode _last = null;\r\n\r\n        IASTNode f = null;\r\n        IASTNode a = null;\r\n        IASTNode pf = null;\r\n        IASTNode with = null;\r\n        IASTNode JOIN70 = null;\r\n        IASTNode wildcard71 = null;\r\n        HqlSqlWalker.joinType_return j = default(HqlSqlWalker.joinType_return);\r\n\r\n        HqlSqlWalker.propertyRef_return pRef = default(HqlSqlWalker.propertyRef_return);\r\n\r\n\r\n        IASTNode f_tree=null;\r\n        IASTNode a_tree=null;\r\n        IASTNode pf_tree=null;\r\n        IASTNode with_tree=null;\r\n        IASTNode JOIN70_tree=null;\r\n        IASTNode wildcard71_tree=null;\r\n\r\n        try \r\n    \t{\r\n            // HqlSqlWalker.g:253:2: ( ^( JOIN (j= joinType )? (f= FETCH )? pRef= propertyRef (a= ALIAS )? (pf= FETCH )? ( ^( (with= WITH ) ( . )* ) )? ) )\r\n            // HqlSqlWalker.g:253:4: ^( JOIN (j= joinType )? (f= FETCH )? pRef= propertyRef (a= ALIAS )? (pf= FETCH )? ( ^( (with= WITH ) ( . )* ) )? )\r\n            {\r\n            \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n            \t_last = (IASTNode)input.LT(1);\r\n            \t{\r\n            \tIASTNode _save_last_1 = _last;\r\n            \tIASTNode _first_1 = null;\r\n            \tIASTNode root_1 = (IASTNode)adaptor.GetNilNode();_last = (IASTNode)input.LT(1);\r\n            \tJOIN70=(IASTNode)Match(input,JOIN,FOLLOW_JOIN_in_joinElement1216); \r\n            \t\tJOIN70_tree = (IASTNode)adaptor.DupNode(JOIN70);\r\n\r\n            \t\troot_1 = (IASTNode)adaptor.BecomeRoot(JOIN70_tree, root_1);\r\n\r\n\r\n\r\n            \tMatch(input, Token.DOWN, null); \r\n            \t// HqlSqlWalker.g:253:11: (j= joinType )?\r\n            \tint alt34 = 2;\r\n            \tint LA34_0 = input.LA(1);\r\n\r\n            \tif ( (LA34_0 == FULL || LA34_0 == INNER || LA34_0 == LEFT || LA34_0 == RIGHT) )\r\n            \t{\r\n            \t    alt34 = 1;\r\n            \t}\r\n            \tswitch (alt34) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:253:12: j= joinType\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tPushFollow(FOLLOW_joinType_in_joinElement1221);\r\n            \t        \tj = joinType();\r\n            \t        \tstate.followingStackPointer--;\r\n\r\n            \t        \tadaptor.AddChild(root_1, j.Tree);\r\n            \t        \t SetImpliedJoinType(((j != null) ? j.j : default(int))); \r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:253:56: (f= FETCH )?\r\n            \tint alt35 = 2;\r\n            \tint LA35_0 = input.LA(1);\r\n\r\n            \tif ( (LA35_0 == FETCH) )\r\n            \t{\r\n            \t    alt35 = 1;\r\n            \t}\r\n            \tswitch (alt35) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:253:57: f= FETCH\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tf=(IASTNode)Match(input,FETCH,FOLLOW_FETCH_in_joinElement1231); \r\n            \t        \t\tf_tree = (IASTNode)adaptor.DupNode(f);\r\n\r\n            \t        \t\tadaptor.AddChild(root_1, f_tree);\r\n\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t_last = (IASTNode)input.LT(1);\r\n            \tPushFollow(FOLLOW_propertyRef_in_joinElement1237);\r\n            \tpRef = propertyRef();\r\n            \tstate.followingStackPointer--;\r\n\r\n            \tadaptor.AddChild(root_1, pRef.Tree);\r\n            \t// HqlSqlWalker.g:253:84: (a= ALIAS )?\r\n            \tint alt36 = 2;\r\n            \tint LA36_0 = input.LA(1);\r\n\r\n            \tif ( (LA36_0 == ALIAS) )\r\n            \t{\r\n            \t    alt36 = 1;\r\n            \t}\r\n            \tswitch (alt36) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:253:85: a= ALIAS\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \ta=(IASTNode)Match(input,ALIAS,FOLLOW_ALIAS_in_joinElement1242); \r\n            \t        \t\ta_tree = (IASTNode)adaptor.DupNode(a);\r\n\r\n            \t        \t\tadaptor.AddChild(root_1, a_tree);\r\n\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:253:95: (pf= FETCH )?\r\n            \tint alt37 = 2;\r\n            \tint LA37_0 = input.LA(1);\r\n\r\n            \tif ( (LA37_0 == FETCH) )\r\n            \t{\r\n            \t    alt37 = 1;\r\n            \t}\r\n            \tswitch (alt37) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:253:96: pf= FETCH\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \tpf=(IASTNode)Match(input,FETCH,FOLLOW_FETCH_in_joinElement1249); \r\n            \t        \t\tpf_tree = (IASTNode)adaptor.DupNode(pf);\r\n\r\n            \t        \t\tadaptor.AddChild(root_1, pf_tree);\r\n\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n            \t// HqlSqlWalker.g:253:107: ( ^( (with= WITH ) ( . )* ) )?\r\n            \tint alt39 = 2;\r\n            \tint LA39_0 = input.LA(1);\r\n\r\n            \tif ( (LA39_0 == WITH) )\r\n            \t{\r\n            \t    alt39 = 1;\r\n            \t}\r\n            \tswitch (alt39) \r\n            \t{\r\n            \t    case 1 :\r\n            \t        // HqlSqlWalker.g:253:108: ^( (with= WITH ) ( . )* )\r\n            \t        {\r\n            \t        \t_last = (IASTNode)input.LT(1);\r\n            \t        \t{\r\n            \t        \tIASTNode _save_last_2 = _last;\r\n            \t        \tIASTNode _first_2 = null;\r\n            \t        \tIASTNode root_2 = (IASTNode)adaptor.GetNilNode();// HqlSqlWalker.g:253:110: (with= WITH )\r\n            \t        \t// HqlSqlWalker.g:253:111: with= WITH\r\n            \t        \t{\r\n            \t        \t\t_last = (IASTNode)input.LT(1);\r\n            \t        \t\twith=(IASTNode)Match(input,WITH,FOLLOW_WITH_in_joinElement1258); \r\n            \t        \t\t\twith_tree = (IASTNode)adaptor.DupNode(with);\r\n\r\n            \t        \t\t\tadaptor.AddChild(root_2, with_tree);\r\n\r\n\r\n            \t        \t}\r\n\r\n\r\n\r\n            \t        \tif ( input.LA(1) == Token.DOWN )\r\n            \t        \t{\r\n            \t        \t    Match(input, Token.DOWN, null); \r\n            \t        \t    // HqlSqlWalker.g:253:122: ( . )*\r\n            \t        \t    do \r\n            \t        \t    {\r\n            \t        \t        int alt38 = 2;\r\n            \t        \t        int LA38_0 = input.LA(1);\r\n\r\n            \t        \t        if ( ((LA38_0 >= ALL && LA38_0 <= BOGUS)) )\r\n            \t        \t        {\r\n            \t        \t            alt38 = 1;\r\n            \t        \t        }\r\n            \t        \t        else if ( (LA38_0 == UP) )\r\n            \t        \t        {\r\n            \t        \t            alt38 = 2;\r\n            \t        \t        }\r\n\r\n\r\n            \t        \t        switch (alt38) \r\n            \t        \t    \t{\r\n            \t        \t    \t\tcase 1 :\r\n            \t        \t    \t\t    // HqlSqlWalker.g:253:122: .\r\n            \t        \t    \t\t    {\r\n            \t        \t    \t\t    \t_last = (IASTNode)input.LT(1);\r\n            \t        \t    \t\t    \twildcard71 = (IASTNode)input.LT(1);\r\n            \t        \t    \t\t    \tMatchAny(input); \r\n            \t        \t    \t\t    \twildcard71_tree = (IASTNode)adaptor.DupTree(wildcard71);\r\n            \t        \t    \t\t    \tadaptor.AddChild(root_2, wildcard71_tree);\r\n\r\n\r\n            \t        \t    \t\t    }\r\n            \t        \t    \t\t    break;\r\n\r\n            \t        \t    \t\tdefault:\r\n            \t        \t    \t\t    goto loop38;\r\n            \t        \t        }\r\n            \t        \t    } while (true);\r\n\r\n            \t        \t    loop38:\r\n            \t        \t    \t;\t// Stops C# compiler whining that label 'loop38' has no statements\r\n\r\n\r\n            \t        \t    Match(input, Token.UP, null); \r\n            \t        \t}adaptor.AddChild(root_1, root_2);_last = _save_last_2;\r\n            \t        \t}\r\n\r\n\r\n            \t        }\r\n            \t        break;\r\n\r\n            \t}\r\n\r\n\r\n            \tMatch(input, Token.UP, null); adaptor.AddChild(root_0, root_1);_last = _save_last_1;\r\n            \t}\r\n\r\n\r\n            \t\t\tCreateFromJoinElement(((pRef != null) ? ((IASTNode)pRef.Tree) : null),a,((j != null) ? j.j : default(int)),f, pf, with);\r\n            \t\t\tSetImpliedJoinType(INNER);\t// Reset the implied join type.\r\n            \t\t\r\n\r\n            }\r\n\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 16,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlSqlWalker.cs",
      "SourceLine": 4196
    },
    {
      "TypeIdentifier": "HqlSqlWalker",
      "MethodIdentifier": "joinType",
      "SourcesSample": "public HqlSqlWalker.joinType_return joinType() // throws RecognitionException [1]\r\n    {   \r\n        HqlSqlWalker.joinType_return retval = new HqlSqlWalker.joinType_return();\r\n        retval.Start = input.LT(1);\r\n\r\n        IASTNode root_0 = null;\r\n\r\n        IASTNode _first_0 = null;\r\n        IASTNode _last = null;\r\n\r\n        IASTNode left = null;\r\n        IASTNode right = null;\r\n        IASTNode outer = null;\r\n        IASTNode FULL72 = null;\r\n        IASTNode INNER73 = null;\r\n\r\n        IASTNode left_tree=null;\r\n        IASTNode right_tree=null;\r\n        IASTNode outer_tree=null;\r\n        IASTNode FULL72_tree=null;\r\n        IASTNode INNER73_tree=null;\r\n\r\n\r\n           retval.j =  INNER;\r\n\r\n        try \r\n    \t{\r\n            // HqlSqlWalker.g:266:2: ( ( (left= LEFT | right= RIGHT ) (outer= OUTER )? ) | FULL | INNER )\r\n            int alt42 = 3;\r\n            switch ( input.LA(1) ) \r\n            {\r\n            case LEFT:\r\n            case RIGHT:\r\n            \t{\r\n                alt42 = 1;\r\n                }\r\n                break;\r\n            case FULL:\r\n            \t{\r\n                alt42 = 2;\r\n                }\r\n                break;\r\n            case INNER:\r\n            \t{\r\n                alt42 = 3;\r\n                }\r\n                break;\r\n            \tdefault:\r\n            \t    NoViableAltException nvae_d42s0 =\r\n            \t        new NoViableAltException(\"\", 42, 0, input);\r\n\r\n            \t    throw nvae_d42s0;\r\n            }\r\n\r\n            switch (alt42) \r\n            {\r\n                case 1 :\r\n                    // HqlSqlWalker.g:266:4: ( (left= LEFT | right= RIGHT ) (outer= OUTER )? )\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \t// HqlSqlWalker.g:266:4: ( (left= LEFT | right= RIGHT ) (outer= OUTER )? )\r\n                    \t// HqlSqlWalker.g:266:6: (left= LEFT | right= RIGHT ) (outer= OUTER )?\r\n                    \t{\r\n                    \t\t// HqlSqlWalker.g:266:6: (left= LEFT | right= RIGHT )\r\n                    \t\tint alt40 = 2;\r\n                    \t\tint LA40_0 = input.LA(1);\r\n\r\n                    \t\tif ( (LA40_0 == LEFT) )\r\n                    \t\t{\r\n                    \t\t    alt40 = 1;\r\n                    \t\t}\r\n                    \t\telse if ( (LA40_0 == RIGHT) )\r\n                    \t\t{\r\n                    \t\t    alt40 = 2;\r\n                    \t\t}\r\n                    \t\telse \r\n                    \t\t{\r\n                    \t\t    NoViableAltException nvae_d40s0 =\r\n                    \t\t        new NoViableAltException(\"\", 40, 0, input);\r\n\r\n                    \t\t    throw nvae_d40s0;\r\n                    \t\t}\r\n                    \t\tswitch (alt40) \r\n                    \t\t{\r\n                    \t\t    case 1 :\r\n                    \t\t        // HqlSqlWalker.g:266:7: left= LEFT\r\n                    \t\t        {\r\n                    \t\t        \t_last = (IASTNode)input.LT(1);\r\n                    \t\t        \tleft=(IASTNode)Match(input,LEFT,FOLLOW_LEFT_in_joinType1299); \r\n                    \t\t        \t\tleft_tree = (IASTNode)adaptor.DupNode(left);\r\n\r\n                    \t\t        \t\tadaptor.AddChild(root_0, left_tree);\r\n\r\n\r\n                    \t\t        }\r\n                    \t\t        break;\r\n                    \t\t    case 2 :\r\n                    \t\t        // HqlSqlWalker.g:266:19: right= RIGHT\r\n                    \t\t        {\r\n                    \t\t        \t_last = (IASTNode)input.LT(1);\r\n                    \t\t        \tright=(IASTNode)Match(input,RIGHT,FOLLOW_RIGHT_in_joinType1305); \r\n                    \t\t        \t\tright_tree = (IASTNode)adaptor.DupNode(right);\r\n\r\n                    \t\t        \t\tadaptor.AddChild(root_0, right_tree);\r\n\r\n\r\n                    \t\t        }\r\n                    \t\t        break;\r\n\r\n                    \t\t}\r\n\r\n                    \t\t// HqlSqlWalker.g:266:32: (outer= OUTER )?\r\n                    \t\tint alt41 = 2;\r\n                    \t\tint LA41_0 = input.LA(1);\r\n\r\n                    \t\tif ( (LA41_0 == OUTER) )\r\n                    \t\t{\r\n                    \t\t    alt41 = 1;\r\n                    \t\t}\r\n                    \t\tswitch (alt41) \r\n                    \t\t{\r\n                    \t\t    case 1 :\r\n                    \t\t        // HqlSqlWalker.g:266:33: outer= OUTER\r\n                    \t\t        {\r\n                    \t\t        \t_last = (IASTNode)input.LT(1);\r\n                    \t\t        \touter=(IASTNode)Match(input,OUTER,FOLLOW_OUTER_in_joinType1311); \r\n                    \t\t        \t\touter_tree = (IASTNode)adaptor.DupNode(outer);\r\n\r\n                    \t\t        \t\tadaptor.AddChild(root_0, outer_tree);\r\n\r\n\r\n                    \t\t        }\r\n                    \t\t        break;\r\n\r\n                    \t\t}\r\n\r\n\r\n                    \t\t\t\tif (left != null)       retval.j =  LEFT_OUTER;\r\n                    \t\t\t\telse if (right != null) retval.j =  RIGHT_OUTER;\r\n                    \t\t\t\telse if (outer != null) retval.j =  RIGHT_OUTER;\r\n                    \t\t\t\r\n\r\n                    \t}\r\n\r\n\r\n                    }\r\n                    break;\r\n                case 2 :\r\n                    // HqlSqlWalker.g:272:4: FULL\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \t_last = (IASTNode)input.LT(1);\r\n                    \tFULL72=(IASTNode)Match(input,FULL,FOLLOW_FULL_in_joinType1325); \r\n                    \t\tFULL72_tree = (IASTNode)adaptor.DupNode(FULL72);\r\n\r\n                    \t\tadaptor.AddChild(root_0, FULL72_tree);\r\n\r\n\r\n                    \t\t\tretval.j =  FULL;\r\n                    \t\t\r\n\r\n                    }\r\n                    break;\r\n                case 3 :\r\n                    // HqlSqlWalker.g:275:4: INNER\r\n                    {\r\n                    \troot_0 = (IASTNode)adaptor.GetNilNode();\r\n\r\n                    \t_last = (IASTNode)input.LT(1);\r\n                    \tINNER73=(IASTNode)Match(input,INNER,FOLLOW_INNER_in_joinType1332); \r\n                    \t\tINNER73_tree = (IASTNode)adaptor.DupNode(INNER73);\r\n\r\n                    \t\tadaptor.AddChild(root_0, INNER73_tree);\r\n\r\n\r\n                    \t\t\tretval.j =  INNER;\r\n                    \t\t\r\n\r\n                    }\r\n                    break;\r\n\r\n            }\r\n            \tretval.Tree = (IASTNode)adaptor.RulePostProcessing(root_0);\r\n\r\n        }\r\n        catch (RecognitionException re) \r\n    \t{\r\n            ReportError(re);\r\n            Recover(input,re);\r\n        }\r\n        finally \r\n    \t{\r\n        }\r\n        return retval;\r\n    }",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Generated\\HqlSqlWalker.cs",
      "SourceLine": 4474
    }
  ],
  [
    {
      "TypeIdentifier": "AbstractEntityPersister",
      "MethodIdentifier": "Delete",
      "SourcesSample": "public void Delete(object id, object version, int j, object obj, SqlCommandInfo sql, ISessionImplementor session,\r\n\t\t\t\t\t\t\t\t\t\t\t object[] loadedState)\r\n\t\t{\r\n\t\t\tif (IsInverseTable(j))\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// NH : Only use version if lock mode is Version\r\n\t\t\tbool useVersion = j == 0 && IsVersioned && Versioning.OptimisticLock.Version == entityMetamodel.OptimisticLockMode;\r\n\r\n\t\t\t//bool callable = IsDeleteCallable(j);\r\n\t\t\tIExpectation expectation = Expectations.AppropriateExpectation(deleteResultCheckStyles[j]);\r\n\t\t\tbool useBatch = j == 0 && expectation.CanBeBatched && IsBatchable;\r\n\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t{\r\n\t\t\t\tlog.Debug(\"Deleting entity: \" + MessageHelper.InfoString(this, id, Factory));\r\n\t\t\t\tif (useVersion)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"Version: \" + version);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (IsTableCascadeDeleteEnabled(j))\r\n\t\t\t{\r\n\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"delete handled by foreign key constraint: \" + GetTableName(j));\r\n\t\t\t\t}\r\n\t\t\t\treturn; //EARLY EXIT!\r\n\t\t\t}\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tint index = 0;\r\n\t\t\t\tIDbCommand statement;\r\n\t\t\t\tif (useBatch)\r\n\t\t\t\t{\r\n\t\t\t\t\tstatement = session.Batcher.PrepareBatchCommand(sql.CommandType, sql.Text, sql.ParameterTypes);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tstatement = session.Batcher.PrepareCommand(sql.CommandType, sql.Text, sql.ParameterTypes);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\t//index += expectation.Prepare(statement, factory.ConnectionProvider.Driver);\r\n\r\n\t\t\t\t\t// Do the key. The key is immutable so we can use the _current_ object state - not necessarily\r\n\t\t\t\t\t// the state at the time the delete was issued\r\n\t\t\t\t\tIdentifierType.NullSafeSet(statement, id, index, session);\r\n\t\t\t\t\tindex += IdentifierColumnSpan;\r\n\r\n\t\t\t\t\t// We should use the _current_ object state (ie. after any updates that occurred during flush)\r\n\t\t\t\t\tif (useVersion)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tVersionType.NullSafeSet(statement, version, index, session);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (entityMetamodel.OptimisticLockMode > Versioning.OptimisticLock.Version && loadedState != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbool[] versionability = PropertyVersionability;\r\n\t\t\t\t\t\tIType[] types = PropertyTypes;\r\n\t\t\t\t\t\tfor (int i = 0; i < entityMetamodel.PropertySpan; i++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (IsPropertyOfTable(i, j) && versionability[i])\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// this property belongs to the table and it is not specifically\r\n\t\t\t\t\t\t\t\t// excluded from optimistic locking by optimistic-lock=\"false\"\r\n\t\t\t\t\t\t\t\tbool[] settable = types[i].ToColumnNullness(loadedState[i], Factory);\r\n\r\n\t\t\t\t\t\t\t\ttypes[i].NullSafeSet(statement, loadedState[i], index, settable, session);\r\n\t\t\t\t\t\t\t\tindex += ArrayHelper.CountTrue(settable);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.Batcher.AddToBatch(expectation);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCheck(session.Batcher.ExecuteNonQuery(statement), id, j, expectation, statement);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch (Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.Batcher.AbortBatch(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrow;\r\n\t\t\t\t}\r\n\t\t\t\tfinally\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!useBatch)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.Batcher.CloseCommand(statement, null);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch (DbException sqle)\r\n\t\t\t{\r\n\t\t\t\tvar exceptionContext = new AdoExceptionContextInfo\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tSqlException = sqle,\r\n\t\t\t\t\t\t\t\t\t\t\tMessage = \"could not delete: \" + MessageHelper.InfoString(this, id, Factory),\r\n\t\t\t\t\t\t\t\t\t\t\tSql = sql.Text.ToString(),\r\n\t\t\t\t\t\t\t\t\t\t\tEntityName = EntityName,\r\n\t\t\t\t\t\t\t\t\t\t\tEntityId = id\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\tthrow ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, exceptionContext);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 14,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Persister\\Entity\\AbstractEntityPersister.cs",
      "SourceLine": 2823
    },
    {
      "TypeIdentifier": "AbstractEntityPersister",
      "MethodIdentifier": "GenerateUpdateString",
      "SourcesSample": "protected internal SqlCommandInfo GenerateUpdateString(bool[] includeProperty, int j, object[] oldFields, bool useRowId)\r\n\t\t{\r\n\t\t\tSqlUpdateBuilder updateBuilder = new SqlUpdateBuilder(Factory.Dialect, Factory)\r\n\t\t\t\t.SetTableName(GetTableName(j));\r\n\r\n\t\t\t// select the correct row by either pk or rowid\r\n\t\t\tif (useRowId)\r\n\t\t\t\tupdateBuilder.SetIdentityColumn(new string[] { rowIdName }, NHibernateUtil.Int32); //TODO: eventually, rowIdName[j]\r\n\t\t\telse\r\n\t\t\t\tupdateBuilder.SetIdentityColumn(GetKeyColumns(j), IdentifierType);\r\n\r\n\t\t\tbool hasColumns = false;\r\n\t\t\tfor (int i = 0; i < entityMetamodel.PropertySpan; i++)\r\n\t\t\t{\r\n\t\t\t\tif (includeProperty[i] && IsPropertyOfTable(i, j))\r\n\t\t\t\t{\r\n\t\t\t\t\t// this is a property of the table, which we are updating\r\n\t\t\t\t\tupdateBuilder.AddColumns(GetPropertyColumnNames(i), propertyColumnUpdateable[i], PropertyTypes[i]);\r\n\t\t\t\t\thasColumns = hasColumns || GetPropertyColumnSpan(i) > 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (j == 0 && IsVersioned && entityMetamodel.OptimisticLockMode == Versioning.OptimisticLock.Version)\r\n\t\t\t{\r\n\t\t\t\t// this is the root (versioned) table, and we are using version-based\r\n\t\t\t\t// optimistic locking;  if we are not updating the version, also don't\r\n\t\t\t\t// check it (unless this is a \"generated\" version column)!\r\n\t\t\t\tif (CheckVersion(includeProperty))\r\n\t\t\t\t{\r\n\t\t\t\t\tupdateBuilder.SetVersionColumn(new string[] { VersionColumnName }, VersionType);\r\n\t\t\t\t\thasColumns = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (entityMetamodel.OptimisticLockMode > Versioning.OptimisticLock.Version && oldFields != null)\r\n\t\t\t{\r\n\t\t\t\t// we are using \"all\" or \"dirty\" property-based optimistic locking\r\n\t\t\t\tbool[] includeInWhere =\r\n\t\t\t\t\tOptimisticLockMode == Versioning.OptimisticLock.All\r\n\t\t\t\t\t\t? PropertyUpdateability\r\n\t\t\t\t\t\t: includeProperty; //optimistic-lock=\"dirty\", include all properties we are updating this time\r\n\r\n\t\t\t\tbool[] versionability = PropertyVersionability;\r\n\t\t\t\tIType[] types = PropertyTypes;\r\n\r\n\t\t\t\tfor (int i = 0; i < entityMetamodel.PropertySpan; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tbool include = includeInWhere[i] && IsPropertyOfTable(i, j) && versionability[i];\r\n\t\t\t\t\tif (include)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// this property belongs to the table, and it is not specifically\r\n\t\t\t\t\t\t// excluded from optimistic locking by optimistic-lock=\"false\"\r\n\t\t\t\t\t\tstring[] _propertyColumnNames = GetPropertyColumnNames(i);\r\n\t\t\t\t\t\tbool[] propertyNullness = types[i].ToColumnNullness(oldFields[i], Factory);\r\n\t\t\t\t\t\tSqlType[] sqlt = types[i].SqlTypes(Factory);\r\n\t\t\t\t\t\tfor (int k = 0; k < propertyNullness.Length; k++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (propertyNullness[k])\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tupdateBuilder.AddWhereFragment(_propertyColumnNames[k], sqlt[k], \" = \");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tupdateBuilder.AddWhereFragment(_propertyColumnNames[k] + \" is null\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (Factory.Settings.IsCommentsEnabled)\r\n\t\t\t{\r\n\t\t\t\tupdateBuilder.SetComment(\"update \" + EntityName);\r\n\t\t\t}\r\n\r\n\t\t\treturn hasColumns ? updateBuilder.ToSqlCommandInfo() : null;\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Persister\\Entity\\AbstractEntityPersister.cs",
      "SourceLine": 2195
    },
    {
      "TypeIdentifier": "AbstractEntityPersister",
      "MethodIdentifier": "Hydrate",
      "SourcesSample": "public object[] Hydrate(IDataReader rs, object id, object obj, ILoadable rootLoadable,\r\n\t\t\tstring[][] suffixedPropertyColumns, bool allProperties, ISessionImplementor session)\r\n\t\t{\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t{\r\n\t\t\t\tlog.Debug(\"Hydrating entity: \" + MessageHelper.InfoString(this, id, Factory));\r\n\t\t\t}\r\n\r\n\t\t\tAbstractEntityPersister rootPersister = (AbstractEntityPersister)rootLoadable;\r\n\r\n\t\t\tbool hasDeferred = rootPersister.HasSequentialSelect;\r\n\t\t\tIDbCommand sequentialSelect = null;\r\n\t\t\tIDataReader sequentialResultSet = null;\r\n\t\t\tbool sequentialSelectEmpty = false;\r\n\t\t\tusing (new SessionIdLoggingContext(session.SessionId)) \r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tif (hasDeferred)\r\n\t\t\t\t{\r\n\t\t\t\t\tSqlString sql = rootPersister.GetSequentialSelect(EntityName);\r\n\t\t\t\t\tif (sql != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//TODO: I am not so sure about the exception handling in this bit!\r\n\t\t\t\t\t\tsequentialSelect = session.Batcher.PrepareCommand(CommandType.Text, sql, IdentifierType.SqlTypes(factory));\r\n\t\t\t\t\t\trootPersister.IdentifierType.NullSafeSet(sequentialSelect, id, 0, session);\r\n\t\t\t\t\t\tsequentialResultSet = session.Batcher.ExecuteReader(sequentialSelect);\r\n\t\t\t\t\t\tif (!sequentialResultSet.Read())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// TODO: Deal with the \"optional\" attribute in the <join> mapping;\r\n\t\t\t\t\t\t\t// this code assumes that optional defaults to \"true\" because it\r\n\t\t\t\t\t\t\t// doesn't actually seem to work in the fetch=\"join\" code\r\n\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t// Note that actual proper handling of optional-ality here is actually\r\n\t\t\t\t\t\t\t// more involved than this patch assumes.  Remember that we might have\r\n\t\t\t\t\t\t\t// multiple <join/> mappings associated with a single entity.  Really\r\n\t\t\t\t\t\t\t// a couple of things need to happen to properly handle optional here:\r\n\t\t\t\t\t\t\t//  1) First and foremost, when handling multiple <join/>s, we really\r\n\t\t\t\t\t\t\t//      should be using the entity root table as the driving table;\r\n\t\t\t\t\t\t\t//      another option here would be to choose some non-optional joined\r\n\t\t\t\t\t\t\t//      table to use as the driving table.  In all likelihood, just using\r\n\t\t\t\t\t\t\t//      the root table is much simplier\r\n\t\t\t\t\t\t\t//  2) Need to add the FK columns corresponding to each joined table\r\n\t\t\t\t\t\t\t//      to the generated select list; these would then be used when\r\n\t\t\t\t\t\t\t//      iterating the result set to determine whether all non-optional\r\n\t\t\t\t\t\t\t//      data is present\r\n\t\t\t\t\t\t\t// My initial thoughts on the best way to deal with this would be\r\n\t\t\t\t\t\t\t// to introduce a new SequentialSelect abstraction that actually gets\r\n\t\t\t\t\t\t\t// generated in the persisters (ok, SingleTable...) and utilized here.\r\n\t\t\t\t\t\t\t// It would encapsulated all this required optional-ality checking...\r\n\t\t\t\t\t\t\tsequentialSelectEmpty = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstring[] propNames = PropertyNames;\r\n\t\t\t\tIType[] types = PropertyTypes;\r\n\t\t\t\tobject[] values = new object[types.Length];\r\n\t\t\t\tbool[] laziness = PropertyLaziness;\r\n\t\t\t\tstring[] propSubclassNames = SubclassPropertySubclassNameClosure;\r\n\r\n\t\t\t\tfor (int i = 0; i < types.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!propertySelectable[i])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalues[i] = BackrefPropertyAccessor.Unknown;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (allProperties || !laziness[i])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//decide which ResultSet to get the property value from:\r\n\t\t\t\t\t\tbool propertyIsDeferred = hasDeferred\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& rootPersister.IsSubclassPropertyDeferred(propNames[i], propSubclassNames[i]);\r\n\t\t\t\t\t\tif (propertyIsDeferred && sequentialSelectEmpty)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvalues[i] = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tIDataReader propertyResultSet = propertyIsDeferred ? sequentialResultSet : rs;\r\n\t\t\t\t\t\t\tstring[] cols = propertyIsDeferred ? propertyColumnAliases[i] : suffixedPropertyColumns[i];\r\n\t\t\t\t\t\t\tvalues[i] = types[i].Hydrate(propertyResultSet, cols, session, obj);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalues[i] = LazyPropertyInitializer.UnfetchedProperty;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (sequentialResultSet != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tsequentialResultSet.Close();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn values;\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\tif (sequentialSelect != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tsession.Batcher.CloseCommand(sequentialSelect, sequentialResultSet);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Persister\\Entity\\AbstractEntityPersister.cs",
      "SourceLine": 2436
    },
    {
      "TypeIdentifier": "AbstractEntityPersister",
      "MethodIdentifier": "Update",
      "SourcesSample": "protected bool Update(object id, object[] fields, object[] oldFields, object rowId, bool[] includeProperty, int j,\r\n\t\t\tobject oldVersion, object obj, SqlCommandInfo sql, ISessionImplementor session)\r\n\t\t{\r\n\t\t\tbool useVersion = j == 0 && IsVersioned;\r\n\t\t\tIExpectation expectation = Expectations.AppropriateExpectation(updateResultCheckStyles[j]);\r\n\t\t\t//bool callable = IsUpdateCallable(j);\r\n\t\t\tbool useBatch = j == 0 && expectation.CanBeBatched && IsBatchable; //note: updates to joined tables can't be batched...\r\n\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t{\r\n\t\t\t\tlog.Debug(\"Updating entity: \" + MessageHelper.InfoString(this, id, Factory));\r\n\t\t\t\tif (useVersion)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"Existing version: \" + oldVersion + \" -> New Version: \" + fields[VersionProperty]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tint index = 0;\r\n\t\t\t\tIDbCommand statement = useBatch\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? session.Batcher.PrepareBatchCommand(sql.CommandType, sql.Text, sql.ParameterTypes)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: session.Batcher.PrepareCommand(sql.CommandType, sql.Text, sql.ParameterTypes);\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\t//index += expectation.Prepare(statement, factory.ConnectionProvider.Driver);\r\n\r\n\t\t\t\t\t//Now write the values of fields onto the prepared statement\r\n\t\t\t\t\tindex = Dehydrate(id, fields, rowId, includeProperty, propertyColumnUpdateable, j, statement, session, index);\r\n\r\n\t\t\t\t\t// Write any appropriate versioning conditional parameters\r\n\t\t\t\t\tif (useVersion && Versioning.OptimisticLock.Version == entityMetamodel.OptimisticLockMode)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (CheckVersion(includeProperty))\r\n\t\t\t\t\t\t\tVersionType.NullSafeSet(statement, oldVersion, index, session);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (entityMetamodel.OptimisticLockMode > Versioning.OptimisticLock.Version && oldFields != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbool[] versionability = PropertyVersionability;\r\n\t\t\t\t\t\tbool[] includeOldField = OptimisticLockMode == Versioning.OptimisticLock.All\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? PropertyUpdateability\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: includeProperty;\r\n\t\t\t\t\t\tIType[] types = PropertyTypes;\r\n\r\n\t\t\t\t\t\tfor (int i = 0; i < entityMetamodel.PropertySpan; i++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbool include = includeOldField[i] &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t IsPropertyOfTable(i, j) &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t versionability[i];\r\n\t\t\t\t\t\t\tif (include)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tbool[] settable = types[i].ToColumnNullness(oldFields[i], Factory);\r\n\t\t\t\t\t\t\t\ttypes[i].NullSafeSet(statement, oldFields[i], index, settable, session);\r\n\t\t\t\t\t\t\t\tindex += ArrayHelper.CountTrue(settable);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.Batcher.AddToBatch(expectation);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn Check(session.Batcher.ExecuteNonQuery(statement), id, j, expectation, statement);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch (StaleStateException e)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.Batcher.AbortBatch(e);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthrow new StaleObjectStateException(EntityName, id);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.Batcher.AbortBatch(e);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthrow;\r\n\t\t\t\t}\r\n\t\t\t\tfinally\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!useBatch)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.Batcher.CloseCommand(statement, null);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch (DbException sqle)\r\n\t\t\t{\r\n\t\t\t\tvar exceptionContext = new AdoExceptionContextInfo\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\tSqlException = sqle,\r\n\t\t\t\t\t\t\t\t\t\t\tMessage = \"could not update: \" + MessageHelper.InfoString(this, id, Factory),\r\n\t\t\t\t\t\t\t\t\t\t\tSql = sql.Text.ToString(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tEntityName = EntityName,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tEntityId = id\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\tthrow ADOExceptionHelper.Convert(Factory.SQLExceptionConverter, exceptionContext);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Persister\\Entity\\AbstractEntityPersister.cs",
      "SourceLine": 2712
    },
    {
      "TypeIdentifier": "AbstractEntityPersister",
      "MethodIdentifier": "LogStaticSQL",
      "SourcesSample": "protected void LogStaticSQL()\r\n\t\t{\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t{\r\n\t\t\t\tlog.Debug(\"Static SQL for entity: \" + EntityName);\r\n\t\t\t\tif (sqlLazySelectString != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\" Lazy select: \" + sqlLazySelectString);\r\n\t\t\t\t}\r\n\t\t\t\tif (sqlVersionSelectString != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\" Version select: \" + sqlVersionSelectString);\r\n\t\t\t\t}\r\n\t\t\t\tif (sqlSnapshotSelectString != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\" Snapshot select: \" + sqlSnapshotSelectString);\r\n\t\t\t\t}\r\n\t\t\t\tfor (int j = 0; j < TableSpan; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\" Insert \" + j + \": \" + SqlInsertStrings[j]);\r\n\t\t\t\t\tlog.Debug(\" Update \" + j + \": \" + SqlUpdateStrings[j]);\r\n\t\t\t\t\tlog.Debug(\" Delete \" + j + \": \" + SqlDeleteStrings[j]);\r\n\t\t\t\t}\r\n\t\t\t\tif (sqlIdentityInsertString != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\" Identity insert: \" + sqlIdentityInsertString);\r\n\t\t\t\t}\r\n\t\t\t\tif (sqlUpdateByRowIdString != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\" Update by row id (all fields): \" + sqlUpdateByRowIdString);\r\n\t\t\t\t}\r\n\t\t\t\tif (sqlLazyUpdateByRowIdString != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\" Update by row id (non-lazy fields): \" + sqlLazyUpdateByRowIdString);\r\n\t\t\t\t}\r\n\t\t\t\tif (sqlInsertGeneratedValuesSelectString != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"Insert-generated property select: \" + sqlInsertGeneratedValuesSelectString);\r\n\t\t\t\t}\r\n\t\t\t\tif (sqlUpdateGeneratedValuesSelectString != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"Update-generated property select: \" + sqlUpdateGeneratedValuesSelectString);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Persister\\Entity\\AbstractEntityPersister.cs",
      "SourceLine": 3152
    }
  ],
  [
    {
      "TypeIdentifier": "Configuration",
      "MethodIdentifier": "GenerateDropSchemaScript",
      "SourcesSample": "public string[] GenerateDropSchemaScript(Dialect.Dialect dialect)\r\n\t\t{\r\n\t\t\tSecondPassCompile();\r\n\r\n\t\t\tstring defaultCatalog = PropertiesHelper.GetString(Environment.DefaultCatalog, properties, null);\r\n\t\t\tstring defaultSchema = PropertiesHelper.GetString(Environment.DefaultSchema, properties, null);\r\n\r\n\t\t\tvar script = new List<string>();\r\n\r\n\t\t\tif (!dialect.SupportsForeignKeyConstraintInAlterTable && !string.IsNullOrEmpty(dialect.DisableForeignKeyConstraintsString))\r\n\t\t\t\tscript.Add(dialect.DisableForeignKeyConstraintsString);\r\n\r\n\t\t\t// drop them in reverse order in case db needs it done that way...););\r\n\t\t\tfor (int i = auxiliaryDatabaseObjects.Count - 1; i >= 0; i--)\r\n\t\t\t{\r\n\t\t\t\tIAuxiliaryDatabaseObject auxDbObj = auxiliaryDatabaseObjects[i];\r\n\t\t\t\tif (auxDbObj.AppliesToDialect(dialect))\r\n\t\t\t\t{\r\n\t\t\t\t\tscript.Add(auxDbObj.SqlDropString(dialect, defaultCatalog, defaultSchema));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (dialect.DropConstraints)\r\n\t\t\t{\r\n\t\t\t\tforeach (var table in TableMappings)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (table.IsPhysicalTable && IncludeAction(table.SchemaActions, SchemaAction.Drop))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (var fk in table.ForeignKeyIterator)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (fk.HasPhysicalConstraint && IncludeAction(fk.ReferencedTable.SchemaActions, SchemaAction.Drop))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tscript.Add(fk.SqlDropString(dialect, defaultCatalog, defaultSchema));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tforeach (var table in TableMappings)\r\n\t\t\t{\r\n\t\t\t\tif (table.IsPhysicalTable && IncludeAction(table.SchemaActions, SchemaAction.Drop))\r\n\t\t\t\t{\r\n\t\t\t\t\tscript.Add(table.SqlDropString(dialect, defaultCatalog, defaultSchema));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tIEnumerable<IPersistentIdentifierGenerator> pIDg = IterateGenerators(dialect);\r\n\t\t\tforeach (var idGen in pIDg)\r\n\t\t\t{\r\n\t\t\t\tstring[] lines = idGen.SqlDropString(dialect);\r\n\t\t\t\tif (lines != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (var line in lines)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tscript.Add(line);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!dialect.SupportsForeignKeyConstraintInAlterTable && !string.IsNullOrEmpty(dialect.EnableForeignKeyConstraintsString))\r\n\t\t\t\tscript.Add(dialect.EnableForeignKeyConstraintsString);\r\n\r\n\t\t\treturn script.ToArray();\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\Configuration.cs",
      "SourceLine": 816
    },
    {
      "TypeIdentifier": "Configuration",
      "MethodIdentifier": "GenerateSchemaCreationScript",
      "SourcesSample": "public string[] GenerateSchemaCreationScript(Dialect.Dialect dialect)\r\n\t\t{\r\n\t\t\tSecondPassCompile();\r\n\r\n\t\t\tstring defaultCatalog = PropertiesHelper.GetString(Environment.DefaultCatalog, properties, null);\r\n\t\t\tstring defaultSchema = PropertiesHelper.GetString(Environment.DefaultSchema, properties, null);\r\n\r\n\t\t\tvar script = new List<string>();\r\n\r\n\t\t\tforeach (var table in TableMappings)\r\n\t\t\t{\r\n\t\t\t\tif (table.IsPhysicalTable && IncludeAction(table.SchemaActions, SchemaAction.Export))\r\n\t\t\t\t{\r\n\t\t\t\t\tscript.Add(table.SqlCreateString(dialect, mapping, defaultCatalog, defaultSchema));\r\n\t\t\t\t\tscript.AddRange(table.SqlCommentStrings(dialect, defaultCatalog, defaultSchema));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tforeach (var table in TableMappings)\r\n\t\t\t{\r\n\t\t\t\tif (table.IsPhysicalTable && IncludeAction(table.SchemaActions, SchemaAction.Export))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!dialect.SupportsUniqueConstraintInCreateAlterTable)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (var uk in table.UniqueKeyIterator)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tstring constraintString = uk.SqlCreateString(dialect, mapping, defaultCatalog, defaultSchema);\r\n\t\t\t\t\t\t\tif (constraintString != null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tscript.Add(constraintString);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tforeach (var index in table.IndexIterator)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tscript.Add(index.SqlCreateString(dialect, mapping, defaultCatalog, defaultSchema));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (dialect.SupportsForeignKeyConstraintInAlterTable)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (var fk in table.ForeignKeyIterator)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (fk.HasPhysicalConstraint && IncludeAction(fk.ReferencedTable.SchemaActions, SchemaAction.Export))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tscript.Add(fk.SqlCreateString(dialect, mapping, defaultCatalog, defaultSchema));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tIEnumerable<IPersistentIdentifierGenerator> pIDg = IterateGenerators(dialect);\r\n\t\t\tforeach (var idGen in pIDg)\r\n\t\t\t{\r\n\t\t\t\tscript.AddRange(idGen.SqlCreateStrings(dialect));\r\n\t\t\t}\r\n\r\n\t\t\tforeach (var auxDbObj in auxiliaryDatabaseObjects)\r\n\t\t\t{\r\n\t\t\t\tif (auxDbObj.AppliesToDialect(dialect))\r\n\t\t\t\t{\r\n\t\t\t\t\tscript.Add(auxDbObj.SqlCreateString(dialect, mapping, defaultCatalog, defaultSchema));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn script.ToArray();\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\Configuration.cs",
      "SourceLine": 891
    },
    {
      "TypeIdentifier": "Configuration",
      "MethodIdentifier": "GenerateSchemaUpdateScript",
      "SourcesSample": "public string[] GenerateSchemaUpdateScript(Dialect.Dialect dialect, DatabaseMetadata databaseMetadata)\r\n\t\t{\r\n\t\t\tSecondPassCompile();\r\n\r\n\t\t\tstring defaultCatalog = PropertiesHelper.GetString(Environment.DefaultCatalog, properties, null);\r\n\t\t\tstring defaultSchema = PropertiesHelper.GetString(Environment.DefaultSchema, properties, null);\r\n\r\n\t\t\tvar script = new List<string>(50);\r\n\t\t\tforeach (var table in TableMappings)\r\n\t\t\t{\r\n\t\t\t\tif (table.IsPhysicalTable && IncludeAction(table.SchemaActions, SchemaAction.Update))\r\n\t\t\t\t{\r\n\t\t\t\t\tITableMetadata tableInfo = databaseMetadata.GetTableMetadata(table.Name, table.Schema ?? defaultSchema,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t table.Catalog ?? defaultCatalog, table.IsQuoted);\r\n\t\t\t\t\tif (tableInfo == null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tscript.Add(table.SqlCreateString(dialect, mapping, defaultCatalog, defaultSchema));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring[] alterDDL = table.SqlAlterStrings(dialect, mapping, tableInfo, defaultCatalog, defaultSchema);\r\n\t\t\t\t\t\tscript.AddRange(alterDDL);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tstring[] comments = table.SqlCommentStrings(dialect, defaultCatalog, defaultSchema);\r\n\t\t\t\t\tscript.AddRange(comments);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tforeach (var table in TableMappings)\r\n\t\t\t{\r\n\t\t\t\tif (table.IsPhysicalTable && IncludeAction(table.SchemaActions, SchemaAction.Update))\r\n\t\t\t\t{\r\n\t\t\t\t\tITableMetadata tableInfo = databaseMetadata.GetTableMetadata(table.Name, table.Schema, table.Catalog,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t table.IsQuoted);\r\n\r\n\t\t\t\t\tif (dialect.SupportsForeignKeyConstraintInAlterTable)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tforeach (var fk in table.ForeignKeyIterator)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (fk.HasPhysicalConstraint && IncludeAction(fk.ReferencedTable.SchemaActions, SchemaAction.Update))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tbool create = tableInfo == null\r\n\t\t\t\t\t\t\t\t\t\t\t  ||\r\n\t\t\t\t\t\t\t\t\t\t\t  (tableInfo.GetForeignKeyMetadata(fk.Name) == null\r\n\t\t\t\t\t\t\t\t\t\t\t   && (!(dialect is MySQLDialect) || tableInfo.GetIndexMetadata(fk.Name) == null));\r\n\t\t\t\t\t\t\t\tif (create)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tscript.Add(fk.SqlCreateString(dialect, mapping, defaultCatalog, defaultSchema));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tforeach (var index in table.IndexIterator)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (tableInfo == null || tableInfo.GetIndexMetadata(index.Name) == null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tscript.Add(index.SqlCreateString(dialect, mapping, defaultCatalog, defaultSchema));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tforeach (var generator in IterateGenerators(dialect))\r\n\t\t\t{\r\n\t\t\t\tstring key = generator.GeneratorKey();\r\n\t\t\t\tif (!databaseMetadata.IsSequence(key) && !databaseMetadata.IsTable(key))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring[] lines = generator.SqlCreateStrings(dialect);\r\n\t\t\t\t\tfor (int i = 0; i < lines.Length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tscript.Add(lines[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn script.ToArray();\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\Configuration.cs",
      "SourceLine": 2323
    },
    {
      "TypeIdentifier": "Configuration",
      "MethodIdentifier": "DoConfigure",
      "SourcesSample": "protected Configuration DoConfigure(ISessionFactoryConfiguration factoryConfiguration)\r\n\t\t{\r\n\t\t\tif (!string.IsNullOrEmpty(factoryConfiguration.Name))\r\n\t\t\t{\r\n\t\t\t\tproperties[Environment.SessionFactoryName] = factoryConfiguration.Name;\r\n\t\t\t}\r\n\r\n\t\t\tAddProperties(factoryConfiguration);\r\n\r\n\t\t\t// Load mappings\r\n\t\t\tforeach (var mc in factoryConfiguration.Mappings)\r\n\t\t\t{\r\n\t\t\t\tif (mc.IsEmpty())\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new HibernateConfigException(\"<mapping> element in configuration specifies no attributes\");\r\n\t\t\t\t}\r\n\t\t\t\tif (!string.IsNullOrEmpty(mc.Resource) && !string.IsNullOrEmpty(mc.Assembly))\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(factoryConfiguration.Name + \"<-\" + mc.Resource + \" in \" + mc.Assembly);\r\n\t\t\t\t\tAddResource(mc.Resource, Assembly.Load(mc.Assembly));\r\n\t\t\t\t}\r\n\t\t\t\telse if (!string.IsNullOrEmpty(mc.Assembly))\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(factoryConfiguration.Name + \"<-\" + mc.Assembly);\r\n\t\t\t\t\tAddAssembly(mc.Assembly);\r\n\t\t\t\t}\r\n\t\t\t\telse if (!string.IsNullOrEmpty(mc.File))\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(factoryConfiguration.Name + \"<-\" + mc.File);\r\n\t\t\t\t\tAddFile(mc.File);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Load class-cache\r\n\t\t\tforeach (var ccc in factoryConfiguration.ClassesCache)\r\n\t\t\t{\r\n\t\t\t\tstring region = string.IsNullOrEmpty(ccc.Region) ? ccc.Class : ccc.Region;\r\n\t\t\t\tbool includeLazy = (ccc.Include != ClassCacheInclude.NonLazy);\r\n\t\t\t\tSetCacheConcurrencyStrategy(ccc.Class, EntityCacheUsageParser.ToString(ccc.Usage), region, includeLazy);\r\n\t\t\t}\r\n\r\n\t\t\t// Load collection-cache\r\n\t\t\tforeach (var ccc in factoryConfiguration.CollectionsCache)\r\n\t\t\t{\r\n\t\t\t\tstring role = ccc.Collection;\r\n\t\t\t\tNHibernate.Mapping.Collection collection = GetCollectionMapping(role);\r\n\t\t\t\tif (collection == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new HibernateConfigException(\r\n\t\t\t\t\t\t\"collection-cache Configuration: Cannot configure cache for unknown collection role \" + role);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstring region = string.IsNullOrEmpty(ccc.Region) ? role : ccc.Region;\r\n\t\t\t\tSetCollectionCacheConcurrencyStrategy(role, EntityCacheUsageParser.ToString(ccc.Usage), region);\r\n\t\t\t}\r\n\r\n\t\t\t// Events\r\n\t\t\tforeach (var ec in factoryConfiguration.Events)\r\n\t\t\t{\r\n\t\t\t\tvar listenerClasses = new string[ec.Listeners.Count];\r\n\t\t\t\tfor (int i = 0; i < ec.Listeners.Count; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tlistenerClasses[i] = ec.Listeners[i].Class;\r\n\t\t\t\t}\r\n\t\t\t\tlog.Debug(\"Event listeners: \" + ec.Type + \"=\" + StringHelper.ToString(listenerClasses));\r\n\t\t\t\tSetListeners(ec.Type, listenerClasses);\r\n\t\t\t}\r\n\t\t\t// Listeners\r\n\t\t\tforeach (var lc in factoryConfiguration.Listeners)\r\n\t\t\t{\r\n\t\t\t\tlog.Debug(\"Event listener: \" + lc.Type + \"=\" + lc.Class);\r\n\t\t\t\tSetListeners(lc.Type, new[] { lc.Class });\r\n\t\t\t}\r\n\r\n\t\t\tif (!string.IsNullOrEmpty(factoryConfiguration.Name))\r\n\t\t\t{\r\n\t\t\t\tlog.Info(\"Configured SessionFactory: \" + factoryConfiguration.Name);\r\n\t\t\t}\r\n\t\t\tlog.Debug(\"properties: \" + properties);\r\n\r\n\t\t\treturn this;\r\n\t\t}",
      "nStatementSyntax": 14,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\Configuration.cs",
      "SourceLine": 1553
    }
  ],
  [
    {
      "TypeIdentifier": "ABCProxyTest",
      "MethodIdentifier": "Subclassing",
      "SourcesSample": "[Test]\n\t\tpublic void Subclassing()\n\t\t{\n\t\t\tC1 c1;\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tc1 = new C1();\n\t\t\t\tD d = new D();\n\t\t\t\td.Amount = 213.34f;\n\t\t\t\tc1.Address = \"foo bar\";\n\t\t\t\tc1.Count = 23432;\n\t\t\t\tc1.Name = \"c1\";\n\t\t\t\tc1.D = d;\n\t\t\t\ts.Save(c1);\n\t\t\t\td.Id = c1.Id;\n\t\t\t\ts.Save(d);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\t// Test won't run after this line because of proxy initalization problems\n\t\t\t\tA c1a = (A) s.Load(typeof(A), c1.Id);\n\t\t\t\tAssert.IsFalse(NHibernateUtil.IsInitialized(c1a));\n\t\t\t\tAssert.IsTrue(c1a.Name.Equals(\"c1\"));\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tB c1b = (B) s.Load(typeof(B), c1.Id);\n\t\t\t\tAssert.IsTrue(\n\t\t\t\t\t(c1b.Count == 23432) &&\n\t\t\t\t\tc1b.Name.Equals(\"c1\")\n\t\t\t\t\t);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tc1 = (C1) s.Load(typeof(C1), c1.Id);\n\t\t\t\tAssert.IsTrue(\n\t\t\t\t\tc1.Address.Equals(\"foo bar\") &&\n\t\t\t\t\t(c1.Count == 23432) &&\n\t\t\t\t\tc1.Name.Equals(\"c1\") &&\n\t\t\t\t\tc1.D.Amount > 213.3f\n\t\t\t\t\t);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tA c1a = (A) s.Load(typeof(A), c1.Id);\n\t\t\t\tAssert.IsTrue(c1a.Name.Equals(\"c1\"));\n\t\t\t\tc1 = (C1) s.Load(typeof(C1), c1.Id);\n\t\t\t\tAssert.IsTrue(\n\t\t\t\t\tc1.Address.Equals(\"foo bar\") &&\n\t\t\t\t\t(c1.Count == 23432) &&\n\t\t\t\t\tc1.Name.Equals(\"c1\") &&\n\t\t\t\t\tc1.D.Amount > 213.3f\n\t\t\t\t\t);\n\t\t\t\tB c1b = (B) s.Load(typeof(B), c1.Id);\n\t\t\t\tAssert.IsTrue(\n\t\t\t\t\t(c1b.Count == 23432) &&\n\t\t\t\t\tc1b.Name.Equals(\"c1\")\n\t\t\t\t\t);\n\t\t\t\tAssert.IsTrue(c1a.Name.Equals(\"c1\"));\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tA c1a = (A) s.Load(typeof(A), c1.Id);\n\t\t\t\tAssert.IsTrue(c1a.Name.Equals(\"c1\"));\n\t\t\t\tc1 = (C1) s.Load(typeof(C1), c1.Id, LockMode.Upgrade);\n\t\t\t\tAssert.IsTrue(\n\t\t\t\t\tc1.Address.Equals(\"foo bar\") &&\n\t\t\t\t\t(c1.Count == 23432) &&\n\t\t\t\t\tc1.Name.Equals(\"c1\") &&\n\t\t\t\t\tc1.D.Amount > 213.3f\n\t\t\t\t\t);\n\t\t\t\tB c1b = (B) s.Load(typeof(B), c1.Id, LockMode.Upgrade);\n\t\t\t\tAssert.IsTrue(\n\t\t\t\t\t(c1b.Count == 23432) &&\n\t\t\t\t\tc1b.Name.Equals(\"c1\")\n\t\t\t\t\t);\n\t\t\t\tAssert.IsTrue(c1a.Name.Equals(\"c1\"));\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tA c1a = (A) s.Load(typeof(A), c1.Id);\n\t\t\t\tc1 = (C1) s.Load(typeof(C1), c1.Id);\n\t\t\t\tB c1b = (B) s.Load(typeof(B), c1.Id);\n\t\t\t\tAssert.IsTrue(c1a.Name.Equals(\"c1\"));\n\t\t\t\tAssert.IsTrue(\n\t\t\t\t\tc1.Address.Equals(\"foo bar\") &&\n\t\t\t\t\t(c1.Count == 23432) &&\n\t\t\t\t\tc1.Name.Equals(\"c1\") &&\n\t\t\t\t\tc1.D.Amount > 213.3f\n\t\t\t\t\t);\n\t\t\t\tAssert.IsTrue(\n\t\t\t\t\t(c1b.Count == 23432) &&\n\t\t\t\t\tc1b.Name.Equals(\"c1\")\n\t\t\t\t\t);\n\t\t\t\tConsole.Out.WriteLine(s.Delete(\"from a in class A\"));\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\ts.Save(new B());\n\t\t\t\ts.Save(new A());\n\t\t\t\tAssert.IsTrue(s.CreateQuery(\"from b in class B\").List().Count == 1);\n\t\t\t\tAssert.IsTrue(s.CreateQuery(\"from a in class A\").List().Count == 2);\n\t\t\t\ts.Delete(\"from a in class A\");\n\t\t\t\ts.Delete(c1.D);\n\t\t\t\tt.Commit();\n\t\t\t}\n\t\t}",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Legacy\\ABCProxyTest.cs",
      "SourceLine": 105
    },
    {
      "TypeIdentifier": "ABCProxyTest",
      "MethodIdentifier": "OneToOne",
      "SourcesSample": "[Test]\n\t\tpublic void OneToOne()\n\t\t{\n\t\t\tA a = new A();\n\t\t\tE d1 = new E();\n\t\t\tC1 c = new C1();\n\t\t\tE d2 = new E();\n\t\t\ta.Forward = d1;\n\t\t\td1.Reverse = a;\n\t\t\tc.Forward = d2;\n\t\t\td2.Reverse = c;\n\n\t\t\tobject aid;\n\t\t\tobject d2id;\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\taid = s.Save(a);\n\t\t\t\td2id = s.Save(d2);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tIList l;\n\t\t\t\tl = s.CreateQuery(\"from E e join fetch e.Reverse\").List();\n\t\t\t\tAssert.AreEqual(2, l.Count);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tIList l = s.CreateQuery(\"from E e\").List();\n\t\t\t\tAssert.AreEqual(2, l.Count);\n\t\t\t\tE e = (E) l[0];\n\t\t\t\tAssert.AreSame(e, e.Reverse.Forward);\n\t\t\t\te = (E) l[1];\n\t\t\t\tAssert.AreSame(e, e.Reverse.Forward);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\ta = (A) s.Load(typeof(A), aid);\n\t\t\t\td2 = (E) s.Load(typeof(E), d2id);\n\t\t\t\tAssert.AreSame(a, a.Forward.Reverse);\n\t\t\t\tAssert.AreSame(d2, d2.Reverse.Forward);\n\t\t\t\ts.Delete(a);\n\t\t\t\ts.Delete(a.Forward);\n\t\t\t\ts.Delete(d2);\n\t\t\t\ts.Delete(d2.Reverse);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tIList l = s.CreateQuery(\"from E e\").List();\n\t\t\t\tAssert.AreEqual(0, l.Count);\n\t\t\t\tt.Commit();\n\t\t\t}\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Legacy\\ABCProxyTest.cs",
      "SourceLine": 302
    },
    {
      "TypeIdentifier": "ABCProxyTest",
      "MethodIdentifier": "SharedColumn",
      "SourcesSample": "[Test]\n\t\tpublic void SharedColumn()\n\t\t{\n\t\t\tC1 c1;\n\t\t\tC2 c2;\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tc1 = new C1();\n\t\t\t\tc2 = new C2();\n\t\t\t\tc1.C2 = c2;\n\t\t\t\tc2.C1 = c1;\n\t\t\t\ts.Save(c1);\n\t\t\t\ts.Save(c2);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tIList list = s.CreateQuery(\"from B\").List();\n\t\t\t\tAssert.AreEqual(2, list.Count);\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tc1 = (C1) s.CreateQuery(\"from C1\").UniqueResult();\n\t\t\t\tc2 = (C2) s.CreateQuery(\"from C2\").UniqueResult();\n\t\t\t\tAssert.AreSame(c2, c1.C2);\n\t\t\t\tAssert.AreSame(c1, c2.C1);\n\t\t\t\tAssert.IsTrue(c1.C2s.Contains(c2));\n\t\t\t\tAssert.IsTrue(c2.C1s.Contains(c1));\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\tc1 = (C1) s.Get(typeof(A), c1.Id);\n\t\t\t\tc2 = (C2) s.Get(typeof(A), c2.Id);\n\t\t\t\tAssert.AreSame(c2, c1.C2);\n\t\t\t\tAssert.AreSame(c1, c2.C1);\n\t\t\t\tAssert.IsTrue(c1.C2s.Contains(c2));\n\t\t\t\tAssert.IsTrue(c2.C1s.Contains(c1));\n\t\t\t\tt.Commit();\n\t\t\t}\n\n\t\t\tusing (ISession s = OpenSession())\n\t\t\tusing (ITransaction t = s.BeginTransaction())\n\t\t\t{\n\t\t\t\ts.Delete(c1);\n\t\t\t\ts.Delete(c2);\n\t\t\t\tt.Commit();\n\t\t\t}\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Legacy\\ABCProxyTest.cs",
      "SourceLine": 46
    }
  ],
  [
    {
      "TypeIdentifier": "FooBarTest",
      "MethodIdentifier": "Query",
      "SourcesSample": "[Test]\r\n\t\tpublic void Query()\r\n\t\t{\r\n\t\t\tISession s = OpenSession();\r\n\t\t\tITransaction txn = s.BeginTransaction();\r\n\t\t\tFoo foo = new Foo();\r\n\t\t\ts.Save(foo);\r\n\t\t\tFoo foo2 = new Foo();\r\n\t\t\ts.Save(foo2);\r\n\t\t\tfoo.TheFoo = foo2;\r\n\r\n\t\t\tIList list = s.CreateQuery(\"from Foo foo inner join fetch foo.TheFoo\").List();\r\n\t\t\tFoo foof = (Foo) list[0];\r\n\t\t\tAssert.IsTrue(NHibernateUtil.IsInitialized(foof.TheFoo));\r\n\r\n\t\t\tlist = s.CreateQuery(\"from Baz baz left outer join fetch baz.FooToGlarch\").List();\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo, bar from Foo foo left outer join foo.TheFoo bar where foo = ?\")\r\n\t\t\t\t.SetEntity(0, foo).List();\r\n\r\n\r\n\t\t\tobject[] row1 = (object[]) list[0];\r\n\t\t\tAssert.IsTrue(row1[0] == foo && row1[1] == foo2);\r\n\r\n\t\t\ts.CreateQuery(\"select foo.TheFoo.TheFoo.String from foo in class Foo where foo.TheFoo = 'bar'\").List();\r\n\t\t\ts.CreateQuery(\"select foo.TheFoo.TheFoo.TheFoo.String from foo in class Foo where foo.TheFoo.TheFoo = 'bar'\").List();\r\n\t\t\ts.CreateQuery(\"select foo.TheFoo.TheFoo.String from foo in class Foo where foo.TheFoo.TheFoo.TheFoo.String = 'bar'\").\r\n\t\t\t\tList();\r\n\t\t\t//\t\t\tif( !( dialect is Dialect.HSQLDialect ) ) \r\n\t\t\t//\t\t\t{\r\n\t\t\ts.CreateQuery(\"select foo.String from foo in class Foo where foo.TheFoo.TheFoo.TheFoo = foo.TheFoo.TheFoo\").List();\r\n\t\t\t//\t\t\t}\r\n\t\t\ts.CreateQuery(\r\n\t\t\t\t\"select foo.String from foo in class Foo where foo.TheFoo.TheFoo = 'bar' and foo.TheFoo.TheFoo.TheFoo = 'baz'\").List\r\n\t\t\t\t();\r\n\t\t\ts.CreateQuery(\r\n\t\t\t\t\"select foo.String from foo in class Foo where foo.TheFoo.TheFoo.TheFoo.String = 'a' and foo.TheFoo.String = 'b'\").\r\n\t\t\t\tList();\r\n\r\n\t\t\ts.CreateQuery(\"from bar in class Bar, foo in elements(bar.Baz.FooArray)\").List();\r\n\r\n\t\t\tif (Dialect is DB2Dialect)\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(\"from foo in class Foo where lower( foo.TheFoo.String ) = 'foo'\").List();\r\n\t\t\t\ts.CreateQuery(\"from foo in class Foo where lower( (foo.TheFoo.String || 'foo') || 'bar' ) = 'foo'\").List();\r\n\t\t\t\ts.CreateQuery(\"from foo in class Foo where repeat( (foo.TheFoo.STring || 'foo') || 'bar', 2 ) = 'foo'\").List();\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"From foo in class Bar where foo.TheFoo.Integer is not null and repeat( (foo.TheFoo.String || 'foo') || 'bar', (5+5)/2 ) = 'foo'\")\r\n\t\t\t\t\t.List();\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"From foo in class Bar where foo.TheFoo.Integer is not null or repeat( (foo.TheFoo.String || 'foo') || 'bar', (5+5)/2 ) = 'foo'\")\r\n\t\t\t\t\t.List();\r\n\t\t\t}\r\n\r\n\t\t\tif (Dialect is MsSql2000Dialect)\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(\"select baz from Baz as baz join baz.FooArray foo group by baz order by sum(foo.Float)\").Enumerable();\r\n\t\t\t}\r\n\r\n\t\t\ts.CreateQuery(\"from Foo as foo where foo.Component.Glarch.Name is not null\").List();\r\n\t\t\ts.CreateQuery(\"from Foo as foo left outer join foo.Component.Glarch as glarch where glarch.Name = 'foo'\").List();\r\n\r\n\t\t\tlist = s.CreateQuery(\"from Foo\").List();\r\n\t\t\tAssert.AreEqual(2, list.Count);\r\n\t\t\tAssert.IsTrue(list[0] is FooProxy);\r\n\t\t\tlist = s.CreateQuery(\"from Foo foo left outer join foo.TheFoo\").List();\r\n\t\t\tAssert.AreEqual(2, list.Count);\r\n\t\t\tAssert.IsTrue(((object[]) list[0])[0] is FooProxy);\r\n\r\n\t\t\ts.CreateQuery(\"From Foo, Bar\").List();\r\n\t\t\ts.CreateQuery(\"from Baz baz left join baz.FooToGlarch, Bar bar join bar.TheFoo\").List();\r\n\t\t\ts.CreateQuery(\"from Baz baz left join baz.FooToGlarch join baz.FooSet\").List();\r\n\t\t\ts.CreateQuery(\"from Baz baz left join baz.FooToGlarch join fetch baz.FooSet foo left join fetch foo.TheFoo\").List();\r\n\r\n\t\t\tlist =\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"from foo in class NHibernate.DomainModel.Foo where foo.String='osama bin laden' and foo.Boolean = true order by foo.String asc, foo.Component.Count desc\")\r\n\t\t\t\t\t.List();\r\n\t\t\tAssert.AreEqual(0, list.Count, \"empty query\");\r\n\t\t\tIEnumerable enumerable =\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"from foo in class NHibernate.DomainModel.Foo where foo.String='osama bin laden' order by foo.String asc, foo.Component.Count desc\")\r\n\t\t\t\t\t.Enumerable();\r\n\t\t\tAssert.IsTrue(IsEmpty(enumerable), \"empty enumerator\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo.TheFoo from foo in class NHibernate.DomainModel.Foo\").List();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"query\");\r\n\t\t\tAssert.AreEqual(foo.TheFoo, list[0], \"returned object\");\r\n\t\t\tfoo.TheFoo.TheFoo = foo;\r\n\t\t\tfoo.String = \"fizard\";\r\n\r\n\t\t\tif (Dialect.SupportsSubSelects && TestDialect.SupportsOperatorSome)\r\n\t\t\t{\r\n\t\t\t\tif (!(Dialect is FirebirdDialect))\r\n\t\t\t\t{\r\n\t\t\t\t\tlist = s.CreateQuery(\r\n\t\t\t\t\t\t\t\"from foo in class NHibernate.DomainModel.Foo where ? = some elements(foo.Component.ImportantDates)\").\r\n\t\t\t\t\t\t\tSetDateTime(0, DateTime.Today).List();\r\n\t\t\t\t\t\r\n\t\t\t\t\tAssert.AreEqual(2, list.Count, \"component query\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlist =\r\n\t\t\t\t\ts.CreateQuery(\"from foo in class NHibernate.DomainModel.Foo where size(foo.Component.ImportantDates) = 3\").List();\r\n\t\t\t\tAssert.AreEqual(2, list.Count, \"component query\");\r\n\t\t\t\tlist = s.CreateQuery(\"from foo in class Foo where 0 = size(foo.Component.ImportantDates)\").List();\r\n\t\t\t\tAssert.AreEqual(0, list.Count, \"component query\");\r\n\t\t\t\tlist = s.CreateQuery(\"from foo in class Foo where exists elements(foo.Component.ImportantDates)\").List();\r\n\t\t\t\tAssert.AreEqual(2, list.Count, \"component query\");\r\n\t\t\t\ts.CreateQuery(\"from foo in class Foo where not exists (from bar in class Bar where bar.id = foo.id)\").List();\r\n\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"select foo.TheFoo from foo in class Foo where foo = some(select x from x in class Foo where x.Long > foo.TheFoo.Long)\")\r\n\t\t\t\t\t.List();\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"from foo in class Foo where foo = some(select x from x in class Foo where x.Long > foo.TheFoo.Long) and foo.TheFoo.String='baz'\")\r\n\t\t\t\t\t.List();\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"from foo in class Foo where foo.TheFoo.String='baz' and foo = some(select x from x in class Foo where x.Long>foo.TheFoo.Long)\")\r\n\t\t\t\t\t.List();\r\n\t\t\t\ts.CreateQuery(\"from foo in class Foo where foo = some(select x from x in class Foo where x.Long > foo.TheFoo.Long)\")\r\n\t\t\t\t\t.List();\r\n\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"select foo.String, foo.Date, foo.TheFoo.String, foo.id from foo in class Foo, baz in class Baz where foo in elements(baz.FooArray) and foo.String like 'foo'\")\r\n\t\t\t\t\t.Enumerable();\r\n\t\t\t}\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where foo.Component.Count is null order by foo.Component.Count\").List();\r\n\t\t\tAssert.AreEqual(0, list.Count, \"component query\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where foo.Component.Name='foo'\").List();\r\n\t\t\tAssert.AreEqual(2, list.Count, \"component query\");\r\n\r\n\t\t\tlist =\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"select distinct foo.Component.Name, foo.Component.Name from foo in class Foo where foo.Component.Name='foo'\").List\r\n\t\t\t\t\t();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"component query\");\r\n\r\n\t\t\tlist =\r\n\t\t\t\ts.CreateQuery(\"select distinct foo.Component.Name, foo.id from foo in class Foo where foo.Component.Name='foo'\").\r\n\t\t\t\t\tList();\r\n\t\t\tAssert.AreEqual(2, list.Count, \"component query\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo.TheFoo from foo in class Foo\").List();\r\n\t\t\tAssert.AreEqual(2, list.Count, \"query\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where foo.id=?\").SetString(0, foo.Key).List();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"id query\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where foo.Key=?\").SetString(0, foo.Key).List();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"named id query\");\r\n\t\t\tAssert.AreSame(foo, list[0], \"id query\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo.TheFoo from foo in class Foo where foo.String='fizard'\").List();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"query\");\r\n\t\t\tAssert.AreSame(foo.TheFoo, list[0], \"returned object\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where foo.Component.Subcomponent.Name='bar'\").List();\r\n\t\t\tAssert.AreEqual(2, list.Count, \"components of components\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo.TheFoo from foo in class Foo where foo.TheFoo.id=?\")\r\n\t\t\t\t.SetString(0, foo.TheFoo.Key).List();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"by id query\");\r\n\t\t\tAssert.AreSame(foo.TheFoo, list[0], \"by id returned object\");\r\n\r\n\t\t\ts.CreateQuery(\"from foo in class Foo where foo.TheFoo = ?\").SetEntity(0, foo.TheFoo).List();\r\n\r\n\t\t\tAssert.IsTrue(\r\n\t\t\t\tIsEmpty(s.CreateQuery(\"from bar in class Bar where bar.String='a string' or bar.String='a string'\").Enumerable()\r\n\t\t\t\t\t));\r\n\r\n\t\t\tenumerable = s.CreateQuery(\r\n\t\t\t\t\t\t\"select foo.Component.Name, elements(foo.Component.ImportantDates) from foo in class Foo where foo.TheFoo.id=?\").\r\n\t\t\t\t\t\tSetString(0, foo.TheFoo.Key).Enumerable();\r\n\t\t\t\r\n\r\n\t\t\tint i = 0;\r\n\t\t\tforeach (object[] row in enumerable)\r\n\t\t\t{\r\n\t\t\t\ti++;\r\n\t\t\t\tAssert.IsTrue(row[0] is String);\r\n\t\t\t\tAssert.IsTrue(row[1] == null || row[1] is DateTime);\r\n\t\t\t}\r\n\t\t\tAssert.AreEqual(3, i); //WAS: 4\r\n\r\n\t\t\tenumerable = s.CreateQuery(\"select max(elements(foo.Component.ImportantDates)) from foo in class Foo group by foo.id\").\r\n\t\t\t\t\t\tEnumerable();\r\n\t\t\t\r\n\t\t\tIEnumerator enumerator = enumerable.GetEnumerator();\r\n\r\n\t\t\tAssert.IsTrue(enumerator.MoveNext());\r\n\t\t\tAssert.IsTrue(enumerator.Current is DateTime);\r\n\r\n\t\t\tlist = s.CreateQuery(\r\n\t\t\t\t\"select foo.TheFoo.TheFoo.TheFoo from foo in class Foo, foo2 in class Foo where\"\r\n\t\t\t\t+ \" foo = foo2.TheFoo and not not ( not foo.String='fizard' )\"\r\n\t\t\t\t+ \" and foo2.String between 'a' and (foo.TheFoo.String)\"\r\n\t\t\t\t+ (Dialect is SQLiteDialect\r\n\t\t\t\t   \t? \" and ( foo2.String in ( 'fiz', 'blah') or 1=1 )\"\r\n\t\t\t\t   \t: \" and ( foo2.String in ( 'fiz', 'blah', foo.TheFoo.String, foo.String, foo2.String ) )\")\r\n\t\t\t\t).List();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"complex query\");\r\n\t\t\tAssert.AreSame(foo, list[0], \"returned object\");\r\n\r\n\t\t\tfoo.String = \"from BoogieDown  -tinsel town  =!@#$^&*())\";\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where foo.String='from BoogieDown  -tinsel town  =!@#$^&*())'\").List();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"single quotes\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where not foo.String='foo''bar'\").List();\r\n\t\t\tAssert.AreEqual(2, list.Count, \"single quotes\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where foo.Component.Glarch.Next is null\").List();\r\n\t\t\tAssert.AreEqual(2, list.Count, \"query association in component\");\r\n\r\n\t\t\tBar bar = new Bar();\r\n\t\t\tBaz baz = new Baz();\r\n\t\t\tbaz.SetDefaults();\r\n\t\t\tbar.Baz = baz;\r\n\t\t\tbaz.ManyToAny = new ArrayList();\r\n\t\t\tbaz.ManyToAny.Add(bar);\r\n\t\t\tbaz.ManyToAny.Add(foo);\r\n\t\t\ts.Save(bar);\r\n\t\t\ts.Save(baz);\r\n\t\t\tlist =\r\n\t\t\t\ts.CreateQuery(\" from bar in class Bar where bar.Baz.Count=667 and bar.Baz.Count!=123 and not bar.Baz.Name='1-E-1'\").\r\n\t\t\t\t\tList();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"query many-to-one\");\r\n\t\t\tlist = s.CreateQuery(\" from i in class Bar where i.Baz.Name='Bazza'\").List();\r\n\t\t\tAssert.AreEqual(1, list.Count, \"query many-to-one\");\r\n\r\n\t\t\tif (DialectSupportsCountDistinct)\r\n\t\t\t{\r\n\t\t\t\tenumerable = s.CreateQuery(\"select count(distinct foo.TheFoo) from foo in class Foo\").Enumerable();\r\n\t\t\t\tAssert.IsTrue(ContainsSingleObject(enumerable, (long) 2), \"count\"); // changed to Int64 (HQLFunction H3.2)\r\n\t\t\t}\r\n\r\n\t\t\tenumerable = s.CreateQuery(\"select count(foo.TheFoo.Boolean) from foo in class Foo\").Enumerable();\r\n\t\t\tAssert.IsTrue(ContainsSingleObject(enumerable, (long) 2), \"count\"); // changed to Int64 (HQLFunction H3.2)\r\n\r\n\t\t\tenumerable = s.CreateQuery(\"select count(*), foo.Int from foo in class Foo group by foo.Int\").Enumerable();\r\n\t\t\tenumerator = enumerable.GetEnumerator();\r\n\t\t\tAssert.IsTrue(enumerator.MoveNext());\r\n\t\t\tAssert.AreEqual(3L, (long) ((object[]) enumerator.Current)[0]);\r\n\t\t\tAssert.IsFalse(enumerator.MoveNext());\r\n\r\n\t\t\tenumerable = s.CreateQuery(\"select sum(foo.TheFoo.Int) from foo in class Foo\").Enumerable();\r\n\t\t\tAssert.IsTrue(ContainsSingleObject(enumerable, (long) 4), \"sum\"); // changed to Int64 (HQLFunction H3.2)\r\n\r\n\t\t\tenumerable = s.CreateQuery(\"select count(foo) from foo in class Foo where foo.id=?\")\r\n\t\t\t\t.SetString(0, foo.Key).Enumerable();\r\n\t\t\tAssert.IsTrue(ContainsSingleObject(enumerable, (long) 1), \"id query count\");\r\n\r\n\t\t\tlist = s.CreateQuery(\"from foo in class Foo where foo.Boolean = ?\").SetBoolean(0, true).List();\r\n\r\n\t\t\tlist = s.CreateQuery(\"select new Foo(fo.X) from Fo fo\").List();\r\n\t\t\tlist = s.CreateQuery(\"select new Foo(fo.Integer) from Foo fo\").List();\r\n\r\n\t\t\tlist = s.CreateQuery(\"select new Foo(fo.X) from Foo fo\")\r\n\t\t\t\t.SetCacheable(true)\r\n\t\t\t\t.List();\r\n\t\t\tAssert.IsTrue(list.Count == 3);\r\n\t\t\tlist = s.CreateQuery(\"select new Foo(fo.X) from Foo fo\")\r\n\t\t\t\t.SetCacheable(true)\r\n\t\t\t\t.List();\r\n\t\t\tAssert.IsTrue(list.Count == 3);\r\n\r\n\t\t\tenumerable = s.CreateQuery(\"select new Foo(fo.X) from Foo fo\").Enumerable();\r\n\t\t\tenumerator = enumerable.GetEnumerator();\r\n\t\t\tAssert.IsTrue(enumerator.MoveNext(), \"projection iterate (results)\");\r\n\t\t\tAssert.IsTrue(typeof(Foo).IsAssignableFrom(enumerator.Current.GetType()),\r\n\t\t\t              \"projection iterate (return check)\");\r\n\r\n\t\t\t// TODO: ScrollableResults not implemented\r\n\t\t\t//ScrollableResults sr = s.CreateQuery(\"select new Foo(fo.x) from Foo fo\").Scroll();\r\n\t\t\t//Assert.IsTrue( \"projection scroll (results)\", sr.next() );\r\n\t\t\t//Assert.IsTrue( \"projection scroll (return check)\", typeof(Foo).isAssignableFrom( sr.get(0).getClass() ) );\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo.Long, foo.Component.Name, foo, foo.TheFoo from foo in class Foo\").List();\r\n\t\t\tAssert.IsTrue(list.Count > 0);\r\n\t\t\tforeach (object[] row in list)\r\n\t\t\t{\r\n\t\t\t\tAssert.IsTrue(row[0] is long);\r\n\t\t\t\tAssert.IsTrue(row[1] is string);\r\n\t\t\t\tAssert.IsTrue(row[2] is Foo);\r\n\t\t\t\tAssert.IsTrue(row[3] is Foo);\r\n\t\t\t}\r\n\r\n\t\t\tif (DialectSupportsCountDistinct)\r\n\t\t\t{\r\n\t\t\t\tlist =\r\n\t\t\t\t\ts.CreateQuery(\"select avg(foo.Float), max(foo.Component.Name), count(distinct foo.id) from foo in class Foo\").List();\r\n\t\t\t\tAssert.IsTrue(list.Count > 0);\r\n\t\t\t\tforeach (object[] row in list)\r\n\t\t\t\t{\r\n\t\t\t\t\tAssert.IsTrue(row[0] is double); // changed from float to double (HQLFunction H3.2) \r\n\t\t\t\t\tAssert.IsTrue(row[1] is string);\r\n\t\t\t\t\tAssert.IsTrue(row[2] is long); // changed from int to long (HQLFunction H3.2)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo.Long, foo.Component, foo, foo.TheFoo from foo in class Foo\").List();\r\n\t\t\tAssert.IsTrue(list.Count > 0);\r\n\t\t\tforeach (object[] row in list)\r\n\t\t\t{\r\n\t\t\t\tAssert.IsTrue(row[0] is long);\r\n\t\t\t\tAssert.IsTrue(row[1] is FooComponent);\r\n\t\t\t\tAssert.IsTrue(row[2] is Foo);\r\n\t\t\t\tAssert.IsTrue(row[3] is Foo);\r\n\t\t\t}\r\n\r\n\t\t\ts.Save(new Holder(\"ice T\"));\r\n\t\t\ts.Save(new Holder(\"ice cube\"));\r\n\r\n\t\t\tAssert.AreEqual(15, s.CreateQuery(\"from o in class System.Object\").List().Count);\r\n\t\t\tAssert.AreEqual(7, s.CreateQuery(\"from n in class INamed\").List().Count);\r\n\t\t\tAssert.IsTrue(s.CreateQuery(\"from n in class INamed where n.Name is not null\").List().Count == 4);\r\n\r\n\t\t\tforeach (INamed named in s.CreateQuery(\"from n in class INamed\").Enumerable())\r\n\t\t\t{\r\n\t\t\t\tAssert.IsNotNull(named);\r\n\t\t\t}\r\n\r\n\t\t\ts.Save(new Holder(\"bar\"));\r\n\t\t\tenumerable = s.CreateQuery(\"from n0 in class INamed, n1 in class INamed where n0.Name = n1.Name\").Enumerable();\r\n\t\t\tint cnt = 0;\r\n\t\t\tforeach (object[] row in enumerable)\r\n\t\t\t{\r\n\t\t\t\tif (row[0] != row[1])\r\n\t\t\t\t{\r\n\t\t\t\t\tcnt++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//if ( !(dialect is Dialect.HSQLDialect) )\r\n\t\t\t//{\r\n\t\t\tAssert.IsTrue(cnt == 2);\r\n\t\t\tAssert.IsTrue(s.CreateQuery(\"from n0 in class INamed, n1 in class INamed where n0.Name = n1.Name\").List().Count == 7);\r\n\t\t\t//}\r\n\r\n\t\t\tIQuery qu = s.CreateQuery(\"from n in class INamed where n.Name = :name\");\r\n\t\t\tobject temp = qu.ReturnTypes;\r\n\t\t\ttemp = qu.NamedParameters;\r\n\r\n\t\t\tint c = 0;\r\n\r\n\t\t\tforeach (object obj in s.CreateQuery(\"from o in class System.Object\").Enumerable())\r\n\t\t\t{\r\n\t\t\t\tc++;\r\n\t\t\t}\r\n\t\t\tAssert.IsTrue(c == 16);\r\n\r\n\t\t\ts.CreateQuery(\"select baz.Code, min(baz.Count) from baz in class Baz group by baz.Code\").Enumerable();\r\n\r\n\t\t\tAssert.IsTrue(\r\n\t\t\t\tIsEmpty(\r\n\t\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\t\"selecT baz from baz in class Baz where baz.StringDateMap['foo'] is not null or baz.StringDateMap['bar'] = ?\")\r\n\t\t\t\t\t\t.SetDateTime(0, DateTime.Today).Enumerable()));\r\n\r\n\t\t\tlist = s.CreateQuery(\"select baz from baz in class Baz where baz.StringDateMap['now'] is not null\").List();\r\n\t\t\tAssert.AreEqual(1, list.Count);\r\n\r\n\t\t\tlist =\r\n\t\t\t\ts.CreateQuery(\"select baz from baz in class Baz where baz.StringDateMap[:now] is not null\").SetString(\"now\", \"now\").\r\n\t\t\t\t\tList();\r\n\t\t\tAssert.AreEqual(1, list.Count);\r\n\r\n\t\t\tlist =\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"select baz from baz in class Baz where baz.StringDateMap['now'] is not null and baz.StringDateMap['big bang'] < baz.StringDateMap['now']\")\r\n\t\t\t\t\t.List();\r\n\t\t\tAssert.AreEqual(1, list.Count);\r\n\r\n\t\t\tlist = s.CreateQuery(\"select index(date) from Baz baz join baz.StringDateMap date\").List();\r\n\t\t\tConsole.WriteLine(list);\r\n\t\t\tAssert.AreEqual(3, list.Count);\r\n\r\n\t\t\ts.CreateQuery(\r\n\t\t\t\t\"from foo in class Foo where foo.Integer not between 1 and 5 and foo.String not in ('cde', 'abc') and foo.String is not null and foo.Integer<=3\")\r\n\t\t\t\t.List();\r\n\r\n\t\t\ts.CreateQuery(\"from Baz baz inner join baz.CollectionComponent.Nested.Foos foo where foo.String is null\").List();\r\n\t\t\tif (Dialect.SupportsSubSelects)\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(\"from Baz baz inner join baz.FooSet where '1' in (from baz.FooSet foo where foo.String is not null)\").\r\n\t\t\t\t\tList();\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"from Baz baz where 'a' in elements(baz.CollectionComponent.Nested.Foos) and 1.0 in elements(baz.CollectionComponent.Nested.Floats)\")\r\n\t\t\t\t\t.List();\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"from Baz baz where 'b' in elements(baz.CollectionComponent.Nested.Foos) and 1.0 in elements(baz.CollectionComponent.Nested.Floats)\")\r\n\t\t\t\t\t.List();\r\n\t\t\t}\r\n\r\n\t\t\ts.CreateQuery(\"from Foo foo join foo.TheFoo where foo.TheFoo in ('1','2','3')\").List();\r\n\r\n\t\t\t//if ( !(dialect is Dialect.HSQLDialect) )\r\n\t\t\ts.CreateQuery(\"from Foo foo left join foo.TheFoo where foo.TheFoo in ('1','2','3')\").List();\r\n\t\t\ts.CreateQuery(\"select foo.TheFoo from Foo foo where foo.TheFoo in ('1','2','3')\").List();\r\n\t\t\ts.CreateQuery(\"select foo.TheFoo.String from Foo foo where foo.TheFoo in ('1','2','3')\").List();\r\n\t\t\ts.CreateQuery(\"select foo.TheFoo.String from Foo foo where foo.TheFoo.String in ('1','2','3')\").List();\r\n\t\t\ts.CreateQuery(\"select foo.TheFoo.Long from Foo foo where foo.TheFoo.String in ('1','2','3')\").List();\r\n\t\t\ts.CreateQuery(\"select count(*) from Foo foo where foo.TheFoo.String in ('1','2','3') or foo.TheFoo.Long in (1,2,3)\").\r\n\t\t\t\tList();\r\n\t\t\ts.CreateQuery(\"select count(*) from Foo foo where foo.TheFoo.String in ('1','2','3') group by foo.TheFoo.Long\").List();\r\n\r\n\t\t\ts.CreateQuery(\"from Foo foo1 left join foo1.TheFoo foo2 left join foo2.TheFoo where foo1.String is not null\").List();\r\n\t\t\ts.CreateQuery(\"from Foo foo1 left join foo1.TheFoo.TheFoo where foo1.String is not null\").List();\r\n\t\t\ts.CreateQuery(\r\n\t\t\t\t\"from Foo foo1 left join foo1.TheFoo foo2 left join foo1.TheFoo.TheFoo foo3 where foo1.String is not null\").List();\r\n\r\n\t\t\ts.CreateQuery(\"select foo.Formula from Foo foo where foo.Formula > 0\").List();\r\n\r\n\t\t\tint len = s.CreateQuery(\"from Foo as foo join foo.TheFoo as foo2 where foo2.id >'a' or foo2.id <'a'\").List().Count;\r\n\t\t\tAssert.IsTrue(len == 2);\r\n\r\n\t\t\ts.Delete(\"from Holder\");\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Close();\r\n\r\n\t\t\ts = OpenSession();\r\n\t\t\ttxn = s.BeginTransaction();\r\n\t\t\tbaz = (Baz) s.CreateQuery(\"from Baz baz left outer join fetch baz.ManyToAny\").UniqueResult();\r\n\t\t\tAssert.IsTrue(NHibernateUtil.IsInitialized(baz.ManyToAny));\r\n\t\t\tAssert.IsTrue(baz.ManyToAny.Count == 2);\r\n\t\t\tBarProxy barp = (BarProxy) baz.ManyToAny[0];\r\n\t\t\ts.CreateQuery(\"from Baz baz join baz.ManyToAny\").List();\r\n\t\t\tAssert.IsTrue(s.CreateQuery(\"select baz from Baz baz join baz.ManyToAny a where index(a) = 0\").List().Count == 1);\r\n\r\n\t\t\tFooProxy foop = (FooProxy) s.Get(typeof(Foo), foo.Key);\r\n\t\t\tAssert.IsTrue(foop == baz.ManyToAny[1]);\r\n\r\n\t\t\tbarp.Baz = baz;\r\n\t\t\tAssert.IsTrue(s.CreateQuery(\"select bar from Bar bar where bar.Baz.StringDateMap['now'] is not null\").List().Count ==\r\n\t\t\t              1);\r\n\t\t\tAssert.IsTrue(\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"select bar from Bar bar join bar.Baz b where b.StringDateMap['big bang'] < b.StringDateMap['now'] and b.StringDateMap['now'] is not null\")\r\n\t\t\t\t\t.List().Count == 1);\r\n\t\t\tAssert.IsTrue(\r\n\t\t\t\ts.CreateQuery(\r\n\t\t\t\t\t\"select bar from Bar bar where bar.Baz.StringDateMap['big bang'] < bar.Baz.StringDateMap['now'] and bar.Baz.StringDateMap['now'] is not null\")\r\n\t\t\t\t\t.List().Count == 1);\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo.String, foo.Component, foo.id from Bar foo\").List();\r\n\t\t\tAssert.IsTrue(((FooComponent) ((object[]) list[0])[1]).Name == \"foo\");\r\n\t\t\tlist = s.CreateQuery(\"select elements(baz.Components) from Baz baz\").List();\r\n\t\t\tAssert.IsTrue(list.Count == 2);\r\n\t\t\tlist = s.CreateQuery(\"select bc.Name from Baz baz join baz.Components bc\").List();\r\n\t\t\tAssert.IsTrue(list.Count == 2);\r\n\t\t\t//list = s.CreateQuery(\"select bc from Baz baz join baz.components bc\").List();\r\n\r\n\t\t\ts.CreateQuery(\"from Foo foo where foo.Integer < 10 order by foo.String\").SetMaxResults(12).List();\r\n\r\n\t\t\ts.Delete(barp);\r\n\t\t\ts.Delete(baz);\r\n\t\t\ts.Delete(foop.TheFoo);\r\n\t\t\ts.Delete(foop);\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Close();\r\n\t\t}",
      "nStatementSyntax": 16,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Legacy\\FooBarTest.cs",
      "SourceLine": 421
    },
    {
      "TypeIdentifier": "FooBarTest",
      "MethodIdentifier": "AssociationId",
      "SourcesSample": "[Test]\r\n\t\t//[Ignore(\"TimeZone Portions commented out - http://jira.nhibernate.org:8080/browse/NH-88\")]\r\n\t\tpublic void AssociationId()\r\n\t\t{\r\n\t\t\tstring id;\r\n\t\t\tBar bar;\r\n\t\t\tMoreStuff more;\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t{\r\n\t\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\tbar = new Bar();\r\n\t\t\t\t\tid = (string) s.Save(bar);\r\n\t\t\t\t\tmore = new MoreStuff();\r\n\t\t\t\t\tmore.Name = \"More Stuff\";\r\n\t\t\t\t\tmore.IntId = 12;\r\n\t\t\t\t\tmore.StringId = \"id\";\r\n\t\t\t\t\tStuff stuf = new Stuff();\r\n\t\t\t\t\tstuf.MoreStuff = more;\r\n\t\t\t\t\tmore.Stuffs = new ArrayList();\r\n\t\t\t\t\tmore.Stuffs.Add(stuf);\r\n\t\t\t\t\tstuf.Foo = bar;\r\n\t\t\t\t\tstuf.Id = 1234;\r\n\r\n\t\t\t\t\ts.Save(more);\r\n\t\t\t\t\tt.Commit();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t{\r\n\t\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\t//The special property (lowercase) id may be used to reference the unique identifier of an object. (You may also use its property name.) \r\n\t\t\t\t\tstring hqlString =\r\n\t\t\t\t\t\t\"from s in class Stuff where s.Foo.id = ? and s.id.Id = ? and s.MoreStuff.id.IntId = ? and s.MoreStuff.id.StringId = ?\";\r\n\t\t\t\t\tobject[] values = new object[] {bar, (long) 1234, 12, \"id\"};\r\n\t\t\t\t\tIType[] types = new IType[]\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tNHibernateUtil.Entity(typeof(Foo)),\r\n\t\t\t\t\t\t\tNHibernateUtil.Int64,\r\n\t\t\t\t\t\t\tNHibernateUtil.Int32,\r\n\t\t\t\t\t\t\tNHibernateUtil.String\r\n\t\t\t\t\t\t};\r\n\r\n\r\n\t\t\t\t\t//IList results = s.List( hqlString, values, types );\r\n\t\t\t\t\tIQuery q = s.CreateQuery(hqlString);\r\n\t\t\t\t\tfor (int i = 0; i < values.Length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tq.SetParameter(i, values[i], types[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tIList results = q.List();\r\n\t\t\t\t\tAssert.AreEqual(1, results.Count);\r\n\r\n\t\t\t\t\thqlString = \"from s in class Stuff where s.Foo.id = ? and s.id.Id = ? and s.MoreStuff.Name = ?\";\r\n\t\t\t\t\tvalues = new object[] {bar, (long) 1234, \"More Stuff\"};\r\n\t\t\t\t\ttypes = new IType[]\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tNHibernateUtil.Entity(typeof(Foo)),\r\n\t\t\t\t\t\t\tNHibernateUtil.Int64,\r\n\t\t\t\t\t\t\tNHibernateUtil.String\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\tq = s.CreateQuery(hqlString);\r\n\t\t\t\t\tfor (int i = 0; i < values.Length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tq.SetParameter(i, values[i], types[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults = q.List();\r\n\t\t\t\t\tAssert.AreEqual(1, results.Count);\r\n\r\n\r\n\t\t\t\t\thqlString = \"from s in class Stuff where s.Foo.String is not null\";\r\n\t\t\t\t\ts.CreateQuery(hqlString).List();\r\n\r\n\t\t\t\t\thqlString = \"from s in class Stuff where s.Foo > '0' order by s.Foo\";\r\n\t\t\t\t\tresults = s.CreateQuery(hqlString).List();\r\n\t\t\t\t\tAssert.AreEqual(1, results.Count);\r\n\r\n\t\t\t\t\tt.Commit();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tFooProxy foo;\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t{\r\n\t\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\tfoo = (FooProxy) s.Load(typeof(Foo), id);\r\n\t\t\t\t\ts.Load(more, more);\r\n\t\t\t\t\tt.Commit();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t{\r\n\t\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\tStuff stuff = new Stuff();\r\n\t\t\t\t\tstuff.Foo = foo;\r\n\t\t\t\t\tstuff.Id = 1234;\r\n\t\t\t\t\tstuff.MoreStuff = more;\r\n\t\t\t\t\ts.Load(stuff, stuff);\r\n\r\n\t\t\t\t\tAssert.AreEqual(\"More Stuff\", stuff.MoreStuff.Name);\r\n\t\t\t\t\ts.Delete(\"from ms in class MoreStuff\");\r\n\t\t\t\t\ts.Delete(\"from foo in class Foo\");\r\n\r\n\t\t\t\t\tt.Commit();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Legacy\\FooBarTest.cs",
      "SourceLine": 2235
    },
    {
      "TypeIdentifier": "FooBarTest",
      "MethodIdentifier": "PersistCollections",
      "SourcesSample": "[Test]\r\n\t\tpublic void PersistCollections()\r\n\t\t{\r\n\t\t\tISession s = OpenSession();\r\n\t\t\tITransaction txn = s.BeginTransaction();\r\n\t\t\tIEnumerator enumer = s.CreateQuery(\"select count(*) from b in class Bar\").Enumerable().GetEnumerator();\r\n\t\t\tenumer.MoveNext();\r\n\t\t\tAssert.AreEqual(0L, enumer.Current);\r\n\r\n\t\t\tBaz baz = new Baz();\r\n\t\t\ts.Save(baz);\r\n\t\t\tbaz.SetDefaults();\r\n\t\t\tbaz.StringArray = new string[] {\"stuff\"};\r\n\t\t\tbaz.CascadingBars = new HashSet<BarProxy> {new Bar()};\r\n\t\t\tIDictionary sgm = new Hashtable();\r\n\t\t\tsgm[\"a\"] = new Glarch();\r\n\t\t\tsgm[\"b\"] = new Glarch();\r\n\t\t\tbaz.StringGlarchMap = sgm;\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Close();\r\n\r\n\t\t\ts = OpenSession();\r\n\t\t\ttxn = s.BeginTransaction();\r\n\t\t\tbaz = (Baz) ((object[]) s.CreateQuery(\"select baz, baz from baz in class NHibernate.DomainModel.Baz\").List()[0])[1];\r\n\t\t\tAssert.AreEqual(1, baz.CascadingBars.Count, \"baz.CascadingBars.Count\");\r\n\t\t\tFoo foo = new Foo();\r\n\t\t\ts.Save(foo);\r\n\t\t\tFoo foo2 = new Foo();\r\n\t\t\ts.Save(foo2);\r\n\t\t\tbaz.FooArray = new Foo[] {foo, foo, null, foo2};\r\n\t\t\tbaz.FooSet.Add(foo);\r\n\t\t\tbaz.Customs.Add(new string[] {\"new\", \"custom\"});\r\n\t\t\tbaz.StringArray = null;\r\n\t\t\tbaz.StringList[0] = \"new value\";\r\n\t\t\tbaz.StringSet = new HashSet<string>();\r\n\r\n\t\t\t// NOTE: We put two items in the map, but expect only one to come back, because\r\n\t\t\t// of where=\"...\" specified in the mapping for StringGlarchMap\r\n\t\t\tAssert.AreEqual(1, baz.StringGlarchMap.Count, \"baz.StringGlarchMap.Count\");\r\n\t\t\tIList list;\r\n\r\n\t\t\t// disable this for dbs with no subselects\r\n\t\t\tif (Dialect.SupportsSubSelects && TestDialect.SupportsOperatorAll)\r\n\t\t\t{\r\n\t\t\t\tlist = s.CreateQuery(\r\n\t\t\t\t\t\t\t\"select foo from foo in class NHibernate.DomainModel.Foo, baz in class NHibernate.DomainModel.Baz where foo in elements(baz.FooArray) and 3 = some elements(baz.IntArray) and 4 > all indices(baz.IntArray)\")\r\n\t\t\t\t\t\t\t.List();\r\n\t\t\t\t\r\n\r\n\t\t\t\tAssert.AreEqual(2, list.Count, \"collection.elements find\");\r\n\t\t\t}\r\n\r\n\t\t\t// sapdb doesn't like distinct with binary type\r\n\t\t\t//if( !(dialect is Dialect.SAPDBDialect) ) \r\n\t\t\t//{\r\n\t\t\tlist = s.CreateQuery(\"select distinct foo from baz in class NHibernate.DomainModel.Baz, foo in elements(baz.FooArray)\").\r\n\t\t\t\t\t\tList();\r\n\t\t\t\r\n\t\t\tAssert.AreEqual(2, list.Count, \"collection.elements find\");\r\n\t\t\t//}\r\n\r\n\t\t\tlist = s.CreateQuery(\"select foo from baz in class NHibernate.DomainModel.Baz, foo in elements(baz.FooSet)\").List();\r\n\r\n\t\t\tAssert.AreEqual(1, list.Count, \"association.elements find\");\r\n\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Close();\r\n\r\n\t\t\ts = OpenSession();\r\n\t\t\ttxn = s.BeginTransaction();\r\n\t\t\tbaz = (Baz)s.CreateQuery(\"select baz from baz in class NHibernate.DomainModel.Baz order by baz\").List()[0];\r\n\t\t\tAssert.AreEqual(4, baz.Customs.Count, \"collection of custom types - added element\");\r\n\t\t\tAssert.IsNotNull(baz.Customs[0], \"collection of custom types - added element\");\r\n\t\t\tAssert.IsNotNull(baz.Components[1].Subcomponent, \"component of component in collection\");\r\n\t\t\tAssert.AreSame(baz, baz.Components[1].Baz);\r\n\r\n\t\t\tIEnumerator fooSetEnumer = baz.FooSet.GetEnumerator();\r\n\t\t\tfooSetEnumer.MoveNext();\r\n\t\t\tAssert.IsTrue(((FooProxy) fooSetEnumer.Current).Key.Equals(foo.Key), \"set of objects\");\r\n\t\t\tAssert.AreEqual(0, baz.StringArray.Length, \"collection removed\");\r\n\t\t\tAssert.AreEqual(\"new value\", baz.StringList[0], \"changed element\");\r\n\t\t\tAssert.AreEqual(0, baz.StringSet.Count, \"replaced set\");\r\n\r\n\t\t\tbaz.StringSet.Add(\"two\");\r\n\t\t\tbaz.StringSet.Add(\"one\");\r\n\t\t\tbaz.Bag.Add(\"three\");\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Close();\r\n\r\n\t\t\ts = OpenSession();\r\n\t\t\ttxn = s.BeginTransaction();\r\n\t\t\tbaz = (Baz)s.CreateQuery(\"select baz from baz in class NHibernate.DomainModel.Baz order by baz\").List()[0];\r\n\t\t\tAssert.AreEqual(2, baz.StringSet.Count);\r\n\t\t\tint index = 0;\r\n\t\t\tforeach (string key in baz.StringSet)\r\n\t\t\t{\r\n\t\t\t\t// h2.0.3 doesn't have this because the Set has a first() and last() method\r\n\t\t\t\tindex++;\r\n\t\t\t\tif (index == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tAssert.AreEqual(\"one\", key);\r\n\t\t\t\t}\r\n\t\t\t\tif (index == 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tAssert.AreEqual(\"two\", key);\r\n\t\t\t\t}\r\n\t\t\t\tif (index > 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tAssert.Fail(\"should not be more than 2 items in StringSet\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tAssert.AreEqual(5, baz.Bag.Count);\r\n\t\t\tbaz.StringSet.Remove(\"two\");\r\n\t\t\tbaz.Bag.Remove(\"duplicate\");\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Close();\r\n\r\n\t\t\ts = OpenSession();\r\n\t\t\ttxn = s.BeginTransaction();\r\n\t\t\tbaz = (Baz)s.Load(typeof(Baz), baz.Code);\r\n\t\t\tBar bar = new Bar();\r\n\t\t\tBar bar2 = new Bar();\r\n\t\t\ts.Save(bar);\r\n\t\t\ts.Save(bar2);\r\n\t\t\tbaz.TopFoos = new HashSet<Bar> { bar, bar2 };\r\n\t\t\tbaz.TopGlarchez = new Hashtable();\r\n\t\t\tGlarchProxy g = new Glarch();\r\n\t\t\ts.Save(g);\r\n\t\t\tbaz.TopGlarchez['G'] = g;\r\n\t\t\tHashtable map = new Hashtable();\r\n\t\t\tmap[bar] = g;\r\n\t\t\tmap[bar2] = g;\r\n\t\t\tbaz.FooToGlarch = map;\r\n\t\t\tmap = new Hashtable();\r\n\t\t\tmap[new FooComponent(\"name\", 123, null, null)] = bar;\r\n\t\t\tmap[new FooComponent(\"nameName\", 12, null, null)] = bar;\r\n\t\t\tbaz.FooComponentToFoo = map;\r\n\t\t\tmap = new Hashtable();\r\n\t\t\tmap[bar] = g;\r\n\t\t\tbaz.GlarchToFoo = map;\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Close();\r\n\r\n\t\t\tusing(s = OpenSession())\r\n\t\t\tusing (txn = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tbaz = (Baz) s.CreateQuery(\"select baz from baz in class NHibernate.DomainModel.Baz order by baz\").List()[0];\r\n\t\t\t\tISession s2 = OpenSession();\r\n\t\t\t\tITransaction txn2 = s2.BeginTransaction();\r\n\t\t\t\tbaz = (Baz) s.CreateQuery(\"select baz from baz in class NHibernate.DomainModel.Baz order by baz\").List()[0];\r\n\t\t\t\tobject o = baz.FooComponentToFoo[new FooComponent(\"name\", 123, null, null)];\r\n\t\t\t\tAssert.IsNotNull(o);\r\n\t\t\t\tAssert.AreEqual(o, baz.FooComponentToFoo[new FooComponent(\"nameName\", 12, null, null)]);\r\n\t\t\t\ttxn2.Commit();\r\n\t\t\t\ts2.Close();\r\n\t\t\t\tAssert.AreEqual(2, baz.TopFoos.Count);\r\n\t\t\t\tAssert.AreEqual(1, baz.TopGlarchez.Count);\r\n\t\t\t\tenumer = baz.TopFoos.GetEnumerator();\r\n\t\t\t\tAssert.IsTrue(enumer.MoveNext());\r\n\t\t\t\tAssert.IsNotNull(enumer.Current);\r\n\t\t\t\tAssert.AreEqual(1, baz.StringSet.Count);\r\n\t\t\t\tAssert.AreEqual(4, baz.Bag.Count);\r\n\t\t\t\tAssert.AreEqual(2, baz.FooToGlarch.Count);\r\n\t\t\t\tAssert.AreEqual(2, baz.FooComponentToFoo.Count);\r\n\t\t\t\tAssert.AreEqual(1, baz.GlarchToFoo.Count);\r\n\r\n\t\t\t\tenumer = baz.FooToGlarch.Keys.GetEnumerator();\r\n\t\t\t\tfor (int i = 0; i < 2; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tenumer.MoveNext();\r\n\t\t\t\t\tAssert.IsTrue(enumer.Current is BarProxy);\r\n\t\t\t\t}\r\n\t\t\t\tenumer = baz.FooComponentToFoo.Keys.GetEnumerator();\r\n\t\t\t\tenumer.MoveNext();\r\n\t\t\t\tFooComponent fooComp = (FooComponent) enumer.Current;\r\n\t\t\t\tAssert.IsTrue((fooComp.Count == 123 && fooComp.Name.Equals(\"name\"))\r\n\t\t\t\t              || (fooComp.Count == 12 && fooComp.Name.Equals(\"nameName\")));\r\n\t\t\t\tAssert.IsTrue(baz.FooComponentToFoo[fooComp] is BarProxy);\r\n\r\n\t\t\t\tGlarch g2 = new Glarch();\r\n\t\t\t\ts.Save(g2);\r\n\t\t\t\tg = (GlarchProxy) baz.TopGlarchez['G'];\r\n\t\t\t\tbaz.TopGlarchez['H'] = g;\r\n\t\t\t\tbaz.TopGlarchez['G'] = g2;\r\n\t\t\t\ttxn.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\r\n\t\t\ts = OpenSession();\r\n\t\t\ttxn = s.BeginTransaction();\r\n\t\t\tbaz = (Baz)s.CreateQuery(\"select baz from baz in class NHibernate.DomainModel.Baz order by baz\").List()[0];\r\n\t\t\tAssert.AreEqual(2, baz.TopGlarchez.Count);\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Disconnect();\r\n\r\n\t\t\t// serialize and then deserialize the session.\r\n\t\t\tStream stream = new MemoryStream();\r\n\t\t\tIFormatter formatter = new BinaryFormatter();\r\n\t\t\tformatter.Serialize(stream, s);\r\n\r\n\t\t\ts.Close();\r\n\r\n\t\t\tstream.Position = 0;\r\n\t\t\ts = (ISession) formatter.Deserialize(stream);\r\n\t\t\tstream.Close();\r\n\r\n\t\t\ts.Reconnect();\r\n\t\t\ttxn = s.BeginTransaction();\r\n\t\t\tbaz = (Baz) s.Load(typeof(Baz), baz.Code);\r\n\t\t\ts.Delete(baz);\r\n\t\t\ts.Delete(baz.TopGlarchez['G']);\r\n\t\t\ts.Delete(baz.TopGlarchez['H']);\r\n\r\n\t\t\tIDbCommand cmd = s.Connection.CreateCommand();\r\n\t\t\ts.Transaction.Enlist(cmd);\r\n\t\t\tcmd.CommandText = \"update \" + Dialect.QuoteForTableName(\"glarchez\") + \" set baz_map_id=null where baz_map_index='a'\";\r\n\t\t\tint rows = cmd.ExecuteNonQuery();\r\n\t\t\tAssert.AreEqual(1, rows);\r\n\t\t\tAssert.AreEqual(2, s.Delete(\"from bar in class NHibernate.DomainModel.Bar\"));\r\n\t\t\tFooProxy[] arr = baz.FooArray;\r\n\t\t\tAssert.AreEqual(4, arr.Length);\r\n\t\t\tAssert.AreEqual(foo.Key, arr[1].Key);\r\n\t\t\tfor (int i = 0; i < arr.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tif (arr[i] != null)\r\n\t\t\t\t{\r\n\t\t\t\t\ts.Delete(arr[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ts.Load(typeof(Qux), (long) 666); //nonexistent\r\n\t\t\t}\r\n\t\t\tcatch (ObjectNotFoundException onfe)\r\n\t\t\t{\r\n\t\t\t\tAssert.IsNotNull(onfe, \"should not find a Qux with id of 666 when Proxies are not implemented.\");\r\n\t\t\t}\r\n\r\n\t\t\tAssert.AreEqual(1, s.Delete(\"from g in class Glarch\"), \"Delete('from g in class Glarch')\");\r\n\t\t\ttxn.Commit();\r\n\t\t\ts.Disconnect();\r\n\r\n\t\t\t// serialize and then deserialize the session.\r\n\t\t\tstream = new MemoryStream();\r\n\t\t\tformatter.Serialize(stream, s);\r\n\r\n\t\t\ts.Close();\r\n\r\n\t\t\tstream.Position = 0;\r\n\t\t\ts = (ISession) formatter.Deserialize(stream);\r\n\t\t\tstream.Close();\r\n\r\n\t\t\tQux nonexistentQux = (Qux) s.Load(typeof(Qux), (long) 666); //nonexistent\r\n\t\t\tAssert.IsNotNull(nonexistentQux, \"even though it doesn't exists should still get a proxy - no db hit.\");\r\n\r\n\t\t\ts.Close();\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Legacy\\FooBarTest.cs",
      "SourceLine": 2628
    }
  ],
  [
    {
      "TypeIdentifier": "CollectionBinder",
      "MethodIdentifier": "BindCollection",
      "SourcesSample": "private void BindCollection(ICollectionPropertiesMapping collectionMapping, Mapping.Collection model, string className,\r\n\t\t\tstring path, System.Type containingType, IDictionary<string, MetaAttribute> inheritedMetas)\r\n\t\t{\r\n\t\t\t// ROLENAME\r\n\t\t\tmodel.Role = path;\r\n\r\n\t\t\tmodel.IsInverse = collectionMapping.Inverse;\r\n\t\t\tmodel.IsMutable = collectionMapping.Mutable;\r\n\t\t\tmodel.IsOptimisticLocked = collectionMapping.OptimisticLock;\r\n\t\t\tmodel.OrderBy = collectionMapping.OrderBy;\r\n\t\t\tmodel.Where = collectionMapping.Where;\r\n\t\t\tif (collectionMapping.BatchSize.HasValue)\r\n\t\t\t\tmodel.BatchSize = collectionMapping.BatchSize.Value;\r\n\r\n\t\t\t// PERSISTER\r\n\t\t\tif (!string.IsNullOrEmpty(collectionMapping.PersisterQualifiedName))\r\n\t\t\t{\r\n\t\t\t\tmodel.CollectionPersisterClass = ClassForNameChecked(collectionMapping.PersisterQualifiedName, mappings,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"could not instantiate collection persister class: {0}\");\r\n\t\t\t}\r\n\r\n\t\t\tif(!string.IsNullOrEmpty(collectionMapping.CollectionType))\r\n\t\t\t{\r\n\t\t\t\tTypeDef typeDef = mappings.GetTypeDef(collectionMapping.CollectionType);\r\n\t\t\t\tif (typeDef != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tmodel.TypeName = typeDef.TypeClass;\r\n\t\t\t\t\tmodel.TypeParameters = typeDef.Parameters;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmodel.TypeName = FullQualifiedClassName(collectionMapping.CollectionType, mappings);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// FETCH STRATEGY\r\n\t\t\tInitOuterJoinFetchSetting(collectionMapping, model);\r\n\r\n\t\t\t// LAZINESS\r\n\t\t\tInitLaziness(collectionMapping, model);\r\n\r\n\t\t\tvar oneToManyMapping = collectionMapping.ElementRelationship as HbmOneToMany;\r\n\t\t\tif (oneToManyMapping != null)\r\n\t\t\t{\r\n\t\t\t\tvar oneToMany = new OneToMany(model.Owner);\r\n\t\t\t\tmodel.Element = oneToMany;\r\n\t\t\t\tBindOneToMany(oneToManyMapping, oneToMany);\r\n\t\t\t\t//we have to set up the table later!! yuck\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t//TABLE\r\n\t\t\t\tstring tableName = !string.IsNullOrEmpty(collectionMapping.Table)\r\n\t\t\t\t\t\t\t\t\t? mappings.NamingStrategy.TableName(collectionMapping.Table)\r\n\t\t\t\t\t\t\t\t\t: mappings.NamingStrategy.PropertyToTableName(className, path);\r\n\r\n\t\t\t\tstring schema = string.IsNullOrEmpty(collectionMapping.Schema) ? mappings.SchemaName : collectionMapping.Schema;\r\n\t\t\t\tstring catalog = string.IsNullOrEmpty(collectionMapping.Catalog) ? mappings.CatalogName : collectionMapping.Catalog;\r\n\r\n\t\t\t\t// TODO NH : add schema-action to the xsd\r\n\t\t\t\tmodel.CollectionTable = mappings.AddTable(schema, catalog, tableName, collectionMapping.Subselect, false, \"all\");\r\n\r\n\t\t\t\tlog.InfoFormat(\"Mapping collection: {0} -> {1}\", model.Role, model.CollectionTable.Name);\r\n\t\t\t}\r\n\r\n\t\t\t//SORT\r\n\t\t\tvar sortedAtt = collectionMapping.Sort;\r\n\t\t\t// unsorted, natural, comparator.class.name\r\n\t\t\tif (string.IsNullOrEmpty(sortedAtt) || sortedAtt.Equals(\"unsorted\"))\r\n\t\t\t\tmodel.IsSorted = false;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmodel.IsSorted = true;\r\n\t\t\t\tif (!sortedAtt.Equals(\"natural\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring comparatorClassName = FullQualifiedClassName(sortedAtt, mappings);\r\n\t\t\t\t\tmodel.ComparerClassName = comparatorClassName;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//ORPHAN DELETE (used for programmer error detection)\r\n\t\t\tvar cascadeAtt = collectionMapping.Cascade;\r\n\t\t\tif (!string.IsNullOrEmpty(cascadeAtt) && cascadeAtt.IndexOf(\"delete-orphan\") >= 0)\r\n\t\t\t\tmodel.HasOrphanDelete = true;\r\n\r\n\t\t\t// GENERIC\r\n\t\t\tbool? isGeneric = collectionMapping.Generic;\r\n\t\t\tSystem.Type collectionType = null;\r\n\t\t\tif (!isGeneric.HasValue && containingType != null)\r\n\t\t\t{\r\n\t\t\t\tcollectionType = GetPropertyType(containingType, collectionMapping.Name, collectionMapping.Access);\r\n\t\t\t\tisGeneric = collectionType.IsGenericType;\r\n\t\t\t}\r\n\r\n\t\t\tmodel.IsGeneric = isGeneric.GetValueOrDefault();\r\n\r\n\t\t\tif (model.IsGeneric)\r\n\t\t\t{\r\n\t\t\t\t// Determine the generic arguments using reflection\r\n\t\t\t\tif (collectionType == null)\r\n\t\t\t\t\tcollectionType = GetPropertyType(containingType, collectionMapping.Name, collectionMapping.Access);\r\n\t\t\t\tSystem.Type[] genericArguments = collectionType.GetGenericArguments();\r\n\t\t\t\tmodel.GenericArguments = genericArguments;\r\n\t\t\t}\r\n\r\n\t\t\t// CUSTOM SQL\r\n\t\t\tHandleCustomSQL(collectionMapping, model);\r\n\t\t\tif (collectionMapping.SqlLoader != null)\r\n\t\t\t\tmodel.LoaderName = collectionMapping.SqlLoader.queryref;\r\n\r\n\t\t\tnew FiltersBinder(model, Mappings).Bind(collectionMapping.Filters);\r\n\r\n\t\t\tvar key = collectionMapping.Key;\r\n\t\t\tif (key != null)\r\n\t\t\t\tmodel.ReferencedPropertyName = key.propertyref;\r\n\t\t}",
      "nStatementSyntax": 14,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\XmlHbmBinding\\CollectionBinder.cs",
      "SourceLine": 141
    },
    {
      "TypeIdentifier": "CollectionBinder",
      "MethodIdentifier": "BindCollectionSecondPass",
      "SourcesSample": "private void BindCollectionSecondPass(ICollectionPropertiesMapping collectionMapping, Mapping.Collection model,\r\n\t\t\tIDictionary<string, PersistentClass> persistentClasses, IDictionary<string, MetaAttribute> inheritedMetas)\r\n\t\t{\r\n\t\t\tif (model.IsOneToMany)\r\n\t\t\t{\r\n\t\t\t\tvar oneToMany = (OneToMany)model.Element;\r\n\t\t\t\tstring associatedEntityName = oneToMany.ReferencedEntityName;\r\n\t\t\t\tPersistentClass persistentClass;\r\n\t\t\t\tif (persistentClasses.TryGetValue(associatedEntityName, out persistentClass) == false)\r\n\t\t\t\t\tthrow new MappingException(\"Association references unmapped class: \" + associatedEntityName);\r\n\t\t\t\toneToMany.AssociatedClass = persistentClass;\r\n\t\t\t\tmodel.CollectionTable = persistentClass.Table;\r\n\t\t\t\tif (model.IsInverse && persistentClass.JoinClosureSpan > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\t// NH: bidirectional one-to-many with a class splitted in more tables; have to find in which table is the inverse side\r\n\t\t\t\t\tforeach (var joined in persistentClass.JoinClosureIterator)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (collectionMapping.Key.Columns.Select(x=> x.name).All(x => joined.Table.ColumnIterator.Select(jc=> jc.Name).Contains(x)))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tmodel.CollectionTable = joined.Table;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (log.IsInfoEnabled)\r\n\t\t\t\t\tlog.Info(\"mapping collection: \" + model.Role + \" -> \" + model.CollectionTable.Name);\r\n\t\t\t}\r\n\r\n\t\t\t//CHECK\r\n\t\t\tif (!string.IsNullOrEmpty(collectionMapping.Check))\r\n\t\t\t{\r\n\t\t\t\tmodel.CollectionTable.AddCheckConstraint(collectionMapping.Check);\r\n\t\t\t}\r\n\t\t\tBindKey(collectionMapping.Key, model);\r\n\r\n\t\t\t//contained elements:\r\n\t\t\tHbmCompositeElement compositeElementMapping;\r\n\t\t\tHbmElement elementMapping;\r\n\t\t\tHbmManyToAny manyToAnyMapping;\r\n\t\t\tHbmManyToMany manyToManyMapping;\r\n\r\n\t\t\tif ((elementMapping = collectionMapping.ElementRelationship as HbmElement) != null)\r\n\t\t\t{\r\n\t\t\t\tBindElement(elementMapping, model);\r\n\t\t\t}\r\n\t\t\telse if ((manyToManyMapping = collectionMapping.ElementRelationship as HbmManyToMany) != null)\r\n\t\t\t{\r\n\t\t\t\tBindManyToMany(manyToManyMapping, model);\r\n\t\t\t}\r\n\t\t\telse if ((compositeElementMapping = collectionMapping.ElementRelationship as HbmCompositeElement) != null)\r\n\t\t\t{\r\n\t\t\t\tBindCompositeElement(compositeElementMapping, model, inheritedMetas);\r\n\t\t\t}\r\n\t\t\telse if ((manyToAnyMapping = collectionMapping.ElementRelationship as HbmManyToAny) != null)\r\n\t\t\t{\r\n\t\t\t\tBindManyToAny(manyToAnyMapping, model);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tBindCache(collectionMapping.Cache, model);\r\n\r\n\t\t\tif (NeedBackref(model))\r\n\t\t\t{\r\n\t\t\t\t// for non-inverse one-to-many, with a not-null fk, add a backref!\r\n\t\t\t\tstring entityName = ((OneToMany)model.Element).ReferencedEntityName;\r\n\t\t\t\tPersistentClass referenced = mappings.GetClass(entityName);\r\n\t\t\t\tvar prop = new Backref();\r\n\t\t\t\tprop.Name = '_' + model.OwnerEntityName + \".\" + collectionMapping.Name + \"Backref\";\r\n\t\t\t\tprop.IsUpdateable = false;\r\n\t\t\t\tprop.IsSelectable = false;\r\n\t\t\t\tprop.CollectionRole = model.Role;\r\n\t\t\t\tprop.EntityName = model.Owner.EntityName;\r\n\t\t\t\tprop.Value = model.Key;\r\n\t\t\t\treferenced.AddProperty(prop);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\XmlHbmBinding\\CollectionBinder.cs",
      "SourceLine": 730
    },
    {
      "TypeIdentifier": "CollectionBinder",
      "MethodIdentifier": "BindMapSecondPass",
      "SourcesSample": "private void BindMapSecondPass(HbmMap mapMapping, Map model,\r\n\t\t\tIDictionary<string, PersistentClass> persistentClasses, IDictionary<string, MetaAttribute> inheritedMetas)\r\n\t\t{\r\n\t\t\tBindCollectionSecondPass(mapMapping, model, persistentClasses, inheritedMetas);\r\n\r\n\t\t\tHbmIndex indexMapping;\r\n\t\t\tHbmMapKey mapKeyMapping;\r\n\r\n\t\t\tHbmIndexManyToMany indexManyToManyMapping;\r\n\t\t\tHbmMapKeyManyToMany mapKeyManyToManyMapping;\r\n\r\n\t\t\tHbmCompositeIndex compositeIndexMapping;\r\n\t\t\tHbmCompositeMapKey compositeMapKeyMapping;\r\n\r\n\t\t\tHbmIndexManyToAny indexManyToAnyMapping;\r\n\r\n\t\t\tif ((indexMapping = mapMapping.Item as HbmIndex) != null)\r\n\t\t\t{\r\n\t\t\t\tvar value = new SimpleValue(model.CollectionTable);\r\n\t\t\t\tnew ValuePropertyBinder(value, Mappings).BindSimpleValue(indexMapping, IndexedCollection.DefaultIndexColumnName,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t model.IsOneToMany);\r\n\t\t\t\tmodel.Index = value;\r\n\t\t\t\tif (string.IsNullOrEmpty(model.Index.TypeName))\r\n\t\t\t\t\tthrow new MappingException(\"map index element must specify a type: \" + model.Role);\r\n\t\t\t}\r\n\t\t\telse if ((mapKeyMapping = mapMapping.Item as HbmMapKey) != null)\r\n\t\t\t{\r\n\t\t\t\tvar value = new SimpleValue(model.CollectionTable);\r\n\t\t\t\tnew ValuePropertyBinder(value, Mappings).BindSimpleValue(mapKeyMapping, IndexedCollection.DefaultIndexColumnName,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t model.IsOneToMany);\r\n\t\t\t\tmodel.Index = value;\r\n\t\t\t\tif (string.IsNullOrEmpty(model.Index.TypeName))\r\n\t\t\t\t\tthrow new MappingException(\"map index element must specify a type: \" + model.Role);\r\n\t\t\t}\r\n\t\t\telse if ((indexManyToManyMapping = mapMapping.Item as HbmIndexManyToMany) != null)\r\n\t\t\t{\r\n\t\t\t\tvar manyToOne = new ManyToOne(model.CollectionTable);\r\n\t\t\t\tBindIndexManyToMany(indexManyToManyMapping, manyToOne, IndexedCollection.DefaultIndexColumnName, model.IsOneToMany);\r\n\t\t\t\tmodel.Index = manyToOne;\r\n\t\t\t}\r\n\t\t\telse if ((mapKeyManyToManyMapping = mapMapping.Item as HbmMapKeyManyToMany) != null)\r\n\t\t\t{\r\n\t\t\t\tvar manyToOne = new ManyToOne(model.CollectionTable);\r\n\t\t\t\tBindMapKeyManyToMany(mapKeyManyToManyMapping, manyToOne, IndexedCollection.DefaultIndexColumnName, model.IsOneToMany);\r\n\t\t\t\tmodel.Index = manyToOne;\r\n\t\t\t}\r\n\t\t\telse if ((compositeIndexMapping = mapMapping.Item as HbmCompositeIndex) != null)\r\n\t\t\t{\r\n\t\t\t\tvar component = new Component(model);\r\n\t\t\t\tBindComponent(compositeIndexMapping, component, null, null, model.Role + \".index\", model.IsOneToMany, inheritedMetas);\r\n\t\t\t\tmodel.Index = component;\r\n\t\t\t}\r\n\t\t\telse if ((compositeMapKeyMapping = mapMapping.Item as HbmCompositeMapKey) != null)\r\n\t\t\t{\r\n\t\t\t\tvar component = new Component(model);\r\n\t\t\t\tBindComponent(compositeMapKeyMapping, component, null, null, model.Role + \".index\", model.IsOneToMany, inheritedMetas);\r\n\t\t\t\tmodel.Index = component;\r\n\t\t\t}\r\n\t\t\telse if ((indexManyToAnyMapping = mapMapping.Item as HbmIndexManyToAny) != null)\r\n\t\t\t{\r\n\t\t\t\tvar any = new Any(model.CollectionTable);\r\n\t\t\t\tBindIndexManyToAny(indexManyToAnyMapping, any, model.IsOneToMany);\r\n\t\t\t\tmodel.Index = any;\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tbool indexIsFormula = model.Index.ColumnIterator.Any(x=> x.IsFormula);\r\n\t\t\tif (NeedBackref(model) && !indexIsFormula)\r\n\t\t\t{\r\n\t\t\t\tstring entityName = ((OneToMany)model.Element).ReferencedEntityName;\r\n\t\t\t\tPersistentClass referenced = mappings.GetClass(entityName);\r\n\t\t\t\tvar ib = new IndexBackref();\r\n\t\t\t\tib.Name = '_' + model.OwnerEntityName + \".\" + mapMapping.Name + \"IndexBackref\";\r\n\t\t\t\tib.IsUpdateable = false;\r\n\t\t\t\tib.IsSelectable = false;\r\n\t\t\t\tib.CollectionRole = model.Role;\r\n\t\t\t\tib.EntityName = model.Owner.EntityName;\r\n\t\t\t\tib.Value = model.Index;\r\n\t\t\t\treferenced.AddProperty(ib);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\XmlHbmBinding\\CollectionBinder.cs",
      "SourceLine": 615
    }
  ],
  [
    {
      "TypeIdentifier": "ComponentTest",
      "MethodIdentifier": "TestMergeComponent",
      "SourcesSample": "[Test]\r\n\t\tpublic void TestMergeComponent() \r\n\t\t{\r\n\t\t\tEmployee emp = null;\r\n\t\t\tIEnumerator<Employee> enumerator = null;\r\n\t\t\t\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = new Employee();\r\n\t\t\t\temp.HireDate = new DateTime(1999, 12, 31);\r\n\t\t\t\temp.Person = new Person();\r\n\t\t\t\temp.Person.Name = \"steve\";\r\n\t\t\t\temp.Person.Dob = new DateTime(1999, 12, 31);\r\n\t\t\t\ts.Persist(emp);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Get(typeof(Employee), emp.Id);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tAssert.That(emp.OptionalComponent, Is.Null);\r\n\t\t\t\r\n\t\t\temp.OptionalComponent = new OptionalComponent();\r\n\t\t\temp.OptionalComponent.Value1 = \"emp-value1\";\r\n\t\t\temp.OptionalComponent.Value2 = \"emp-value2\";\r\n\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Merge(emp);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Get(typeof(Employee), emp.Id);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tAssert.That(emp.OptionalComponent.Value1, Is.EqualTo(\"emp-value1\"));\r\n\t\t\tAssert.That(emp.OptionalComponent.Value2, Is.EqualTo(\"emp-value2\"));\r\n\r\n\t\t\temp.OptionalComponent.Value1 = null;\r\n\t\t\temp.OptionalComponent.Value2 = null;\r\n\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Merge(emp);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Get(typeof(Employee), emp.Id);\r\n\t\t\t\tNHibernateUtil.Initialize(emp.DirectReports);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tAssert.That(emp.OptionalComponent, Is.Null);\r\n\t\r\n\t\t\tEmployee emp1 = new Employee();\r\n\t\t\temp1.HireDate = new DateTime(1999, 12, 31);\r\n\t\t\temp1.Person = new Person();\r\n\t\t\temp1.Person.Name = \"bozo\";\r\n\t\t\temp1.Person.Dob = new DateTime(1999, 12, 31);\r\n\t\t\temp.DirectReports.Add(emp1);\r\n\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Merge(emp);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Get(typeof(Employee), emp.Id);\r\n\t\t\t\tNHibernateUtil.Initialize(emp.DirectReports);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tAssert.That(emp.DirectReports.Count, Is.EqualTo(1));\r\n\t\t\t\r\n\t\t\tenumerator = emp.DirectReports.GetEnumerator();\r\n\t\t\tenumerator.MoveNext();\r\n\t\t\temp1 = (Employee)enumerator.Current;\r\n\t\t\tAssert.That(emp1.OptionalComponent, Is.Null);\r\n\t\t\t\r\n\t\t\temp1.OptionalComponent = new OptionalComponent();\r\n\t\t\temp1.OptionalComponent.Value1 = \"emp1-value1\";\r\n\t\t\temp1.OptionalComponent.Value2 = \"emp1-value2\";\r\n\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Merge(emp);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Get(typeof(Employee), emp.Id);\r\n\t\t\t\tNHibernateUtil.Initialize(emp.DirectReports);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tAssert.That(emp.DirectReports.Count, Is.EqualTo(1));\r\n\t\t\t\r\n\t\t\tenumerator = emp.DirectReports.GetEnumerator();\r\n\t\t\tenumerator.MoveNext();\r\n\t\t\temp1 = (Employee)enumerator.Current;\r\n\t\t\tAssert.That(emp1.OptionalComponent.Value1, Is.EqualTo(\"emp1-value1\"));\r\n\t\t\tAssert.That(emp1.OptionalComponent.Value2, Is.EqualTo(\"emp1-value2\"));\r\n\t\t\t\r\n\t\t\temp1.OptionalComponent.Value1 = null;\r\n\t\t\temp1.OptionalComponent.Value2 = null;\r\n\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Merge(emp);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\temp = (Employee)s.Get(typeof(Employee), emp.Id);\r\n\t\t\t\tNHibernateUtil.Initialize(emp.DirectReports);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\r\n\t\t\tAssert.That(emp.DirectReports.Count, Is.EqualTo(1));\r\n\t\t\t\r\n\t\t\tenumerator = emp.DirectReports.GetEnumerator();\r\n\t\t\tenumerator.MoveNext();\r\n\t\t\temp1 = (Employee)enumerator.Current;\r\n\t\t\tAssert.That(emp1.OptionalComponent, Is.Null);\r\n\t\r\n\t\t\tusing (ISession s = sessions.OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.Delete( emp );\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 27,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Component\\Basic\\ComponentTest.cs",
      "SourceLine": 267
    }
  ],
  [
    {
      "TypeIdentifier": "ExpressionProcessor",
      "MethodIdentifier": "FindMemberExpression",
      "SourcesSample": "public static string FindMemberExpression(Expression expression)\r\n\t\t{\r\n\t\t\tif (expression is MemberExpression)\r\n\t\t\t{\r\n\t\t\t\tMemberExpression memberExpression = (MemberExpression)expression;\r\n\r\n\t\t\t\tif (memberExpression.Expression.NodeType == ExpressionType.MemberAccess\r\n\t\t\t\t\t|| memberExpression.Expression.NodeType == ExpressionType.Call)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (memberExpression.Member.DeclaringType.IsNullable())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// it's a Nullable<T>, so ignore any .Value\r\n\t\t\t\t\t\tif (memberExpression.Member.Name == \"Value\")\r\n\t\t\t\t\t\t\treturn FindMemberExpression(memberExpression.Expression);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn FindMemberExpression(memberExpression.Expression) + \".\" + memberExpression.Member.Name;\r\n\t\t\t\t}\r\n\t\t\t\telse if (IsConversion(memberExpression.Expression.NodeType))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (FindMemberExpression(memberExpression.Expression) + \".\" + memberExpression.Member.Name).TrimStart('.');\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\treturn memberExpression.Member.Name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (expression is UnaryExpression)\r\n\t\t\t{\r\n\t\t\t\tUnaryExpression unaryExpression = (UnaryExpression)expression;\r\n\r\n\t\t\t\tif (!IsConversion(unaryExpression.NodeType))\r\n\t\t\t\t\tthrow new Exception(\"Cannot interpret member from \" + expression.ToString());\r\n\r\n\t\t\t\treturn FindMemberExpression(unaryExpression.Operand);\r\n\t\t\t}\r\n\r\n\t\t\tif (expression is MethodCallExpression)\r\n\t\t\t{\r\n\t\t\t\tMethodCallExpression methodCallExpression = (MethodCallExpression)expression;\r\n\r\n\t\t\t\tif (methodCallExpression.Method.Name == \"GetType\")\r\n\t\t\t\t\treturn ClassMember(methodCallExpression.Object);\r\n\r\n\t\t\t\tif (methodCallExpression.Method.Name == \"get_Item\")\r\n\t\t\t\t\treturn FindMemberExpression(methodCallExpression.Object);\r\n\r\n\t\t\t\tif (methodCallExpression.Method.Name == \"First\")\r\n\t\t\t\t\treturn FindMemberExpression(methodCallExpression.Arguments[0]);\r\n\r\n\t\t\t\tthrow new Exception(\"Unrecognised method call in expression \" + expression.ToString());\r\n\t\t\t}\r\n\r\n\t\t\tif (expression is ParameterExpression)\r\n\t\t\t\treturn \"\";\r\n\r\n\t\t\tthrow new Exception(\"Could not determine member from \" + expression.ToString());\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Impl\\ExpressionProcessor.cs",
      "SourceLine": 267
    },
    {
      "TypeIdentifier": "ExpressionProcessor",
      "MethodIdentifier": "IsMemberExpression",
      "SourcesSample": "private static bool IsMemberExpression(Expression expression)\r\n\t\t{\r\n\t\t\tif (expression is ParameterExpression)\r\n\t\t\t\treturn true;\r\n\r\n\t\t\tif (expression is MemberExpression)\r\n\t\t\t{\r\n\t\t\t\tMemberExpression memberExpression = (MemberExpression)expression;\r\n\r\n\t\t\t\tif (memberExpression.Expression == null)\r\n\t\t\t\t\treturn false;  // it's a member of a static class\r\n\r\n\t\t\t\tif (IsMemberExpression(memberExpression.Expression))\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t// if the member has a null value, it was an alias\r\n\t\t\t\treturn EvaluatesToNull(memberExpression.Expression);\r\n\t\t\t}\r\n\r\n\t\t\tif (expression is UnaryExpression)\r\n\t\t\t{\r\n\t\t\t\tUnaryExpression unaryExpression = (UnaryExpression)expression;\r\n\r\n\t\t\t\tif (!IsConversion(unaryExpression.NodeType))\r\n\t\t\t\t\tthrow new Exception(\"Cannot interpret member from \" + expression.ToString());\r\n\r\n\t\t\t\treturn IsMemberExpression(unaryExpression.Operand);\r\n\t\t\t}\r\n\r\n\t\t\tvar methodCallExpression = expression as MethodCallExpression;\r\n\t\t\tif (methodCallExpression != null)\r\n\t\t\t{\r\n\t\t\t\tstring signature = Signature(methodCallExpression.Method);\r\n\t\t\t\tif (_customProjectionProcessors.ContainsKey(signature))\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\tif (methodCallExpression.Method.Name == \"First\")\r\n\t\t\t\t{\r\n\t\t\t\t\tif (IsMemberExpression(methodCallExpression.Arguments[0]))\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\treturn EvaluatesToNull(methodCallExpression.Arguments[0]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (methodCallExpression.Method.Name == \"GetType\"\r\n\t\t\t\t\t|| methodCallExpression.Method.Name == \"get_Item\")\r\n\t\t\t\t{\r\n\t\t\t\t\tif (IsMemberExpression(methodCallExpression.Object))\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\treturn EvaluatesToNull(methodCallExpression.Object);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Impl\\ExpressionProcessor.cs",
      "SourceLine": 390
    }
  ],
  [
    {
      "TypeIdentifier": "ModelMapper",
      "MethodIdentifier": "MapProperties",
      "SourcesSample": "private void MapProperties(System.Type propertiesContainerType, IEnumerable<MemberInfo> propertiesToMap,\r\n\t\t                           IPropertyContainerMapper propertiesContainer, PropertyPath path)\r\n\t\t{\r\n\t\t\tforeach (var property in propertiesToMap)\r\n\t\t\t{\r\n\t\t\t\tMemberInfo member = property;\r\n\t\t\t\tSystem.Type propertyType = property.GetPropertyOrFieldType();\r\n\t\t\t\tvar memberPath = new PropertyPath(path, member);\r\n\t\t\t\tif (modelInspector.IsProperty(member))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapProperty(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsAny(member))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapAny(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsManyToOne(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapManyToOne(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsOneToOne(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapOneToOne(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsDynamicComponent(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapDynamicComponent(member, memberPath, propertyType, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsSet(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapSet(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsDictionary(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapDictionary(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsArray(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new NotSupportedException();\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsList(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapList(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsIdBag(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapIdBag(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsBag(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapBag(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsComponent(propertyType))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapComponent(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tMapProperty(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 14,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Mapping\\ByCode\\ModelMapper.cs",
      "SourceLine": 965
    },
    {
      "TypeIdentifier": "ModelMapper",
      "MethodIdentifier": "MapSplitProperties",
      "SourcesSample": "private void MapSplitProperties(System.Type propertiesContainerType, IEnumerable<MemberInfo> propertiesToMap, IJoinMapper propertiesContainer)\r\n\t\t{\r\n\t\t\tforeach (var property in propertiesToMap)\r\n\t\t\t{\r\n\t\t\t\tMemberInfo member = property;\r\n\t\t\t\tSystem.Type propertyType = property.GetPropertyOrFieldType();\r\n\t\t\t\tvar memberPath = new PropertyPath(null, member);\r\n\t\t\t\tif (modelInspector.IsProperty(member))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapProperty(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsAny(member))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapAny(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsManyToOne(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapManyToOne(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsSet(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapSet(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsDictionary(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapDictionary(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsArray(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new NotSupportedException();\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsList(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapList(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsIdBag(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapIdBag(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsBag(property))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapBag(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse if (modelInspector.IsComponent(propertyType))\r\n\t\t\t\t{\r\n\t\t\t\t\tMapComponent(member, memberPath, propertyType, propertiesContainer, propertiesContainerType);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tMapProperty(member, memberPath, propertiesContainer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Mapping\\ByCode\\ModelMapper.cs",
      "SourceLine": 819
    }
  ],
  [
    {
      "TypeIdentifier": "StatefulPersistenceContext",
      "MethodIdentifier": "GetOwnerId",
      "SourcesSample": "public object GetOwnerId(string entityName, string propertyName, object childEntity, IDictionary mergeMap)\r\n\t\t{\r\n\t\t\tstring collectionRole = entityName + '.' + propertyName;\r\n\t\t\tIEntityPersister persister = session.Factory.GetEntityPersister(entityName);\r\n\t\t\tICollectionPersister collectionPersister = session.Factory.GetCollectionPersister(collectionRole);\r\n\r\n\t\t\tobject parent = parentsByChild[childEntity];\r\n\t\t\tif (parent != null)\r\n\t\t\t{\r\n\t\t\t\tvar entityEntry = (EntityEntry) entityEntries[parent];\r\n\t\t\t\t//there maybe more than one parent, filter by type\r\n\t\t\t\tif (persister.IsSubclassEntityName(entityEntry.EntityName) && IsFoundInParent(propertyName, childEntity, persister, collectionPersister, parent))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn GetEntry(parent).Id;\r\n\t\t\t\t}\r\n\t\t\t\tparentsByChild.Remove(childEntity); // remove wrong entry\r\n\t\t\t}\r\n\r\n\t\t\t// iterate all the entities currently associated with the persistence context.\r\n\t\t\tforeach (DictionaryEntry entry in entityEntries)\r\n\t\t\t{\r\n\t\t\t\tvar entityEntry = (EntityEntry) entry.Value;\r\n\t\t\t\t// does this entity entry pertain to the entity persister in which we are interested (owner)?\r\n\t\t\t\tif (persister.IsSubclassEntityName(entityEntry.EntityName))\r\n\t\t\t\t{\r\n\t\t\t\t\tobject entityEntryInstance = entry.Key;\r\n\r\n\t\t\t\t\t//check if the managed object is the parent\r\n\t\t\t\t\tbool found = IsFoundInParent(propertyName, childEntity, persister, collectionPersister, entityEntryInstance);\r\n\r\n\t\t\t\t\tif (!found && mergeMap != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//check if the detached object being merged is the parent\r\n\t\t\t\t\t\tobject unmergedInstance = mergeMap[entityEntryInstance];\r\n\t\t\t\t\t\tobject unmergedChild = mergeMap[childEntity];\r\n\t\t\t\t\t\tif (unmergedInstance != null && unmergedChild != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tfound = IsFoundInParent(propertyName, unmergedChild, persister, collectionPersister, unmergedInstance);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (found)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn entityEntry.Id;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if we get here, it is possible that we have a proxy 'in the way' of the merge map resolution...\r\n\t\t\t// \t\tNOTE: decided to put this here rather than in the above loop as I was nervous about the performance\r\n\t\t\t//\t\tof the loop-in-loop especially considering this is far more likely the 'edge case'\r\n\t\t\tif (mergeMap != null)\r\n\t\t\t{\r\n\t\t\t\tforeach (DictionaryEntry mergeMapEntry in mergeMap)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar proxy = mergeMapEntry.Key as INHibernateProxy;\r\n\t\t\t\t\tif (proxy != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (persister.IsSubclassEntityName(proxy.HibernateLazyInitializer.EntityName))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbool found = IsFoundInParent(propertyName, childEntity, persister, collectionPersister, mergeMap[proxy]);\r\n\t\t\t\t\t\t\tif (!found)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tfound = IsFoundInParent(propertyName, mergeMap[childEntity], persister, collectionPersister, mergeMap[proxy]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (found)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn proxy.HibernateLazyInitializer.Identifier;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t}",
      "nStatementSyntax": 14,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Engine\\StatefulPersistenceContext.cs",
      "SourceLine": 1092
    },
    {
      "TypeIdentifier": "StatefulPersistenceContext",
      "MethodIdentifier": "GetIndexInOwner",
      "SourcesSample": "public object GetIndexInOwner(string entity, string property, object childEntity, IDictionary mergeMap)\r\n\t\t{\r\n\t\t\tIEntityPersister persister = session.Factory.GetEntityPersister(entity);\r\n\t\t\tICollectionPersister cp = session.Factory.GetCollectionPersister(entity + '.' + property);\r\n\r\n\t\t\t// try cache lookup first\r\n\t\t\tobject parent = parentsByChild[childEntity];\r\n\t\t\tif (parent != null)\r\n\t\t\t{\r\n\t\t\t\tvar entityEntry = (EntityEntry) entityEntries[parent];\r\n\t\t\t\t//there maybe more than one parent, filter by type\r\n\t\t\t\tif (persister.IsSubclassEntityName(entityEntry.EntityName))\r\n\t\t\t\t{\r\n\t\t\t\t\tobject index = GetIndexInParent(property, childEntity, persister, cp, parent);\r\n\r\n\t\t\t\t\tif (index == null && mergeMap != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobject unmergedInstance = mergeMap[parent];\r\n\t\t\t\t\t\tobject unmergedChild = mergeMap[childEntity];\r\n\t\t\t\t\t\tif (unmergedInstance != null && unmergedChild != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tindex = GetIndexInParent(property, unmergedChild, persister, cp, unmergedInstance);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (index != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn index;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tparentsByChild.Remove(childEntity); // remove wrong entry\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Not found in cache, proceed\r\n\t\t\tforeach (DictionaryEntry me in entityEntries)\r\n\t\t\t{\r\n\t\t\t\tvar ee = (EntityEntry) me.Value;\r\n\t\t\t\tif (persister.IsSubclassEntityName(ee.EntityName))\r\n\t\t\t\t{\r\n\t\t\t\t\tobject instance = me.Key;\r\n\t\t\t\t\tobject index = GetIndexInParent(property, childEntity, persister, cp, instance);\r\n\r\n\t\t\t\t\tif (index == null && mergeMap != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobject unmergedInstance = mergeMap[instance];\r\n\t\t\t\t\t\tobject unmergedChild = mergeMap[childEntity];\r\n\t\t\t\t\t\tif (unmergedInstance != null && unmergedChild != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tindex = GetIndexInParent(property, unmergedChild, persister, cp, unmergedInstance);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (index != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn index;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Engine\\StatefulPersistenceContext.cs",
      "SourceLine": 1178
    }
  ],
  [
    {
      "TypeIdentifier": "WhereJoinDetector",
      "MethodIdentifier": "VisitBinaryExpression",
      "SourcesSample": "protected override Expression VisitBinaryExpression(BinaryExpression expression)\r\n\t\t{\r\n\t\t\tvar result = base.VisitBinaryExpression(expression);\r\n\r\n\t\t\tif (expression.NodeType == ExpressionType.AndAlso)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.AndAlso(b));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.OrElse)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.OrElse(b));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.NotEqual && IsNullConstantExpression(expression.Right))\r\n\t\t\t{\r\n\t\t\t\t// Discard result from right null.  Left is visited first, so it's below right on the stack.\r\n\t\t\t\t_values.Pop();\r\n\r\n\t\t\t\tHandleUnaryOperation(pvs => pvs.IsNotNull());\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.NotEqual && IsNullConstantExpression(expression.Left))\r\n\t\t\t{\r\n\t\t\t\t// Discard result from left null.\r\n\t\t\t\tvar right = _values.Pop();\r\n\t\t\t\t_values.Pop(); // Discard left.\r\n\t\t\t\t_values.Push(right);\r\n\r\n\t\t\t\tHandleUnaryOperation(pvs => pvs.IsNotNull());\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Equal && IsNullConstantExpression(expression.Right))\r\n\t\t\t{\r\n\t\t\t\t// Discard result from right null.  Left is visited first, so it's below right on the stack.\r\n\t\t\t\t_values.Pop();\r\n\r\n\t\t\t\tHandleUnaryOperation(pvs => pvs.IsNull());\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Equal && IsNullConstantExpression(expression.Left))\r\n\t\t\t{\r\n\t\t\t\t// Discard result from left null.\r\n\t\t\t\tvar right = _values.Pop();\r\n\t\t\t\t_values.Pop(); // Discard left.\r\n\t\t\t\t_values.Push(right);\r\n\r\n\t\t\t\tHandleUnaryOperation(pvs => pvs.IsNull());\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Coalesce)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Coalesce(b));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Add || expression.NodeType == ExpressionType.AddChecked)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Add(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Divide)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Divide(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Modulo)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Modulo(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Multiply || expression.NodeType == ExpressionType.MultiplyChecked)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Multiply(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Power)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Power(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Subtract || expression.NodeType == ExpressionType.SubtractChecked)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Subtract(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.And)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.And(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Or)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Or(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.ExclusiveOr)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.ExclusiveOr(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.LeftShift)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.LeftShift(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.RightShift)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.RightShift(b, expression.Type));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.Equal)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.Equal(b));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.NotEqual)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.NotEqual(b));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.GreaterThanOrEqual)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.GreaterThanOrEqual(b));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.GreaterThan)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.GreaterThan(b));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.LessThan)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.LessThan(b));\r\n\t\t\t}\r\n\t\t\telse if (expression.NodeType == ExpressionType.LessThanOrEqual)\r\n\t\t\t{\r\n\t\t\t\tHandleBinaryOperation((a, b) => a.LessThanOrEqual(b));\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t}",
      "nStatementSyntax": 25,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Linq\\Visitors\\WhereJoinDetector.cs",
      "SourceLine": 121
    }
  ],
  [
    {
      "TypeIdentifier": "SettingsFactory",
      "MethodIdentifier": "BuildSettings",
      "SourcesSample": "public Settings BuildSettings(IDictionary<string, string> properties)\n\t\t{\n\t\t\tSettings settings = new Settings();\n\n\t\t\tDialect.Dialect dialect;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdialect = Dialect.Dialect.GetDialect(properties);\n\t\t\t\tDictionary<string, string> temp = new Dictionary<string, string>();\n\n\t\t\t\tforeach (KeyValuePair<string, string> de in dialect.DefaultProperties)\n\t\t\t\t{\n\t\t\t\t\ttemp[de.Key] = de.Value;\n\t\t\t\t}\n\t\t\t\tforeach (KeyValuePair<string, string> de in properties)\n\t\t\t\t{\n\t\t\t\t\ttemp[de.Key] = de.Value;\n\t\t\t\t}\n\t\t\t\tproperties = temp;\n\t\t\t}\n\t\t\tcatch (HibernateException he)\n\t\t\t{\n\t\t\t\tlog.Warn(\"No dialect set - using GenericDialect: \" + he.Message);\n\t\t\t\tdialect = new GenericDialect();\n\t\t\t}\n\t\t\tsettings.Dialect = dialect;\n\n\t\t\tsettings.LinqToHqlGeneratorsRegistry = LinqToHqlGeneratorsRegistryFactory.CreateGeneratorsRegistry(properties);\n\n\t\t\t#region SQL Exception converter\n\n\t\t\tISQLExceptionConverter sqlExceptionConverter;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsqlExceptionConverter = SQLExceptionConverterFactory.BuildSQLExceptionConverter(dialect, properties);\n\t\t\t}\n\t\t\tcatch (HibernateException)\n\t\t\t{\n\t\t\t\tlog.Warn(\"Error building SQLExceptionConverter; using minimal converter\");\n\t\t\t\tsqlExceptionConverter = SQLExceptionConverterFactory.BuildMinimalSQLExceptionConverter();\n\t\t\t}\n\t\t\tsettings.SqlExceptionConverter = sqlExceptionConverter;\n\n\t\t\t#endregion\n\n\t\t\tbool comments = PropertiesHelper.GetBoolean(Environment.UseSqlComments, properties);\n\t\t\tlog.Info(\"Generate SQL with comments: \" + EnabledDisabled(comments));\n\t\t\tsettings.IsCommentsEnabled = comments;\n\n\t\t\tint maxFetchDepth = PropertiesHelper.GetInt32(Environment.MaxFetchDepth, properties, -1);\n\t\t\tif (maxFetchDepth != -1)\n\t\t\t{\n\t\t\t\tlog.Info(\"Maximum outer join fetch depth: \" + maxFetchDepth);\n\t\t\t}\n\n\t\t\tIConnectionProvider connectionProvider = ConnectionProviderFactory.NewConnectionProvider(properties);\n\t\t\tITransactionFactory transactionFactory = CreateTransactionFactory(properties);\n\t\t\t// TransactionManagerLookup transactionManagerLookup = TransactionManagerLookupFactory.GetTransactionManagerLookup( properties );\n\n\t\t\t// Not ported: useGetGeneratedKeys, useScrollableResultSets\n\n\t\t\tbool useMinimalPuts = PropertiesHelper.GetBoolean(Environment.UseMinimalPuts, properties, false);\n\t\t\tlog.Info(\"Optimize cache for minimal puts: \" + useMinimalPuts);\n\n\t\t\tstring releaseModeName = PropertiesHelper.GetString(Environment.ReleaseConnections, properties, \"auto\");\n\t\t\tlog.Info(\"Connection release mode: \" + releaseModeName);\n\t\t\tConnectionReleaseMode releaseMode;\n\t\t\tif (\"auto\".Equals(releaseModeName))\n\t\t\t{\n\t\t\t\treleaseMode = ConnectionReleaseMode.AfterTransaction; //transactionFactory.DefaultReleaseMode;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treleaseMode = ConnectionReleaseModeParser.Convert(releaseModeName);\n\t\t\t}\n\t\t\tsettings.ConnectionReleaseMode = releaseMode;\n\n\t\t\tstring defaultSchema = PropertiesHelper.GetString(Environment.DefaultSchema, properties, null);\n\t\t\tstring defaultCatalog = PropertiesHelper.GetString(Environment.DefaultCatalog, properties, null);\n\t\t\tif (defaultSchema != null)\n\t\t\t\tlog.Info(\"Default schema: \" + defaultSchema);\n\t\t\tif (defaultCatalog != null)\n\t\t\t\tlog.Info(\"Default catalog: \" + defaultCatalog);\n\t\t\tsettings.DefaultSchemaName = defaultSchema;\n\t\t\tsettings.DefaultCatalogName = defaultCatalog;\n\n\t\t\tint batchFetchSize = PropertiesHelper.GetInt32(Environment.DefaultBatchFetchSize, properties, 1);\n\t\t\tlog.Info(\"Default batch fetch size: \" + batchFetchSize);\n\t\t\tsettings.DefaultBatchFetchSize = batchFetchSize;\n\n\t\t\t//Statistics and logging:\n\n\t\t\tbool showSql = PropertiesHelper.GetBoolean(Environment.ShowSql, properties, false);\n\t\t\tif (showSql)\n\t\t\t{\n\t\t\t\tlog.Info(\"echoing all SQL to stdout\");\n\t\t\t}\n\t\t\tbool formatSql = PropertiesHelper.GetBoolean(Environment.FormatSql, properties);\n\n\t\t\tbool useStatistics = PropertiesHelper.GetBoolean(Environment.GenerateStatistics, properties);\n\t\t\tlog.Info(\"Statistics: \" + EnabledDisabled(useStatistics));\n\t\t\tsettings.IsStatisticsEnabled = useStatistics;\n\n\t\t\tbool useIdentifierRollback = PropertiesHelper.GetBoolean(Environment.UseIdentifierRollBack, properties);\n\t\t\tlog.Info(\"Deleted entity synthetic identifier rollback: \" + EnabledDisabled(useIdentifierRollback));\n\t\t\tsettings.IsIdentifierRollbackEnabled = useIdentifierRollback;\n\n\t\t\t// queries:\n\n\t\t\tsettings.QueryTranslatorFactory = CreateQueryTranslatorFactory(properties);\n\n\t\t\tIDictionary<string, string> querySubstitutions = PropertiesHelper.ToDictionary(Environment.QuerySubstitutions,\n\t\t\t                                                                               \" ,=;:\\n\\t\\r\\f\", properties);\n\t\t\tif (log.IsInfoEnabled)\n\t\t\t{\n\t\t\t\tlog.Info(\"Query language substitutions: \" + CollectionPrinter.ToString((IDictionary) querySubstitutions));\n\t\t\t}\n\n\t\t\t#region Hbm2DDL\n\t\t\tstring autoSchemaExport = PropertiesHelper.GetString(Environment.Hbm2ddlAuto, properties, null);\n\t\t\tif (SchemaAutoAction.Update == autoSchemaExport)\n\t\t\t{\n\t\t\t\tsettings.IsAutoUpdateSchema = true;\n\t\t\t}\n\t\t\telse if (SchemaAutoAction.Create == autoSchemaExport)\n\t\t\t{\n\t\t\t\tsettings.IsAutoCreateSchema = true;\n\t\t\t}\n\t\t\telse if (SchemaAutoAction.Recreate == autoSchemaExport)\n\t\t\t{\n\t\t\t\tsettings.IsAutoCreateSchema = true;\n\t\t\t\tsettings.IsAutoDropSchema = true;\n\t\t\t}\n\t\t\telse if (SchemaAutoAction.Validate == autoSchemaExport)\n\t\t\t{\n\t\t\t\tsettings.IsAutoValidateSchema = true;\n\t\t\t}\n\n\t\t\tstring autoKeyWordsImport = PropertiesHelper.GetString(Environment.Hbm2ddlKeyWords, properties, \"not-defined\");\n\t\t\tautoKeyWordsImport = autoKeyWordsImport.ToLowerInvariant();\n\t\t\tif (autoKeyWordsImport == Hbm2DDLKeyWords.None)\n\t\t\t{\n\t\t\t\tsettings.IsKeywordsImportEnabled = false;\n\t\t\t\tsettings.IsAutoQuoteEnabled = false;\n\t\t\t}\n\t\t\telse if (autoKeyWordsImport == Hbm2DDLKeyWords.Keywords)\n\t\t\t{\n\t\t\t\tsettings.IsKeywordsImportEnabled = true;\n\t\t\t}\n\t\t\telse if (autoKeyWordsImport == Hbm2DDLKeyWords.AutoQuote)\n\t\t\t{\n\t\t\t\tsettings.IsKeywordsImportEnabled = true;\n\t\t\t\tsettings.IsAutoQuoteEnabled = true;\n\t\t\t}\n\t\t\telse if (autoKeyWordsImport == \"not-defined\")\n\t\t\t{\n\t\t\t\tsettings.IsKeywordsImportEnabled = true;\n\t\t\t\tsettings.IsAutoQuoteEnabled = false;\n\t\t\t}\n\n\t\t\t#endregion\n\n\t\t\tbool useSecondLevelCache = PropertiesHelper.GetBoolean(Environment.UseSecondLevelCache, properties, true);\n\t\t\tbool useQueryCache = PropertiesHelper.GetBoolean(Environment.UseQueryCache, properties);\n\n\t\t\tif (useSecondLevelCache || useQueryCache)\n\t\t\t{\n\t\t\t\t// The cache provider is needed when we either have second-level cache enabled\n\t\t\t\t// or query cache enabled.  Note that useSecondLevelCache is enabled by default\n\t\t\t\tsettings.CacheProvider = CreateCacheProvider(properties);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsettings.CacheProvider = new NoCacheProvider();\n\t\t\t}\n\n\t\t\tstring cacheRegionPrefix = PropertiesHelper.GetString(Environment.CacheRegionPrefix, properties, null);\n\t\t\tif (string.IsNullOrEmpty(cacheRegionPrefix)) cacheRegionPrefix = null;\n\t\t\tif (cacheRegionPrefix != null) log.Info(\"Cache region prefix: \" + cacheRegionPrefix);\n\n\n\t\t\tif (useQueryCache)\n\t\t\t{\n\t\t\t\tstring queryCacheFactoryClassName = PropertiesHelper.GetString(Environment.QueryCacheFactory, properties,\n\t\t\t\t                                                               typeof (StandardQueryCacheFactory).FullName);\n\t\t\t\tlog.Info(\"query cache factory: \" + queryCacheFactoryClassName);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tsettings.QueryCacheFactory =\n\t\t\t\t\t\t(IQueryCacheFactory)\n\t\t\t\t\t\tEnvironment.BytecodeProvider.ObjectsFactory.CreateInstance(ReflectHelper.ClassForName(queryCacheFactoryClassName));\n\t\t\t\t}\n\t\t\t\tcatch (Exception cnfe)\n\t\t\t\t{\n\t\t\t\t\tthrow new HibernateException(\"could not instantiate IQueryCacheFactory: \" + queryCacheFactoryClassName, cnfe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstring sessionFactoryName = PropertiesHelper.GetString(Environment.SessionFactoryName, properties, null);\n\n\t\t\t//ADO.NET and connection settings:\n\n\t\t\t// TODO: Environment.BatchVersionedData\n\t\t\tsettings.AdoBatchSize = PropertiesHelper.GetInt32(Environment.BatchSize, properties, 0);\n\t\t\tbool orderInserts = PropertiesHelper.GetBoolean(Environment.OrderInserts, properties, (settings.AdoBatchSize > 0));\n\t\t\tlog.Info(\"Order SQL inserts for batching: \" + EnabledDisabled(orderInserts));\n\t\t\tsettings.IsOrderInsertsEnabled = orderInserts;\n\n\t\t\tbool wrapResultSets = PropertiesHelper.GetBoolean(Environment.WrapResultSets, properties, false);\n\t\t\tlog.Debug(\"Wrap result sets: \" + EnabledDisabled(wrapResultSets));\n\t\t\tsettings.IsWrapResultSetsEnabled = wrapResultSets;\n\t\t\tsettings.BatcherFactory = CreateBatcherFactory(properties, settings.AdoBatchSize, connectionProvider);\n\n\t\t\tstring isolationString = PropertiesHelper.GetString(Environment.Isolation, properties, String.Empty);\n\t\t\tIsolationLevel isolation = IsolationLevel.Unspecified;\n\t\t\tif (isolationString.Length > 0)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tisolation = (IsolationLevel) Enum.Parse(typeof (IsolationLevel), isolationString);\n\t\t\t\t\tlog.Info(\"Using Isolation Level: \" + isolation);\n\t\t\t\t}\n\t\t\t\tcatch (ArgumentException ae)\n\t\t\t\t{\n\t\t\t\t\tlog.Error(\"error configuring IsolationLevel \" + isolationString, ae);\n\t\t\t\t\tthrow new HibernateException(\n\t\t\t\t\t\t\"The isolation level of \" + isolationString + \" is not a valid IsolationLevel.  Please \"\n\t\t\t\t\t\t+ \"use one of the Member Names from the IsolationLevel.\", ae);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tEntityMode defaultEntityMode =\n\t\t\t\tEntityModeHelper.Parse(PropertiesHelper.GetString(Environment.DefaultEntityMode, properties, \"poco\"));\n\t\t\tlog.Info(\"Default entity-mode: \" + defaultEntityMode);\n\t\t\tsettings.DefaultEntityMode = defaultEntityMode;\n\n\t\t\tbool namedQueryChecking = PropertiesHelper.GetBoolean(Environment.QueryStartupChecking, properties, true);\n\t\t\tlog.Info(\"Named query checking : \" + EnabledDisabled(namedQueryChecking));\n\t\t\tsettings.IsNamedQueryStartupCheckingEnabled = namedQueryChecking;\n\n\t\t\t// Not ported - settings.StatementFetchSize = statementFetchSize;\n\t\t\t// Not ported - ScrollableResultSetsEnabled\n\t\t\t// Not ported - GetGeneratedKeysEnabled\n\t\t\tsettings.SqlStatementLogger = new SqlStatementLogger(showSql, formatSql);\n\n\t\t\tsettings.ConnectionProvider = connectionProvider;\n\t\t\tsettings.QuerySubstitutions = querySubstitutions;\n\t\t\tsettings.TransactionFactory = transactionFactory;\n\t\t\t// Not ported - TransactionManagerLookup\n\t\t\tsettings.SessionFactoryName = sessionFactoryName;\n\t\t\tsettings.MaximumFetchDepth = maxFetchDepth;\n\t\t\tsettings.IsQueryCacheEnabled = useQueryCache;\n\t\t\tsettings.IsSecondLevelCacheEnabled = useSecondLevelCache;\n\t\t\tsettings.CacheRegionPrefix = cacheRegionPrefix;\n\t\t\tsettings.IsMinimalPutsEnabled = useMinimalPuts;\n\t\t\t// Not ported - JdbcBatchVersionedData\n\n\t\t\t// NHibernate-specific:\n\t\t\tsettings.IsolationLevel = isolation;\n\n\t\t\treturn settings;\n\t\t}",
      "nStatementSyntax": 22,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\SettingsFactory.cs",
      "SourceLine": 27
    }
  ],
  [
    {
      "TypeIdentifier": "Table",
      "MethodIdentifier": "SqlCreateString",
      "SourcesSample": "public string SqlCreateString(Dialect.Dialect dialect, IMapping p, string defaultCatalog, string defaultSchema)\r\n\t\t{\r\n\t\t\tStringBuilder buf =\r\n\t\t\t\tnew StringBuilder(HasPrimaryKey ? dialect.CreateTableString : dialect.CreateMultisetTableString).Append(' ').Append(\r\n\t\t\t\t\tGetQualifiedName(dialect, defaultCatalog, defaultSchema)).Append(\" (\");\r\n\r\n\t\t\tbool identityColumn = idValue != null && idValue.IsIdentityColumn(dialect);\r\n\r\n\t\t\t// try to find out the name of the pk to create it as identity if the \r\n\t\t\t// identitygenerator is used\r\n\t\t\tstring pkname = null;\r\n\t\t\tif (HasPrimaryKey && identityColumn)\r\n\t\t\t{\r\n\t\t\t\tforeach (Column col in PrimaryKey.ColumnIterator)\r\n\t\t\t\t{\r\n\t\t\t\t\tpkname = col.GetQuotedName(dialect); //should only go through this loop once\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbool commaNeeded = false;\r\n\t\t\tforeach (Column col in ColumnIterator)\r\n\t\t\t{\r\n\t\t\t\tif (commaNeeded)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Append(StringHelper.CommaSpace);\r\n\t\t\t\t}\r\n\t\t\t\tcommaNeeded = true;\r\n\r\n\t\t\t\tbuf.Append(col.GetQuotedName(dialect)).Append(' ');\r\n\r\n\t\t\t\tif (identityColumn && col.GetQuotedName(dialect).Equals(pkname))\r\n\t\t\t\t{\r\n\t\t\t\t\t// to support dialects that have their own identity data type\r\n\t\t\t\t\tif (dialect.HasDataTypeInIdentityColumn)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuf.Append(col.GetSqlType(dialect, p));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbuf.Append(' ').Append(dialect.GetIdentityColumnString(col.GetSqlTypeCode(p).DbType));\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Append(col.GetSqlType(dialect, p));\r\n\r\n\t\t\t\t\tif (!string.IsNullOrEmpty(col.DefaultValue))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuf.Append(\" default \").Append(col.DefaultValue).Append(\" \");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (col.IsNullable)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuf.Append(dialect.NullColumnString);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuf.Append(\" not null\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (col.IsUnique)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (dialect.SupportsUnique)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuf.Append(\" unique\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tUniqueKey uk = GetOrCreateUniqueKey(col.GetQuotedName(dialect) + \"_\");\r\n\t\t\t\t\t\tuk.AddColumn(col);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (col.HasCheckConstraint && dialect.SupportsColumnCheck)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Append(\" check( \").Append(col.CheckConstraint).Append(\") \");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (string.IsNullOrEmpty(col.Comment) == false)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Append(dialect.GetColumnComment(col.Comment));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (HasPrimaryKey && (dialect.GenerateTablePrimaryKeyConstraintForIdentityColumn || !identityColumn))\r\n\t\t\t{\r\n\t\t\t\tbuf.Append(StringHelper.CommaSpace).Append(PrimaryKey.SqlConstraintString(dialect, defaultSchema));\r\n\t\t\t}\r\n\r\n\t\t\tforeach (UniqueKey uk in UniqueKeyIterator)\r\n\t\t\t{\r\n\t\t\t\tbuf.Append(',').Append(uk.SqlConstraintString(dialect));\r\n\t\t\t}\r\n\r\n\t\t\tif (dialect.SupportsTableCheck)\r\n\t\t\t{\r\n\t\t\t\tforeach (string checkConstraint in checkConstraints)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Append(\", check (\").Append(checkConstraint).Append(\") \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!dialect.SupportsForeignKeyConstraintInAlterTable)\r\n\t\t\t{\r\n\t\t\t\tforeach (ForeignKey foreignKey in ForeignKeyIterator)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (foreignKey.HasPhysicalConstraint)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuf.Append(\",\").Append(foreignKey.SqlConstraintString(dialect, foreignKey.Name, defaultCatalog, defaultSchema));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbuf.Append(StringHelper.ClosedParen);\r\n\r\n\t\t\tif (string.IsNullOrEmpty(comment) == false)\r\n\t\t\t{\r\n\t\t\t\tbuf.Append(dialect.GetTableComment(comment));\r\n\t\t\t}\r\n\t\t\tbuf.Append(dialect.TableTypeString);\r\n\r\n\t\t\treturn buf.ToString();\r\n\t\t}",
      "nStatementSyntax": 21,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Mapping\\Table.cs",
      "SourceLine": 330
    }
  ],
  [
    {
      "TypeIdentifier": "QuotedAndParenthesisStringTokenizer",
      "MethodIdentifier": "GetEnumerator",
      "SourcesSample": "IEnumerator<SqlString> IEnumerable<SqlString>.GetEnumerator()\r\n\t\t\t{\r\n\t\t\t\tTokenizerState state = TokenizerState.WhiteSpace;\r\n\t\t\t\tint parenthesisCount = 0;\r\n\t\t\t\tbool escapeQuote = false;\r\n\t\t\t\tchar quoteType = '\\'';\r\n\t\t\t\tint tokenStart = 0;\r\n\t\t\t\tint tokenLength = 0;\r\n\t\t\t\tstring originalString = _original.ToString();\r\n\r\n\t\t\t\tfor (int i = 0; i < originalString.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tchar ch = originalString[i];\r\n\t\t\t\t\tswitch (state)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase TokenizerState.WhiteSpace:\r\n\t\t\t\t\t\t\tif (ch == '\\'')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.Quoted;\r\n\t\t\t\t\t\t\t\tquoteType = '\\'';\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == '\"')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.Quoted;\r\n\t\t\t\t\t\t\t\tquoteType = '\"';\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == ',')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tyield return new SqlString(\",\");\r\n\t\t\t\t\t\t\t\ttokenStart += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == '(' || ch == '[')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.InParenthesis;\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t\tparenthesisCount = 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (char.IsWhiteSpace(ch) == false)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.Token;\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\ttokenStart += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase TokenizerState.Quoted:\r\n\t\t\t\t\t\t\tif (escapeQuote)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tescapeQuote = false;\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// handle escaping of ' by using '' or \\'\r\n\t\t\t\t\t\t\telse if (ch == '\\\\' || (ch == quoteType && i + 1 < originalString.Length && originalString[i + 1] == quoteType))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tescapeQuote = true;\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == quoteType)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tyield return _original.Substring(tokenStart, tokenLength + 1);\r\n\t\t\t\t\t\t\t\ttokenStart += tokenLength + 1;\r\n\t\t\t\t\t\t\t\ttokenLength = 0;\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.WhiteSpace;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase TokenizerState.InParenthesis:\r\n\t\t\t\t\t\t\tif (ch == ')' || ch == ']')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t\tparenthesisCount -= 1;\r\n\t\t\t\t\t\t\t\tif (parenthesisCount == 0)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tyield return _original.Substring(tokenStart, tokenLength);\r\n\t\t\t\t\t\t\t\t\ttokenStart += tokenLength;\r\n\t\t\t\t\t\t\t\t\ttokenLength = 0;\r\n\t\t\t\t\t\t\t\t\tstate = TokenizerState.WhiteSpace;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == '(' || ch == '[')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t\tparenthesisCount += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase TokenizerState.Token:\r\n\t\t\t\t\t\t\tif (char.IsWhiteSpace(ch))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tyield return _original.Substring(tokenStart, tokenLength);\r\n\t\t\t\t\t\t\t\ttokenStart += tokenLength + 1;\r\n\t\t\t\t\t\t\t\ttokenLength = 0;\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.WhiteSpace;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == ',') // stop current token, and send the , as well\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tyield return _original.Substring(tokenStart, tokenLength);\r\n\t\t\t\t\t\t\t\tyield return new SqlString(\",\");\r\n\t\t\t\t\t\t\t\ttokenStart += tokenLength + 1;\r\n\t\t\t\t\t\t\t\ttokenLength = 0;\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.WhiteSpace;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == '(' || ch == '[')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.InParenthesis;\r\n\t\t\t\t\t\t\t\tparenthesisCount = 1;\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == '\\'')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.Quoted;\r\n\t\t\t\t\t\t\t\tquoteType = '\\'';\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (ch == '\"')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tstate = TokenizerState.Quoted;\r\n\t\t\t\t\t\t\t\tquoteType = '\"';\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\ttokenLength += 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tthrow new InvalidExpressionException(\"Could not understand the string \" + _original);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (tokenLength > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tyield return _original.Substring(tokenStart, tokenLength);\r\n\t\t\t\t}\r\n\t\t\t}",
      "nStatementSyntax": 20,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Dialect\\Dialect.cs",
      "SourceLine": 1231
    }
  ],
  [
    {
      "TypeIdentifier": "SqlTokenizerExtensions",
      "MethodIdentifier": "TryParseUntilFirstMsSqlSelectColumn",
      "SourcesSample": "public static bool TryParseUntilFirstMsSqlSelectColumn(this IEnumerator<SqlToken> tokenEnum, out SqlToken selectToken, out bool isDistinct)\r\n\t\t{\r\n\t\t\tselectToken = null;\r\n\t\t\tisDistinct = false;\r\n\r\n\t\t\twhile (tokenEnum.TryParseUntil(\"select\"))\r\n\t\t\t{\r\n\t\t\t\tselectToken = tokenEnum.Current;\r\n\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\r\n\t\t\t\t// [ DISTINCT | ALL ]\r\n\t\t\t\tif (tokenEnum.Current.Equals(\"distinct\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t{\r\n\t\t\t\t\tisDistinct = true;\r\n\t\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\t\t\t\t}\r\n\t\t\t\telse if\t(tokenEnum.Current.Equals(\"all\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// [ TOP { integer | ( expression ) } [PERCENT] [ WITH TIES ] ] \r\n\t\t\t\tif (tokenEnum.Current.Equals(\"top\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\t\t\t\t\tif (tokenEnum.Current.TokenType == SqlTokenType.BracketOpen)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\t\t\t\t\t\t} while (tokenEnum.Current.TokenType != SqlTokenType.BracketClose);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\r\n\t\t\t\t\tif (tokenEnum.Current.Equals(\"percent\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (tokenEnum.Current.Equals(\"with\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\t\t\t\t\t\tif (tokenEnum.Current.Equals(\"ties\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (!tokenEnum.MoveNext()) return false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!tokenEnum.Current.Value.StartsWith(\"@\")) return true;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}",
      "nStatementSyntax": 20,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\Parser\\SqlTokenizerExtensions.cs",
      "SourceLine": 40
    }
  ],
  [
    {
      "TypeIdentifier": "FormatProcess",
      "MethodIdentifier": "Perform",
      "SourcesSample": "public string Perform()\r\n\t\t\t{\r\n\t\t\t\tresult.Append(Initial);\r\n\r\n\t\t\t\twhile (tokens.MoveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\ttoken = tokens.Current;\r\n\t\t\t\t\tlcToken = token.ToLowerInvariant();\r\n\r\n\t\t\t\t\tif (\"'\".Equals(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tExtractStringEnclosedBy(\"'\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (\"\\\"\".Equals(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tExtractStringEnclosedBy(\"\\\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(IsMultiQueryDelimiter(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tStartingNewQuery();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (afterByOrSetOrFromOrSelect && \",\".Equals(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCommaAfterByOrFromOrSelect();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (afterOn && \",\".Equals(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCommaAfterOn();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (\"(\".Equals(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tOpenParen();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (\")\".Equals(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCloseParen();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (beginClauses.Contains(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tBeginNewClause();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (endClauses.Contains(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tEndNewClause();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (\"select\".Equals(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSelect();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (dml.Contains(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tUpdateOrInsertOrDelete();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (\"values\".Equals(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tValues();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (\"on\".Equals(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tOn();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (afterBetween && lcToken.Equals(\"and\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMisc();\r\n\t\t\t\t\t\tafterBetween = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (logical.Contains(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tLogical();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (IsWhitespace(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tWhite();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMisc();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!IsWhitespace(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlastToken = lcToken;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn result.ToString();\r\n\t\t\t}",
      "nStatementSyntax": 19,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\AdoNet\\Util\\BasicFormatter.cs",
      "SourceLine": 96
    }
  ],
  [
    {
      "TypeIdentifier": "PropertiesBinder",
      "MethodIdentifier": "Bind",
      "SourcesSample": "public void Bind(IEnumerable<IEntityPropertyMapping> properties, Table table, IDictionary<string, MetaAttribute> inheritedMetas, Action<Property> modifier, Action<Property> addToModelAction)\r\n\t\t{\r\n\t\t\tif (table == null)\r\n\t\t\t{\r\n\t\t\t\tthrow new ArgumentNullException(\"table\");\r\n\t\t\t}\r\n\t\t\tif (modifier == null)\r\n\t\t\t{\r\n\t\t\t\tthrow new ArgumentNullException(\"modifier\");\r\n\t\t\t}\r\n\t\t\tif (addToModelAction == null)\r\n\t\t\t{\r\n\t\t\t\tthrow new ArgumentNullException(\"addToModelAction\");\r\n\t\t\t}\r\n\r\n\t\t\tforeach (var entityPropertyMapping in properties)\r\n\t\t\t{\r\n\t\t\t\tProperty property = null;\r\n\r\n\t\t\t\tstring propertyName = entityPropertyMapping.Name;\r\n\r\n\t\t\t\tICollectionPropertiesMapping collectionMapping;\r\n\t\t\t\tHbmManyToOne manyToOneMapping;\r\n\t\t\t\tHbmAny anyMapping;\r\n\t\t\t\tHbmOneToOne oneToOneMapping;\r\n\t\t\t\tHbmProperty propertyMapping;\r\n\t\t\t\tHbmComponent componentMapping;\r\n\t\t\t\tHbmDynamicComponent dynamicComponentMapping;\r\n\t\t\t\tHbmNestedCompositeElement nestedCompositeElementMapping;\r\n\t\t\t\tHbmKeyProperty keyPropertyMapping;\r\n\t\t\t\tHbmKeyManyToOne keyManyToOneMapping;\r\n\t\t\t\tHbmProperties propertiesMapping;\r\n\r\n\t\t\t\tif ((propertyMapping = entityPropertyMapping as HbmProperty) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar value = new SimpleValue(table);\r\n\t\t\t\t\tnew ValuePropertyBinder(value, Mappings).BindSimpleValue(propertyMapping, propertyName, true);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t\tBindValueProperty(propertyMapping, property);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((collectionMapping = entityPropertyMapping as ICollectionPropertiesMapping) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar collectionBinder = new CollectionBinder(Mappings, dialect);\r\n\t\t\t\t\tstring propertyPath = propertyName == null ? null : StringHelper.Qualify(propertyBasePath, propertyName);\r\n\r\n\t\t\t\t\tMapping.Collection collection = collectionBinder.Create(collectionMapping, entityName, propertyPath, persistentClass,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmappedClass, inheritedMetas);\r\n\r\n\t\t\t\t\tmappings.AddCollection(collection);\r\n\r\n\t\t\t\t\tproperty = CreateProperty(collectionMapping, className, collection, inheritedMetas);\r\n\t\t\t\t\tBindCollectionProperty(collectionMapping, property);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((propertiesMapping = entityPropertyMapping as HbmProperties) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar subpath = propertyName == null ? null : StringHelper.Qualify(propertyBasePath, propertyName);\r\n\t\t\t\t\tvar value = CreateNewComponent(table);\r\n\t\t\t\t\tBindComponent(propertiesMapping, value, null, entityName, subpath, componetDefaultNullable, inheritedMetas);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t\tBindComponentProperty(propertiesMapping, property, value);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((manyToOneMapping = entityPropertyMapping as HbmManyToOne) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar value = new ManyToOne(table);\r\n\t\t\t\t\tBindManyToOne(manyToOneMapping, value, propertyName, true);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t\tBindManyToOneProperty(manyToOneMapping, property);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((componentMapping = entityPropertyMapping as HbmComponent) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring subpath = propertyName == null ? null : StringHelper.Qualify(propertyBasePath, propertyName);\r\n\t\t\t\t\tvar value = CreateNewComponent(table);\r\n\t\t\t\t\t// NH: Modified from H2.1 to allow specifying the type explicitly using class attribute\r\n\t\t\t\t\tSystem.Type reflectedClass = mappedClass == null ? null : GetPropertyType(componentMapping.Class, mappedClass, propertyName, componentMapping.Access);\r\n\t\t\t\t\tBindComponent(componentMapping, value, reflectedClass, entityName, subpath, componetDefaultNullable, inheritedMetas);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t\tBindComponentProperty(componentMapping, property, value);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((oneToOneMapping = entityPropertyMapping as HbmOneToOne) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar value = new OneToOne(table, persistentClass);\r\n\t\t\t\t\tBindOneToOne(oneToOneMapping, value);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t\tBindOneToOneProperty(oneToOneMapping, property);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((dynamicComponentMapping = entityPropertyMapping as HbmDynamicComponent) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tstring subpath = propertyName == null ? null : StringHelper.Qualify(propertyBasePath, propertyName);\r\n\t\t\t\t\tvar value = CreateNewComponent(table);\r\n\t\t\t\t\t// NH: Modified from H2.1 to allow specifying the type explicitly using class attribute\r\n\t\t\t\t\tSystem.Type reflectedClass = mappedClass == null ? null : GetPropertyType(dynamicComponentMapping.Class, mappedClass, propertyName, dynamicComponentMapping.Access);\r\n\t\t\t\t\tBindComponent(dynamicComponentMapping, value, reflectedClass, entityName, subpath, componetDefaultNullable, inheritedMetas);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t\tBindComponentProperty(dynamicComponentMapping, property, value);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((anyMapping = entityPropertyMapping as HbmAny) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar value = new Any(table);\r\n\t\t\t\t\tBindAny(anyMapping, value, true);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t\tBindAnyProperty(anyMapping, property);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((nestedCompositeElementMapping = entityPropertyMapping as HbmNestedCompositeElement) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (component == null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new AssertionFailure(\"Nested Composite Element without a owner component.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstring subpath = propertyName == null ? null : StringHelper.Qualify(propertyBasePath, propertyName);\r\n\t\t\t\t\tvar value = CreateNewComponent(table);\r\n\t\t\t\t\t// NH: Modified from H2.1 to allow specifying the type explicitly using class attribute\r\n\t\t\t\t\tSystem.Type reflectedClass = mappedClass == null ? null : GetPropertyType(nestedCompositeElementMapping.Class, mappedClass, propertyName, nestedCompositeElementMapping.access);\r\n\t\t\t\t\tBindComponent(nestedCompositeElementMapping, value, reflectedClass, entityName, subpath, componetDefaultNullable, inheritedMetas);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((keyPropertyMapping = entityPropertyMapping as HbmKeyProperty) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar value = new SimpleValue(table);\r\n\t\t\t\t\tnew ValuePropertyBinder(value, Mappings).BindSimpleValue(keyPropertyMapping, propertyName, componetDefaultNullable);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t}\r\n\t\t\t\telse if ((keyManyToOneMapping = entityPropertyMapping as HbmKeyManyToOne) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar value = new ManyToOne(table);\r\n\t\t\t\t\tBindKeyManyToOne(keyManyToOneMapping, value, propertyName, componetDefaultNullable);\r\n\t\t\t\t\tproperty = CreateProperty(entityPropertyMapping, className, value, inheritedMetas);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (property != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tmodifier(property);\r\n\t\t\t\t\tproperty.LogMapped(log);\r\n\t\t\t\t\taddToModelAction(property);\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}",
      "nStatementSyntax": 18,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\XmlHbmBinding\\PropertiesBinder.cs",
      "SourceLine": 54
    }
  ],
  [
    {
      "TypeIdentifier": "TwoPhaseLoad",
      "MethodIdentifier": "InitializeEntity",
      "SourcesSample": "public static void InitializeEntity(object entity, bool readOnly, ISessionImplementor session, PreLoadEvent preLoadEvent, PostLoadEvent postLoadEvent)\r\n\t\t{\r\n\t\t\t//TODO: Should this be an InitializeEntityEventListener??? (watch out for performance!)\r\n\r\n\t\t\tbool statsEnabled = session.Factory.Statistics.IsStatisticsEnabled;\r\n\t\t\tvar stopWath = new Stopwatch();\r\n\t\t\tif (statsEnabled)\r\n\t\t\t{\r\n\t\t\t\tstopWath.Start();\r\n\t\t\t}\r\n\r\n\t\t\tIPersistenceContext persistenceContext = session.PersistenceContext;\r\n\t\t\tEntityEntry entityEntry = persistenceContext.GetEntry(entity);\r\n\t\t\tif (entityEntry == null)\r\n\t\t\t{\r\n\t\t\t\tthrow new AssertionFailure(\"possible non-threadsafe access to the session\");\r\n\t\t\t}\r\n\t\t\tIEntityPersister persister = entityEntry.Persister;\r\n\t\t\tobject id = entityEntry.Id;\r\n\t\t\tobject[] hydratedState = entityEntry.LoadedState;\r\n\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\tlog.Debug(\"resolving associations for \" + MessageHelper.InfoString(persister, id, session.Factory));\r\n\r\n\t\t\tIType[] types = persister.PropertyTypes;\r\n\t\t\tfor (int i = 0; i < hydratedState.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tobject value = hydratedState[i];\r\n\t\t\t\tif (!Equals(LazyPropertyInitializer.UnfetchedProperty, value) && !(Equals(BackrefPropertyAccessor.Unknown, value)))\r\n\t\t\t\t{\r\n\t\t\t\t\thydratedState[i] = types[i].ResolveIdentifier(value, session, entity);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Must occur after resolving identifiers!\r\n\t\t\tif (session.IsEventSource)\r\n\t\t\t{\r\n\t\t\t\tpreLoadEvent.Entity = entity;\r\n\t\t\t\tpreLoadEvent.State = hydratedState;\r\n\t\t\t\tpreLoadEvent.Id = id;\r\n\t\t\t\tpreLoadEvent.Persister=persister;\r\n\t\t\t\tIPreLoadEventListener[] listeners = session.Listeners.PreLoadEventListeners;\r\n\t\t\t\tfor (int i = 0; i < listeners.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tlisteners[i].OnPreLoad(preLoadEvent);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpersister.SetPropertyValues(entity, hydratedState, session.EntityMode);\r\n\t\t\t\r\n\t\t\tISessionFactoryImplementor factory = session.Factory;\r\n\r\n\t\t\tif (persister.HasCache && ((session.CacheMode & CacheMode.Put) == CacheMode.Put))\r\n\t\t\t{\r\n\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t\tlog.Debug(\"adding entity to second-level cache: \" + MessageHelper.InfoString(persister, id, session.Factory));\r\n\r\n\t\t\t\tobject version = Versioning.GetVersion(hydratedState, persister);\r\n\t\t\t\tCacheEntry entry =\r\n\t\t\t\t\tnew CacheEntry(hydratedState, persister, entityEntry.LoadedWithLazyPropertiesUnfetched, version, session, entity);\r\n\t\t\t\tCacheKey cacheKey = session.GenerateCacheKey(id, persister.IdentifierType, persister.RootEntityName);\r\n\t\t\t\tbool put =\r\n\t\t\t\t\tpersister.Cache.Put(cacheKey, persister.CacheEntryStructure.Structure(entry), session.Timestamp, version,\r\n\t\t\t\t\t\t\t\t\t\tpersister.IsVersioned ? persister.VersionType.Comparator : null,\r\n\t\t\t\t\t\t\t\t\t\tUseMinimalPuts(session, entityEntry));\r\n\r\n\t\t\t\tif (put && factory.Statistics.IsStatisticsEnabled)\r\n\t\t\t\t{\r\n\t\t\t\t\tfactory.StatisticsImplementor.SecondLevelCachePut(persister.Cache.RegionName);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tbool isReallyReadOnly = readOnly;\r\n\t\t\t\r\n\t\t\tif (!persister.IsMutable)\r\n\t\t\t{\r\n\t\t\t\tisReallyReadOnly = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tobject proxy = persistenceContext.GetProxy(entityEntry.EntityKey);\r\n\t\t\t\tif (proxy != null)\r\n\t\t\t\t{\r\n\t\t\t\t\t// there is already a proxy for this impl\r\n\t\t\t\t\t// only set the status to read-only if the proxy is read-only\r\n\t\t\t\t\tisReallyReadOnly = ((INHibernateProxy)proxy).HibernateLazyInitializer.ReadOnly;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (isReallyReadOnly)\r\n\t\t\t{\r\n\t\t\t\t//no need to take a snapshot - this is a\r\n\t\t\t\t//performance optimization, but not really\r\n\t\t\t\t//important, except for entities with huge\r\n\t\t\t\t//mutable property values\r\n\t\t\t\tpersistenceContext.SetEntryStatus(entityEntry, Status.ReadOnly);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t//take a snapshot\r\n\t\t\t\tTypeHelper.DeepCopy(hydratedState, persister.PropertyTypes, persister.PropertyUpdateability, hydratedState, session);\r\n\t\t\t\tpersistenceContext.SetEntryStatus(entityEntry, Status.Loaded);\r\n\t\t\t}\r\n\r\n\t\t\tpersister.AfterInitialize(entity, entityEntry.LoadedWithLazyPropertiesUnfetched, session);\r\n\r\n\t\t\tif (session.IsEventSource)\r\n\t\t\t{\r\n\t\t\t\tpostLoadEvent.Entity = entity;\r\n\t\t\t\tpostLoadEvent.Id = id;\r\n\t\t\t\tpostLoadEvent.Persister = persister;\r\n\t\t\t\tIPostLoadEventListener[] listeners = session.Listeners.PostLoadEventListeners;\r\n\t\t\t\tfor (int i = 0; i < listeners.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tlisteners[i].OnPostLoad(postLoadEvent);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\tlog.Debug(\"done materializing entity \" + MessageHelper.InfoString(persister, id, session.Factory));\r\n\r\n\t\t\tif (statsEnabled)\r\n\t\t\t{\r\n\t\t\t\tstopWath.Stop();\r\n\t\t\t\tfactory.StatisticsImplementor.LoadEntity(persister.EntityName, stopWath.Elapsed);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 18,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Engine\\TwoPhaseLoad.cs",
      "SourceLine": 48
    }
  ],
  [
    {
      "TypeIdentifier": "OneToManyPersister",
      "MethodIdentifier": "DoUpdateRows",
      "SourcesSample": "protected override int DoUpdateRows(object id, IPersistentCollection collection, ISessionImplementor session)\r\n\t\t{\r\n\t\t\t// we finish all the \"removes\" first to take care of possible unique \r\n\t\t\t// constraints and so that we can take better advantage of batching\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tconst int offset = 0;\r\n\t\t\t\tint count = 0;\r\n\r\n\t\t\t\tif (RowDeleteEnabled)\r\n\t\t\t\t{\r\n\t\t\t\t\tbool useBatch = true;\r\n\t\t\t\t\tIDbCommand st = null;\r\n\t\t\t\t\t// update removed rows fks to null\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tint i = 0;\r\n\t\t\t\t\t\tIEnumerable entries = collection.Entries(this);\r\n\t\t\t\t\t\tIExpectation expectation = Expectations.None;\r\n\r\n\t\t\t\t\t\tforeach (object entry in entries)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (collection.NeedsUpdating(entry, i, ElementType))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// will still be issued when it used to be null\r\n\t\t\t\t\t\t\t\tif (st == null)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tSqlCommandInfo sql = SqlDeleteRowString;\r\n\t\t\t\t\t\t\t\t\tif (DeleteCallable)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\texpectation = Expectations.AppropriateExpectation(DeleteCheckStyle);\r\n\t\t\t\t\t\t\t\t\t\tuseBatch = expectation.CanBeBatched;\r\n\t\t\t\t\t\t\t\t\t\tst = useBatch\r\n\t\t\t\t\t\t\t\t\t\t\t\t? session.Batcher.PrepareBatchCommand(SqlDeleteRowString.CommandType, sql.Text, SqlDeleteRowString.ParameterTypes)\r\n\t\t\t\t\t\t\t\t\t\t\t\t: session.Batcher.PrepareCommand(SqlDeleteRowString.CommandType, sql.Text, SqlDeleteRowString.ParameterTypes);\r\n\t\t\t\t\t\t\t\t\t\t//offset += expectation.prepare(st);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tst = session.Batcher.PrepareBatchCommand(SqlDeleteRowString.CommandType, sql.Text, SqlDeleteRowString.ParameterTypes);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tint loc = WriteKey(st, id, offset, session);\r\n\t\t\t\t\t\t\t\tWriteElementToWhere(st, collection.GetSnapshotElement(entry, i), loc, session);\r\n\t\t\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tsession.Batcher.AddToBatch(expectation);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\texpectation.VerifyOutcomeNonBatched(session.Batcher.ExecuteNonQuery(st), st);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (Exception e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tsession.Batcher.AbortBatch(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthrow;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfinally\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!useBatch && st != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tsession.Batcher.CloseCommand(st, null);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (RowInsertEnabled)\r\n\t\t\t\t{\r\n\t\t\t\t\tIExpectation expectation = Expectations.AppropriateExpectation(InsertCheckStyle);\r\n\t\t\t\t\t//bool callable = InsertCallable;\r\n\t\t\t\t\tbool useBatch = expectation.CanBeBatched;\r\n\t\t\t\t\tSqlCommandInfo sql = SqlInsertRowString;\r\n\t\t\t\t\tIDbCommand st = null;\r\n\r\n\t\t\t\t\t// now update all changed or added rows fks\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tint i = 0;\r\n\t\t\t\t\t\tIEnumerable entries = collection.Entries(this);\r\n\t\t\t\t\t\tforeach (object entry in entries)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (collection.NeedsUpdating(entry, i, ElementType))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif (st == null)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tst = session.Batcher.PrepareBatchCommand(SqlInsertRowString.CommandType, sql.Text, SqlInsertRowString.ParameterTypes);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tst = session.Batcher.PrepareCommand(SqlInsertRowString.CommandType, sql.Text, SqlInsertRowString.ParameterTypes);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t//offset += expectation.Prepare(st, Factory.ConnectionProvider.Driver);\r\n\t\t\t\t\t\t\t\tint loc = WriteKey(st, id, offset, session);\r\n\t\t\t\t\t\t\t\tif (HasIndex && !indexContainsFormula)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tloc = WriteIndexToWhere(st, collection.GetIndex(entry, i, this), loc, session);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tWriteElementToWhere(st, collection.GetElement(entry), loc, session);\r\n\t\t\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tsession.Batcher.AddToBatch(expectation);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\texpectation.VerifyOutcomeNonBatched(session.Batcher.ExecuteNonQuery(st), st);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (Exception e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tsession.Batcher.AbortBatch(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthrow;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfinally\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!useBatch && st != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tsession.Batcher.CloseCommand(st, null);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn count;\r\n\t\t\t}\r\n\t\t\tcatch (DbException sqle)\r\n\t\t\t{\r\n\t\t\t\tthrow ADOExceptionHelper.Convert(SQLExceptionConverter, sqle, \"could not update collection rows: \" + MessageHelper.InfoString(this, id));\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 18,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Persister\\Collection\\OneToManyPersister.cs",
      "SourceLine": 152
    }
  ],
  [
    {
      "TypeIdentifier": "CriteriaQueryTest",
      "MethodIdentifier": "SubselectWithComponent",
      "SourcesSample": "[Test]\r\n\t\tpublic void SubselectWithComponent()\r\n\t\t{\r\n\t\t\tCourse course = null;\r\n\t\t\tStudent gavin = null;\r\n\t\t\tDetachedCriteria dc = null;\r\n\t\t\tCityState odessaWa = null;\r\n\t\t\tEnrolment enrolment2 = null;\r\n\t\t\t\r\n\t\t\tusing (ISession session = OpenSession())\r\n\t\t\tusing (ITransaction t = session.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tcourse = new Course();\r\n\t\t\t\tcourse.CourseCode = \"HIB\";\r\n\t\t\t\tcourse.Description = \"Hibernate Training\";\r\n\t\t\t\tsession.Save(course);\r\n\t\t\t\t\r\n\t\t\t\todessaWa = new CityState(\"Odessa\", \"WA\");\r\n\t\r\n\t\t\t\tgavin = new Student();\r\n\t\t\t\tgavin.Name = \"Gavin King\";\r\n\t\t\t\tgavin.StudentNumber = 232;\r\n\t\t\t\tgavin.CityState = odessaWa;\r\n\t\t\t\tsession.Save(gavin);\r\n\t\r\n\t\t\t\tenrolment2 = new Enrolment();\r\n\t\t\t\tenrolment2.Course = course;\r\n\t\t\t\tenrolment2.CourseCode = course.CourseCode;\r\n\t\t\t\tenrolment2.Semester = 3;\r\n\t\t\t\tenrolment2.Year = 1998;\r\n\t\t\t\tenrolment2.Student = gavin;\r\n\t\t\t\tenrolment2.StudentNumber = gavin.StudentNumber;\r\n\t\t\t\tgavin.Enrolments.Add(enrolment2);\r\n\t\t\t\t\r\n\t\t\t\tsession.Persist(enrolment2);\r\n\t\r\n\t\t\t\tdc = DetachedCriteria.For<Student>()\r\n\t\t\t\t\t.Add(Property.ForName(\"CityState\").Eq(odessaWa))\r\n\t\t\t\t\t.SetProjection(Property.ForName(\"CityState\"));\r\n\t\t\r\n\t\t\t\tsession.CreateCriteria<Student>()\r\n\t\t\t\t\t.Add(Subqueries.Exists(dc))\r\n\t\t\t\t\t.List();\r\n\t\t\t\t\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tif (TestDialect.SupportsOperatorAll)\r\n\t\t\t{\r\n\t\t\t\tusing (ISession session = OpenSession())\r\n\t\t\t\tusing (ITransaction t = session.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.CreateCriteria<Student>()\r\n\t\t\t\t\t\t\t.Add(Subqueries.PropertyEqAll(\"CityState\", dc))\r\n\t\t\t\t\t\t\t.List();\r\n\r\n\t\t\t\t\t\tAssert.Fail(\"should have failed because cannot compare subquery results with multiple columns\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (QueryException)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// expected\r\n\t\t\t\t\t}\r\n\t\t\t\t\tt.Rollback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (TestDialect.SupportsOperatorAll)\r\n\t\t\t{\r\n\t\t\t\tusing (ISession session = OpenSession())\r\n\t\t\t\tusing (ITransaction t = session.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsession.CreateCriteria<Student>()\r\n\t\t\t\t\t\t\t.Add(Property.ForName(\"CityState\").EqAll(dc))\r\n\t\t\t\t\t\t\t.List();\r\n\r\n\t\t\t\t\t\tAssert.Fail(\"should have failed because cannot compare subquery results with multiple columns\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (QueryException)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// expected\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfinally\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tt.Rollback();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tusing (ISession session = OpenSession())\r\n\t\t\tusing (ITransaction t = session.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tsession.CreateCriteria<Student>()\r\n\t\t\t\t\t\t.Add(Subqueries.In(odessaWa, dc))\r\n\t\t\t\t\t\t.List();\r\n\t\t\t\t\t\r\n\t\t\t\t\tAssert.Fail(\"should have failed because cannot compare subquery results with multiple columns\");\r\n\t\t\t\t}\r\n\t\t\t\tcatch (NHibernate.Exceptions.GenericADOException)\r\n\t\t\t\t{\r\n\t\t\t\t\t// expected\r\n\t\t\t\t}\r\n\t\t\t\tfinally\r\n\t\t\t\t{\r\n\t\t\t\t\tt.Rollback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tusing (ISession session = OpenSession())\r\n\t\t\tusing (ITransaction t = session.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tDetachedCriteria dc2 = DetachedCriteria.For<Student>(\"st1\")\r\n\t\t\t\t\t.Add(Property.ForName(\"st1.CityState\").EqProperty(\"st2.CityState\"))\r\n\t\t\t\t\t.SetProjection(Property.ForName(\"CityState\"));\r\n\t\t\t\t\r\n\t\t\t\ttry \r\n\t\t\t\t{\r\n\t\t\t\t\tsession.CreateCriteria<Student>(\"st2\")\r\n\t\t\t\t\t\t.Add( Subqueries.Eq(odessaWa, dc2))\r\n\t\t\t\t\t\t.List();\r\n\t\t\t\t\tAssert.Fail(\"should have failed because cannot compare subquery results with multiple columns\");\r\n\t\t\t\t}\r\n\t\t\t\tcatch (NHibernate.Exceptions.GenericADOException)\r\n\t\t\t\t{\r\n\t\t\t\t\t// expected\r\n\t\t\t\t}\r\n\t\t\t\tfinally\r\n\t\t\t\t{\r\n\t\t\t\t\tt.Rollback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tusing (ISession session = OpenSession())\r\n\t\t\tusing (ITransaction t = session.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tDetachedCriteria dc3 = DetachedCriteria.For<Student>(\"st\")\r\n\t\t\t\t\t.CreateCriteria(\"Enrolments\")\r\n\t\t\t\t\t\t.CreateCriteria(\"Course\")\r\n\t\t\t\t\t\t\t.Add(Property.ForName(\"Description\").Eq(\"Hibernate Training\"))\r\n\t\t\t\t\t\t\t.SetProjection(Property.ForName(\"st.CityState\"));\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tsession.CreateCriteria<Enrolment>(\"e\")\r\n\t\t\t\t\t\t.Add(Subqueries.Eq(odessaWa, dc3))\r\n\t\t\t\t\t\t.List();\r\n\t\t\t\t\t\r\n\t\t\t\t\tAssert.Fail(\"should have failed because cannot compare subquery results with multiple columns\");\r\n\t\t\t\t}\r\n\t\t\t\tcatch (NHibernate.Exceptions.GenericADOException)\r\n\t\t\t\t{\r\n\t\t\t\t\t// expected\r\n\t\t\t\t}\r\n\t\t\t\tfinally\r\n\t\t\t\t{\r\n\t\t\t\t\tt.Rollback();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tusing (ISession session = OpenSession())\r\n\t\t\tusing (ITransaction t = session.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tsession.Delete(enrolment2);\r\n\t\t\t\tsession.Delete(gavin);\r\n\t\t\t\tsession.Delete(course);\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Criteria\\CriteriaQueryTest.cs",
      "SourceLine": 246
    }
  ],
  [
    {
      "TypeIdentifier": "ObjectDumper",
      "MethodIdentifier": "WriteObject",
      "SourcesSample": "private void WriteObject(string prefix, object o)\r\n\t\t{\r\n\t\t\tif (o == null || o is ValueType || o is string)\r\n\t\t\t{\r\n\t\t\t\tWriteIndent();\r\n\t\t\t\tWrite(prefix);\r\n\t\t\t\tWriteValue(o);\r\n\t\t\t\tWriteLine();\r\n\t\t\t}\r\n\t\t\telse if (o is IEnumerable)\r\n\t\t\t{\r\n\t\t\t\tforeach (object element in (IEnumerable) o)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (element is IEnumerable && !(element is string))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tWriteIndent();\r\n\t\t\t\t\t\tWrite(prefix);\r\n\t\t\t\t\t\tWrite(\"...\");\r\n\t\t\t\t\t\tWriteLine();\r\n\t\t\t\t\t\tif (_level < _depth)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t_level++;\r\n\t\t\t\t\t\t\tWriteObject(prefix, element);\r\n\t\t\t\t\t\t\t_level--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tWriteObject(prefix, element);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tMemberInfo[] members = o.GetType().GetMembers(BindingFlags.Public | BindingFlags.Instance);\r\n\t\t\t\tWriteIndent();\r\n\t\t\t\tWrite(prefix);\r\n\t\t\t\tbool propWritten = false;\r\n\t\t\t\tforeach (MemberInfo m in members)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar f = m as FieldInfo;\r\n\t\t\t\t\tvar p = m as PropertyInfo;\r\n\t\t\t\t\tif (f != null || p != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (propWritten)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tWriteTab();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tpropWritten = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tWrite(m.Name);\r\n\t\t\t\t\t\tWrite(\"=\");\r\n\t\t\t\t\t\tSystem.Type t = f != null ? f.FieldType : p.PropertyType;\r\n\t\t\t\t\t\tif (t.IsValueType || t == typeof (string))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tWriteValue(f != null ? f.GetValue(o) : p.GetValue(o, null));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (typeof (IEnumerable).IsAssignableFrom(t))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tWrite(\"...\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tWrite(\"{ }\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (propWritten) WriteLine();\r\n\t\t\t\tif (_level < _depth)\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (MemberInfo m in members)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar f = m as FieldInfo;\r\n\t\t\t\t\t\tvar p = m as PropertyInfo;\r\n\t\t\t\t\t\tif (f != null || p != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tSystem.Type t = f != null ? f.FieldType : p.PropertyType;\r\n\t\t\t\t\t\t\tif (!(t.IsValueType || t == typeof (string)))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tobject value = f != null ? f.GetValue(o) : p.GetValue(o, null);\r\n\t\t\t\t\t\t\t\tif (value != null)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t_level++;\r\n\t\t\t\t\t\t\t\t\tWriteObject(m.Name + \": \", value);\r\n\t\t\t\t\t\t\t\t\t_level--;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Linq\\ObjectDumper.cs",
      "SourceLine": 59
    }
  ],
  [
    {
      "TypeIdentifier": "ResultSetMappingBinder",
      "MethodIdentifier": "BindPropertyResults",
      "SourcesSample": "private IDictionary<string, string[]> BindPropertyResults(string alias, HbmReturnDiscriminator discriminatorSchema,\r\n\t\t\tHbmReturnProperty[] returnProperties, PersistentClass pc)\r\n\t\t{\r\n\t\t\tDictionary<string, string[]> propertyresults = new Dictionary<string, string[]>();\r\n\t\t\t// maybe a concrete SQLpropertyresult type, but Map is exactly what is required at the moment\r\n\r\n\t\t\tif (discriminatorSchema != null)\r\n\t\t\t{\r\n\t\t\t\tpropertyresults[\"class\"] = GetResultColumns(discriminatorSchema).ToArray();\r\n\t\t\t}\r\n\r\n\t\t\tList<HbmReturnProperty> properties = new List<HbmReturnProperty>();\r\n\t\t\tList<string> propertyNames = new List<string>();\r\n\r\n\t\t\tforeach (HbmReturnProperty returnPropertySchema in returnProperties ?? new HbmReturnProperty[0])\r\n\t\t\t{\r\n\t\t\t\tstring name = returnPropertySchema.name;\r\n\t\t\t\tif (pc == null || name.IndexOf('.') == -1)\r\n\t\t\t\t{\r\n\t\t\t\t\t//if dotted and not load-collection nor return-join\r\n\t\t\t\t\t//regular property\r\n\t\t\t\t\tproperties.Add(returnPropertySchema);\r\n\t\t\t\t\tpropertyNames.Add(name);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// Reorder properties\r\n\t\t\t\t\t// 1. get the parent property\r\n\t\t\t\t\t// 2. list all the properties following the expected one in the parent property\r\n\t\t\t\t\t// 3. calculate the lowest index and insert the property\r\n\r\n\t\t\t\t\tint dotIndex = name.LastIndexOf('.');\r\n\t\t\t\t\tstring reducedName = name.Substring(0, dotIndex);\r\n\t\t\t\t\tIValue value = pc.GetRecursiveProperty(reducedName).Value;\r\n\t\t\t\t\tIEnumerable<Mapping.Property> parentPropIter;\r\n\t\t\t\t\tif (value is Component)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tComponent comp = (Component) value;\r\n\t\t\t\t\t\tparentPropIter = comp.PropertyIterator;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (value is ToOne)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tToOne toOne = (ToOne) value;\r\n\t\t\t\t\t\tPersistentClass referencedPc = mappings.GetClass(toOne.ReferencedEntityName);\r\n\t\t\t\t\t\tif (toOne.ReferencedPropertyName != null)\r\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tparentPropIter =\r\n\t\t\t\t\t\t\t\t\t((Component) referencedPc.GetRecursiveProperty(toOne.ReferencedPropertyName).Value).PropertyIterator;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch (InvalidCastException e)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tthrow new MappingException(\"dotted notation reference neither a component nor a many/one to one\", e);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tparentPropIter = ((Component) referencedPc.IdentifierProperty.Value).PropertyIterator;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch (InvalidCastException e)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tthrow new MappingException(\"dotted notation reference neither a component nor a many/one to one\", e);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tthrow new MappingException(\"dotted notation reference neither a component nor a many/one to one\");\r\n\t\t\t\t\tbool hasFollowers = false;\r\n\t\t\t\t\tList<string> followers = new List<string>();\r\n\t\t\t\t\tforeach (Mapping.Property prop in parentPropIter)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring currentPropertyName = prop.Name;\r\n\t\t\t\t\t\tstring currentName = reducedName + '.' + currentPropertyName;\r\n\t\t\t\t\t\tif (hasFollowers)\r\n\t\t\t\t\t\t\tfollowers.Add(currentName);\r\n\t\t\t\t\t\tif (name.Equals(currentName))\r\n\t\t\t\t\t\t\thasFollowers = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tint index = propertyNames.Count;\r\n\t\t\t\t\tint followersSize = followers.Count;\r\n\t\t\t\t\tfor (int loop = 0; loop < followersSize; loop++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring follower = followers[loop];\r\n\t\t\t\t\t\tint currentIndex = GetIndexOfFirstMatchingProperty(propertyNames, follower);\r\n\t\t\t\t\t\tindex = currentIndex != -1 && currentIndex < index ? currentIndex : index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpropertyNames.Insert(index, name);\r\n\t\t\t\t\tproperties.Insert(index, returnPropertySchema);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar uniqueReturnProperty = new HashSet<string>();\r\n\t\t\tforeach (HbmReturnProperty returnPropertySchema in properties)\r\n\t\t\t{\r\n\t\t\t\tstring name = returnPropertySchema.name;\r\n\t\t\t\tif (\"class\".Equals(name))\r\n\t\t\t\t\tthrow new MappingException(\r\n\t\t\t\t\t\t\"class is not a valid property name to use in a <return-property>, use <return-discriminator> instead\"\r\n\t\t\t\t\t\t);\r\n\t\t\t\t//TODO: validate existing of property with the chosen name. (secondpass )\r\n\t\t\t\tList<string> allResultColumns = GetResultColumns(returnPropertySchema);\r\n\r\n\t\t\t\tif (allResultColumns.Count == 0)\r\n\t\t\t\t\tthrow new MappingException(\r\n\t\t\t\t\t\t\"return-property for alias \" + alias +\r\n\t\t\t\t\t\t\t\" must specify at least one column or return-column name\"\r\n\t\t\t\t\t\t);\r\n\t\t\t\tif (uniqueReturnProperty.Contains(name))\r\n\t\t\t\t\tthrow new MappingException(\r\n\t\t\t\t\t\t\"duplicate return-property for property \" + name +\r\n\t\t\t\t\t\t\t\" on alias \" + alias\r\n\t\t\t\t\t\t);\r\n\t\t\t\tuniqueReturnProperty.Add(name);\r\n\r\n\t\t\t\t// the issue here is that for <return-join/> representing an entity collection,\r\n\t\t\t\t// the collection element values (the property values of the associated entity)\r\n\t\t\t\t// are represented as 'element.{propertyname}'.  Thus the StringHelper.root()\r\n\t\t\t\t// here puts everything under 'element' (which additionally has significant\r\n\t\t\t\t// meaning).  Probably what we need to do is to something like this instead:\r\n\t\t\t\t//      String root = StringHelper.root( name );\r\n\t\t\t\t//      String key = root; // by default\r\n\t\t\t\t//      if ( !root.equals( name ) ) {\r\n\t\t\t\t//\t        // we had a dot\r\n\t\t\t\t//          if ( !root.equals( alias ) {\r\n\t\t\t\t//              // the root does not apply to the specific alias\r\n\t\t\t\t//              if ( \"elements\".equals( root ) {\r\n\t\t\t\t//                  // we specifically have a <return-join/> representing an entity collection\r\n\t\t\t\t//                  // and this <return-property/> is one of that entity's properties\r\n\t\t\t\t//                  key = name;\r\n\t\t\t\t//              }\r\n\t\t\t\t//          }\r\n\t\t\t\t//      }\r\n\t\t\t\t// but I am not clear enough on the intended purpose of this code block, especially\r\n\t\t\t\t// in relation to the \"Reorder properties\" code block above... \r\n\t\t\t\t//\t\t\tString key = StringHelper.root( name );\r\n\t\t\t\tstring key = name;\r\n\t\t\t\tstring[] intermediateResults;\r\n\t\t\t\tif (!propertyresults.TryGetValue(key,out intermediateResults))\r\n\t\t\t\t\tpropertyresults[key] = allResultColumns.ToArray();\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new NotImplementedException();\r\n\t\t\t\t\t// 2013-02-24: In 89994bc113e1bb35bf6bcd0b7408d08340bfbccd, 2008-05-29, the intermediateResults\r\n\t\t\t\t\t// variable was changed from ArrayList to string[]. The following code line was there before.\r\n\t\t\t\t\t// Since an array cannot be modified, it seems this code line has never been hit since then.\r\n\t\t\t\t\t// While working on NH-3345, I'm adding an ambigous overload for AddAll(), and I don't want to\r\n\t\t\t\t\t// try to understand this code right now, so comment it out instead. /Oskar\r\n\t\t\t\t\t//ArrayHelper.AddAll(intermediateResults, allResultColumns); // TODO: intermediateResults not used after this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tDictionary<string, string[]> newPropertyResults = new Dictionary<string, string[]>();\r\n\r\n\t\t\tforeach (KeyValuePair<string, string[]> entry in propertyresults)\r\n\t\t\t{\r\n\t\t\t\tnewPropertyResults[entry.Key] = entry.Value;\r\n\t\t\t}\r\n\t\t\treturn newPropertyResults.Count == 0 ? (IDictionary<string, string[]>)new CollectionHelper.EmptyMapClass<string, string[]>() : newPropertyResults;\r\n\t\t}",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cfg\\XmlHbmBinding\\ResultSetMappingBinder.cs",
      "SourceLine": 154
    }
  ],
  [
    {
      "TypeIdentifier": "SelectClause",
      "MethodIdentifier": "InitializeExplicitSelectClause",
      "SourcesSample": "public void InitializeExplicitSelectClause(FromClause fromClause)\r\n\t\t{\r\n\t\t\tif (_prepared)\r\n\t\t\t{\r\n\t\t\t\tthrow new InvalidOperationException(\"SelectClause was already prepared!\");\r\n\t\t\t}\r\n\r\n\t\t\t//explicit = true;\t// This is an explict Select.\r\n\t\t\t//ArrayList sqlResultTypeList = new ArrayList();\r\n\t\t\tList<IType> queryReturnTypeList = new List<IType>();\r\n\r\n\t\t\t// First, collect all of the select expressions.\r\n\t\t\t// NOTE: This must be done *before* invoking setScalarColumnText() because setScalarColumnText()\r\n\t\t\t// changes the AST!!!\r\n\t\t\tISelectExpression[] selectExpressions = CollectSelectExpressions();\r\n\r\n\t\t\tfor (int i = 0; i < selectExpressions.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tISelectExpression expr = selectExpressions[i];\r\n\r\n\t\t\t\tif (expr.IsConstructor)\r\n\t\t\t\t{\r\n\t\t\t\t\t_constructorNode = (ConstructorNode)expr;\r\n\t\t\t\t\tIList<IType> constructorArgumentTypeList = _constructorNode.ConstructorArgumentTypeList;\r\n\t\t\t\t\t//sqlResultTypeList.addAll( constructorArgumentTypeList );\r\n\t\t\t\t\tqueryReturnTypeList.AddRange(constructorArgumentTypeList);\r\n\t\t\t\t\t_scalarSelect = true;\r\n\r\n\t\t\t\t\tfor (int j = 1; j < _constructorNode.ChildCount; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tISelectExpression se = _constructorNode.GetChild(j) as ISelectExpression;\r\n\r\n\t\t\t\t\t\tif (se != null && IsReturnableEntity(se))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t_fromElementsForLoad.Add(se.FromElement);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tIType type = expr.DataType;\r\n\t\t\t\t\tif (type == null && !(expr is ParameterNode))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new QueryException(\"No data type for node: \" + expr.GetType().Name + \" \" + new ASTPrinter().ShowAsString((IASTNode)expr, \"\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//sqlResultTypeList.add( type );\r\n\r\n\t\t\t\t\t// If the data type is not an association type, it could not have been in the FROM clause.\r\n\t\t\t\t\tif (expr.IsScalar)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_scalarSelect = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (IsReturnableEntity(expr))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_fromElementsForLoad.Add(expr.FromElement);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Always add the type to the return type list.\r\n\t\t\t\t\tqueryReturnTypeList.Add(type);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//init the aliases, after initing the constructornode\r\n\t\t\tInitAliases(selectExpressions);\r\n\r\n\t\t\tif (!Walker.IsShallowQuery)\r\n\t\t\t{\r\n\t\t\t\t// add the fetched entities\r\n\t\t\t\tIList<IASTNode> fromElements = fromClause.GetProjectionList();\r\n\r\n\t\t\t\tASTAppender appender = new ASTAppender(ASTFactory, this);\t// Get ready to start adding nodes.\r\n\t\t\t\tint size = fromElements.Count;\r\n\t\t\t\tint k = 0;\r\n\r\n\t\t\t\tforeach (FromElement fromElement in fromElements)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (fromElement.IsFetch)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar origin = GetOrigin(fromElement);\r\n\r\n\t\t\t\t\t\t// Only perform the fetch if its owner is included in the select \r\n\t\t\t\t\t\tif (!_fromElementsForLoad.Contains(origin))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// NH-2846: Before 2012-01-18, we threw this exception. However, some\r\n\t\t\t\t\t\t\t// components using LINQ (e.g. paging) like to automatically append e.g. Count(). It\r\n\t\t\t\t\t\t\t// can then be difficult to avoid having a bogus fetch statement, so just ignore those.\r\n\t\t\t\t\t\t\t// An alternative solution may be to have the linq provider filter out the fetch instead.\r\n\t\t\t\t\t\t\t// throw new QueryException(string.Format(JoinFetchWithoutOwnerExceptionMsg, fromElement.GetDisplayText()));\r\n\r\n\t\t\t\t\t\t\t//throw away the fromElement. It's clearly redundant.\r\n\t\t\t\t\t\t\tfromElement.Parent.RemoveChild(fromElement);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\tIType type = fromElement.SelectType;\r\n\t\t\t\t\t\t\tAddCollectionFromElement(fromElement);\r\n\r\n\t\t\t\t\t\t\tif (type != null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tbool collectionOfElements = fromElement.IsCollectionOfValuesOrComponents;\r\n\t\t\t\t\t\t\t\tif (!collectionOfElements)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t// Add the type to the list of returned sqlResultTypes.\r\n\t\t\t\t\t\t\t\t\tfromElement.IncludeSubclasses = true;\r\n\t\t\t\t\t\t\t\t\t_fromElementsForLoad.Add(fromElement);\r\n\t\t\t\t\t\t\t\t\t//sqlResultTypeList.add( type );\r\n\t\t\t\t\t\t\t\t\t// Generate the select expression.\r\n\t\t\t\t\t\t\t\t\tString text = fromElement.RenderIdentifierSelect(size, k);\r\n\t\t\t\t\t\t\t\t\tSelectExpressionImpl generatedExpr = (SelectExpressionImpl)appender.Append(HqlSqlWalker.SELECT_EXPR, text, false);\r\n\t\t\t\t\t\t\t\t\tif (generatedExpr != null)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tgeneratedExpr.FromElement = fromElement;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tk++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// generate id select fragment and then property select fragment for\r\n\t\t\t\t// each expression, just like generateSelectFragments().\r\n\t\t\t\tRenderNonScalarSelects(CollectSelectExpressions(true), fromClause);\r\n\t\t\t}\r\n\r\n\t\t\tif (_scalarSelect || Walker.IsShallowQuery)\r\n\t\t\t{\r\n\t\t\t\t// If there are any scalars (non-entities) selected, render the select column aliases.\r\n\t\t\t\tRenderScalarSelects(selectExpressions, fromClause);\r\n\t\t\t}\r\n\r\n\t\t\tFinishInitialization( /*sqlResultTypeList,*/ queryReturnTypeList);\r\n\t\t}",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Tree\\SelectClause.cs",
      "SourceLine": 114
    }
  ],
  [
    {
      "TypeIdentifier": "Template",
      "MethodIdentifier": "RenderWhereStringTemplate",
      "SourcesSample": "public static string RenderWhereStringTemplate(string sqlWhereString, string placeholder, Dialect.Dialect dialect,\r\n\t\t                                               SQLFunctionRegistry functionRegistry)\r\n\t\t{\r\n\t\t\t//TODO: make this a bit nicer\r\n\t\t\tstring symbols = new StringBuilder()\r\n\t\t\t\t.Append(\"=><!+-*/()',|&`\")\r\n\t\t\t\t.Append(ParserHelper.Whitespace)\r\n\t\t\t\t.Append(dialect.OpenQuote)\r\n\t\t\t\t.Append(dialect.CloseQuote)\r\n\t\t\t\t.ToString();\r\n\t\t\tStringTokenizer tokens = new StringTokenizer(sqlWhereString, symbols, true);\r\n\r\n\t\t\tStringBuilder result = new StringBuilder();\r\n\t\t\tbool quoted = false;\r\n\t\t\tbool quotedIdentifier = false;\r\n\t\t\tbool beforeTable = false;\r\n\t\t\tbool inFromClause = false;\r\n\t\t\tbool afterFromTable = false;\r\n\r\n\t\t\tIEnumerator<string> tokensEnum = tokens.GetEnumerator();\r\n\t\t\tbool hasMore = tokensEnum.MoveNext();\r\n\t\t\tstring nextToken = hasMore ? tokensEnum.Current : null;\r\n\t\t\tstring lastToken = string.Empty;\r\n\t\t\twhile (hasMore)\r\n\t\t\t{\r\n\t\t\t\tstring token = nextToken;\r\n\t\t\t\tstring lcToken = token.ToLowerInvariant();\r\n\t\t\t\thasMore = tokensEnum.MoveNext();\r\n\t\t\t\tnextToken = hasMore ? tokensEnum.Current : null;\r\n\r\n\t\t\t\tbool isQuoteCharacter = false;\r\n\r\n\t\t\t\tif (!quotedIdentifier && \"'\".Equals(token))\r\n\t\t\t\t{\r\n\t\t\t\t\tquoted = !quoted;\r\n\t\t\t\t\tisQuoteCharacter = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!quoted)\r\n\t\t\t\t{\r\n\t\t\t\t\tbool isOpenQuote;\r\n\t\t\t\t\tif (\"`\".Equals(token))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tisOpenQuote = !quotedIdentifier;\r\n\t\t\t\t\t\ttoken = lcToken = isOpenQuote ?\r\n\t\t\t\t\t\t                  dialect.OpenQuote.ToString() :\r\n\t\t\t\t\t\t                  dialect.CloseQuote.ToString();\r\n\t\t\t\t\t\tquotedIdentifier = isOpenQuote;\r\n\t\t\t\t\t\tisQuoteCharacter = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (!quotedIdentifier && (dialect.OpenQuote == token[0]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tisOpenQuote = true;\r\n\t\t\t\t\t\tquotedIdentifier = true;\r\n\t\t\t\t\t\tisQuoteCharacter = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (quotedIdentifier && (dialect.CloseQuote == token[0]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tquotedIdentifier = false;\r\n\t\t\t\t\t\tisQuoteCharacter = true;\r\n\t\t\t\t\t\tisOpenQuote = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tisOpenQuote = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isOpenQuote && !inFromClause && !lastToken.EndsWith(\".\"))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult.Append(placeholder).Append('.');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbool quotedOrWhitespace = quoted ||\r\n\t\t\t\t                          quotedIdentifier ||\r\n\t\t\t\t                          isQuoteCharacter ||\r\n\t\t\t\t                          char.IsWhiteSpace(token[0]);\r\n\r\n\t\t\t\tif (quotedOrWhitespace)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult.Append(token);\r\n\t\t\t\t}\r\n\t\t\t\telse if (beforeTable)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult.Append(token);\r\n\t\t\t\t\tbeforeTable = false;\r\n\t\t\t\t\tafterFromTable = true;\r\n\t\t\t\t}\r\n\t\t\t\telse if (afterFromTable)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!\"as\".Equals(lcToken))\r\n\t\t\t\t\t\tafterFromTable = false;\r\n\t\t\t\t\tresult.Append(token);\r\n\t\t\t\t}\r\n\t\t\t\telse if (IsNamedParameter(token))\r\n\t\t\t\t{\r\n\t\t\t\t\tresult.Append(token);\r\n\t\t\t\t}\r\n\t\t\t\telse if (\r\n\t\t\t\t\tIsIdentifier(token, dialect) &&\r\n\t\t\t\t\t!IsFunctionOrKeyword(lcToken, nextToken, dialect, functionRegistry)\r\n\t\t\t\t\t)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult.Append(placeholder)\r\n\t\t\t\t\t\t.Append('.')\r\n\t\t\t\t\t\t.Append(token);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (BeforeTableKeywords.Contains(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbeforeTable = true;\r\n\t\t\t\t\t\tinFromClause = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (inFromClause && \",\".Equals(lcToken))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbeforeTable = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult.Append(token);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( //Yuck:\r\n\t\t\t\t\tinFromClause &&\r\n\t\t\t\t\tKeywords.Contains(lcToken) && //\"as\" is not in Keywords\r\n\t\t\t\t\t!BeforeTableKeywords.Contains(lcToken)\r\n\t\t\t\t\t)\r\n\t\t\t\t{\r\n\t\t\t\t\tinFromClause = false;\r\n\t\t\t\t}\r\n\t\t\t\tlastToken = token;\r\n\t\t\t}\r\n\t\t\treturn result.ToString();\r\n\t\t}",
      "nStatementSyntax": 17,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\Template.cs",
      "SourceLine": 74
    }
  ],
  [
    {
      "TypeIdentifier": "SessionFactoryImpl",
      "MethodIdentifier": "GetImplementors",
      "SourcesSample": "public string[] GetImplementors(string entityOrClassName)\r\n\t\t{\r\n\t\t\tstring[] knownMap;\r\n\t\t\tif (entityNameImplementorsMap.TryGetValue(entityOrClassName, out knownMap))\r\n\t\t\t{\r\n\t\t\t\treturn knownMap;\r\n\t\t\t}\r\n\t\t\tSystem.Type clazz = null;\r\n\r\n\t\t\t// NH Different implementation for performance: a class without at least a namespace sure can't be found by reflection\r\n\t\t\tif (entityOrClassName.IndexOf('.') > 0)\r\n\t\t\t{\r\n\t\t\t\tIEntityPersister checkPersister;\r\n\t\t\t\t// NH Different implementation: we have better performance checking, first of all, if we know the class\r\n\t\t\t\t// and take the System.Type directly from the persister (className have high probability to be entityName at least using Criteria or Linq)\r\n\t\t\t\tif (entityPersisters.TryGetValue(entityOrClassName, out checkPersister))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!checkPersister.EntityMetamodel.HasPocoRepresentation)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// we found the persister but it is a dynamic entity without class\r\n\t\t\t\t\t\tknownMap = new[] { entityOrClassName };\r\n\t\t\t\t\t\tentityNameImplementorsMap[entityOrClassName] = knownMap;\r\n\t\t\t\t\t\treturn knownMap;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// NH : take care with this because we are forcing the Poco EntityMode\r\n\t\t\t\t\tclazz = checkPersister.GetMappedClass(EntityMode.Poco);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (clazz == null)\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tclazz = ReflectHelper.ClassForFullNameOrNull(entityOrClassName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (Exception)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tclazz = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (clazz == null)\r\n\t\t\t{\r\n\t\t\t\t// try to get the class from imported names\r\n\t\t\t\tstring importedName = GetImportedClassName(entityOrClassName);\r\n\t\t\t\tif (importedName != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tclazz = System.Type.GetType(importedName, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (clazz == null)\r\n\t\t\t{\r\n\t\t\t\tknownMap = new[] { entityOrClassName };\r\n\t\t\t\tentityNameImplementorsMap[entityOrClassName] = knownMap;\r\n\t\t\t\treturn knownMap; //for a dynamic-class\r\n\t\t\t}\r\n\r\n\t\t\tvar results = new List<string>();\r\n\t\t\tforeach (var q in entityPersisters.Values.OfType<IQueryable>())\r\n\t\t\t{\r\n\t\t\t\tstring registeredEntityName = q.EntityName;\r\n\t\t\t\t// NH: as entity-name we are using the FullName but in HQL we allow just the Name, the class is mapped even when its FullName match the entity-name\r\n\t\t\t\tbool isMappedClass = entityOrClassName.Equals(registeredEntityName) || clazz.FullName.Equals(registeredEntityName);\r\n\t\t\t\tif (q.IsExplicitPolymorphism)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (isMappedClass)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tknownMap = new[] { registeredEntityName };\r\n\t\t\t\t\t\tentityNameImplementorsMap[entityOrClassName] = knownMap;\r\n\t\t\t\t\t\treturn knownMap; // NOTE EARLY EXIT\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (isMappedClass)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresults.Add(registeredEntityName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (IsMatchingImplementor(entityOrClassName, clazz, q))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbool assignableSuperclass;\r\n\t\t\t\t\t\t\tif (q.IsInherited)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tSystem.Type mappedSuperclass = GetEntityPersister(q.MappedSuperclass).GetMappedClass(EntityMode.Poco);\r\n\t\t\t\t\t\t\t\tassignableSuperclass = clazz.IsAssignableFrom(mappedSuperclass);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tassignableSuperclass = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (!assignableSuperclass)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tresults.Add(registeredEntityName);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tknownMap = results.ToArray();\r\n\t\t\tentityNameImplementorsMap[entityOrClassName] = knownMap;\r\n\t\t\treturn knownMap;\r\n\t\t}",
      "nStatementSyntax": 16,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Impl\\SessionFactoryImpl.cs",
      "SourceLine": 624
    }
  ],
  [
    {
      "TypeIdentifier": "SqlUpdateBuilder",
      "MethodIdentifier": "ToSqlString",
      "SourcesSample": "public SqlString ToSqlString()\r\n\t\t{\r\n\t\t\t// 3 = \"UPDATE\", tableName, \"SET\"\r\n\t\t\tint initialCapacity = 3;\r\n\r\n\t\t\t// will have a comma for all but the first column, and then for each column\r\n\t\t\t// will have a name, \" = \", value so multiply by 3\r\n\t\t\tif (columns.Count > 0)\r\n\t\t\t{\r\n\t\t\t\tinitialCapacity += (columns.Count - 1) + (columns.Count * 3);\r\n\t\t\t}\r\n\t\t\t// 1 = \"WHERE\" \r\n\t\t\tinitialCapacity++;\r\n\r\n\t\t\t// the \"AND\" before all but the first whereString\r\n\t\t\tif (whereStrings.Count > 0)\r\n\t\t\t{\r\n\t\t\t\tinitialCapacity += (whereStrings.Count - 1);\r\n\t\t\t\tforeach (SqlString whereString in whereStrings)\r\n\t\t\t\t\tinitialCapacity += whereString.Count;\r\n\t\t\t}\r\n\r\n\t\t\tif (!string.IsNullOrEmpty(comment))\r\n\t\t\t\tinitialCapacity++;\r\n\r\n\t\t\tvar sqlBuilder = new SqlStringBuilder(initialCapacity + 2);\r\n\t\t\tif (!string.IsNullOrEmpty(comment))\r\n\t\t\t\tsqlBuilder.Add(\"/* \" + comment + \" */ \");\r\n\r\n\t\t\tsqlBuilder.Add(\"UPDATE \")\r\n\t\t\t\t.Add(tableName)\r\n\t\t\t\t.Add(\" SET \");\r\n\r\n\t\t\tbool assignmentsAppended = false;\r\n\t\t\tbool commaNeeded = false;\r\n\t\t\tforeach (KeyValuePair<string, object> valuePair in columns)\r\n\t\t\t{\r\n\t\t\t\tif (commaNeeded)\r\n\t\t\t\t\tsqlBuilder.Add(StringHelper.CommaSpace);\r\n\t\t\t\tcommaNeeded = true;\r\n\r\n\r\n\t\t\t\tsqlBuilder.Add(valuePair.Key)\r\n\t\t\t\t\t.Add(\" = \");\r\n\r\n\t\t\t\tSqlType param = valuePair.Value as SqlType;\r\n\t\t\t\tif (param != null)\r\n\t\t\t\t\tsqlBuilder.Add(Parameter.Placeholder);\r\n\t\t\t\telse\r\n\t\t\t\t\tsqlBuilder.Add((string) valuePair.Value);\r\n\t\t\t\tassignmentsAppended = true;\r\n\t\t\t}\r\n\t\t\tif (assignments != null)\r\n\t\t\t{\r\n\t\t\t\tif (assignmentsAppended)\r\n\t\t\t\t{\r\n\t\t\t\t\tsqlBuilder.Add(\", \");\r\n\t\t\t\t}\r\n\t\t\t\tsqlBuilder.Add(assignments);\r\n\t\t\t}\r\n\r\n\t\t\tsqlBuilder.Add(\" WHERE \");\r\n\t\t\tbool andNeeded = false;\r\n\t\t\tforeach (SqlString whereString in whereStrings)\r\n\t\t\t{\r\n\t\t\t\tif (andNeeded)\r\n\t\t\t\t\tsqlBuilder.Add(\" AND \");\r\n\t\t\t\tandNeeded = true;\r\n\r\n\t\t\t\tsqlBuilder.Add(whereString);\r\n\t\t\t}\r\n\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t{\r\n\t\t\t\tif (initialCapacity < sqlBuilder.Count)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\r\n\t\t\t\t\t\t\"The initial capacity was set too low at: \" + initialCapacity + \" for the UpdateSqlBuilder \" +\r\n\t\t\t\t\t\t\"that needed a capacity of: \" + sqlBuilder.Count + \" for the table \" + tableName);\r\n\t\t\t\t}\r\n\t\t\t\telse if (initialCapacity > 16 && ((float) initialCapacity / sqlBuilder.Count) > 1.2)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\r\n\t\t\t\t\t\t\"The initial capacity was set too high at: \" + initialCapacity + \" for the UpdateSqlBuilder \" +\r\n\t\t\t\t\t\t\"that needed a capacity of: \" + sqlBuilder.Count + \" for the table \" + tableName);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn sqlBuilder.ToSqlString();\r\n\t\t}",
      "nStatementSyntax": 16,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\SqlUpdateBuilder.cs",
      "SourceLine": 223
    }
  ],
  [
    {
      "TypeIdentifier": "ScalarQueryFixture",
      "MethodIdentifier": "SimpleProjections",
      "SourcesSample": "[Test]\r\n\t\tpublic void SimpleProjections()\r\n\t\t{\r\n\t\t\tvar transformer = new CustomTransformer();\r\n\t\t\tsessions.EvictQueries();\r\n\t\t\tsessions.Statistics.Clear();\r\n\r\n\t\t\tconst string queryString = \"select i.Name, i.Description from AnotherItem i where i.Name='widget'\";\r\n\r\n\t\t\tobject savedId;\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction tx = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(queryString).SetCacheable(true).List();\r\n\t\t\t\tvar i = new AnotherItem { Name = \"widget\" };\r\n\t\t\t\tsavedId = s.Save(i);\r\n\t\t\t\ttx.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tQueryStatistics qs = sessions.Statistics.GetQueryStatistics(queryString);\r\n\t\t\tEntityStatistics es = sessions.Statistics.GetEntityStatistics(typeof(AnotherItem).FullName);\r\n\r\n\t\t\tThread.Sleep(200);\r\n\r\n\t\t\tIList result;\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction tx = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(queryString).SetCacheable(true).List();\r\n\t\t\t\ttx.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tAssert.That(qs.CacheHitCount, Is.EqualTo(0));\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction tx = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(queryString).SetCacheable(true).List();\r\n\t\t\t\ttx.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tAssert.That(qs.CacheHitCount, Is.EqualTo(1));\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction tx = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(queryString).SetCacheable(true).SetResultTransformer(transformer).List();\r\n\t\t\t\ttx.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tAssert.That(qs.CacheHitCount, Is.EqualTo(1), \"hit count should not go up since we are adding a resulttransformer\");\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction tx = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(queryString).SetCacheable(true).SetResultTransformer(transformer).List();\r\n\t\t\t\ttx.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tAssert.That(qs.CacheHitCount, Is.EqualTo(2), \"hit count should go up since we are using the same resulttransformer\");\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction tx = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tresult = s.CreateQuery(queryString).SetCacheable(true).List();\r\n\t\t\t\tAssert.That(result.Count, Is.EqualTo(1));\r\n\t\t\t\tvar i = s.Get<AnotherItem>(savedId);\r\n\t\t\t\ti.Name = \"Widget\";\r\n\t\t\t\ttx.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tAssert.That(qs.CacheHitCount, Is.EqualTo(3));\r\n\t\t\tAssert.That(qs.CacheMissCount, Is.EqualTo(3));\r\n\r\n\t\t\tThread.Sleep(200);\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction tx = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(queryString).SetCacheable(true).List();\r\n\r\n\t\t\t\tvar i = s.Get<AnotherItem>(savedId);\r\n\t\t\t\tAssert.That(i.Name, Is.EqualTo(\"Widget\"));\r\n\r\n\t\t\t\ts.Delete(i);\r\n\t\t\t\ttx.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tAssert.That(qs.CacheHitCount, Is.EqualTo(3));\r\n\t\t\tAssert.That(qs.CacheMissCount, Is.EqualTo(4));\r\n\t\t\tAssert.That(qs.CachePutCount, Is.EqualTo(4));\r\n\t\t\tAssert.That(qs.ExecutionCount, Is.EqualTo(4));\r\n\t\t\tAssert.That(es.FetchCount, Is.EqualTo(0)); //check that it was being cached\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\SecondLevelCacheTest\\QueryCacheFixture.cs",
      "SourceLine": 209
    }
  ],
  [
    {
      "TypeIdentifier": "QueryKey",
      "MethodIdentifier": "Equals",
      "SourcesSample": "public override bool Equals(object other)\r\n\t\t{\r\n\t\t\tQueryKey that = (QueryKey)other;\r\n\t\t\tif (!_sqlQueryString.Equals(that._sqlQueryString))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (_firstRow != that._firstRow\r\n\t\t\t\t|| _maxRows != that._maxRows)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!Equals(_customTransformer, that._customTransformer))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (_types == null)\r\n\t\t\t{\r\n\t\t\t\tif (that._types != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (that._types == null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (_types.Length != that._types.Length)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (int i = 0; i < _types.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!_types[i].Equals(that._types[i]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!Equals(_values[i], that._values[i]))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!CollectionHelper.SetEquals(_filters, that._filters))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!CollectionHelper.DictionaryEquals(_namedParameters, that._namedParameters))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!CollectionHelper.CollectionEquals<int>(_multiQueriesFirstRows, that._multiQueriesFirstRows))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (!CollectionHelper.CollectionEquals<int>(_multiQueriesMaxRows, that._multiQueriesMaxRows))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Cache\\QueryKey.cs",
      "SourceLine": 79
    }
  ],
  [
    {
      "TypeIdentifier": "AnsiTrimEmulationFunction",
      "MethodIdentifier": "Render",
      "SourcesSample": "public SqlString Render(IList args, ISessionFactoryImplementor factory)\r\n\t\t{\r\n\t\t\tif (args.Count < 1 || args.Count > 4)\r\n\t\t\t{\r\n\t\t\t\tthrow new QueryException(\"function takes between 1 and 4 arguments\");\r\n\t\t\t}\r\n\r\n\t\t\tstring firstArg = args[0].ToString();\r\n\r\n\t\t\tif (args.Count == 1)\r\n\t\t\t{\r\n\t\t\t\t// we have the form: trim(trimSource)\r\n\t\t\t\t//      so we trim leading and trailing spaces\r\n\t\t\t\treturn BothSpaceTrim.Render(args, factory);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (StringHelper.EqualsCaseInsensitive(\"from\", firstArg))\r\n\t\t\t{\r\n\t\t\t\t// we have the form: trim(from trimSource).\r\n\t\t\t\t//      This is functionally equivalent to trim(trimSource)\r\n\t\t\t\treturn BothSpaceTrimFrom.Render(args, factory);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// otherwise, a trim-specification and/or a trim-character\r\n\t\t\t// have been specified;  we need to decide which options\r\n\t\t\t// are present and \"do the right thing\"\r\n\t\t\tbool leading = true; // should leading trim-characters be trimmed?\r\n\t\t\tbool trailing = true; // should trailing trim-characters be trimmed?\r\n\t\t\tobject trimCharacter = null; // the trim-character\r\n\t\t\tobject trimSource = null; // the trim-source\r\n\r\n\t\t\t// potentialTrimCharacterArgIndex = 1 assumes that a\r\n\t\t\t// trim-specification has been specified.  we handle the\r\n\t\t\t// exception to that explicitly\r\n\t\t\tint potentialTrimCharacterArgIndex = 1;\r\n\t\t\tif (StringHelper.EqualsCaseInsensitive(\"leading\", firstArg))\r\n\t\t\t{\r\n\t\t\t\ttrailing = false;\r\n\t\t\t}\r\n\t\t\telse if (StringHelper.EqualsCaseInsensitive(\"trailing\", firstArg))\r\n\t\t\t{\r\n\t\t\t\tleading = false;\r\n\t\t\t}\r\n\t\t\telse if (StringHelper.EqualsCaseInsensitive(\"both\", firstArg))\r\n\t\t\t{\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tpotentialTrimCharacterArgIndex = 0;\r\n\t\t\t}\r\n\r\n\t\t\tobject potentialTrimCharacter = args[potentialTrimCharacterArgIndex];\r\n\t\t\tif (StringHelper.EqualsCaseInsensitive(\"from\", potentialTrimCharacter.ToString()))\r\n\t\t\t{\r\n\t\t\t\ttrimCharacter = \"' '\";\r\n\t\t\t\ttrimSource = args[potentialTrimCharacterArgIndex + 1];\r\n\t\t\t}\r\n\t\t\telse if (potentialTrimCharacterArgIndex + 1 >= args.Count)\r\n\t\t\t{\r\n\t\t\t\ttrimCharacter = \"' '\";\r\n\t\t\t\ttrimSource = potentialTrimCharacter;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ttrimCharacter = potentialTrimCharacter;\r\n\t\t\t\tif (StringHelper.EqualsCaseInsensitive(\"from\", args[potentialTrimCharacterArgIndex + 1].ToString()))\r\n\t\t\t\t{\r\n\t\t\t\t\ttrimSource = args[potentialTrimCharacterArgIndex + 2];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ttrimSource = args[potentialTrimCharacterArgIndex + 1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tIList argsToUse = new List<object> {trimSource, trimCharacter};\r\n\r\n\t\t\tif (trimCharacter.Equals(\"' '\"))\r\n\t\t\t{\r\n\t\t\t\tif (leading && trailing)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn BothSpaceTrim.Render(argsToUse, factory);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (leading)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn LeadingSpaceTrim.Render(argsToUse, factory);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn TrailingSpaceTrim.Render(argsToUse, factory);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (leading && trailing)\r\n\t\t\t{\r\n\t\t\t\treturn BothTrim.Render(argsToUse, factory);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (leading)\r\n\t\t\t{\r\n\t\t\t\treturn LeadingTrim.Render(argsToUse, factory);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn TrailingTrim.Render(argsToUse, factory);\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Dialect\\Function\\AnsiTrimEmulationFunction.cs",
      "SourceLine": 85
    }
  ],
  [
    {
      "TypeIdentifier": "DefaultRefreshEventListener",
      "MethodIdentifier": "OnRefresh",
      "SourcesSample": "public virtual void OnRefresh(RefreshEvent @event, IDictionary refreshedAlready)\r\n\t\t{\r\n\t\t\tIEventSource source = @event.Session;\r\n\r\n\t\t\tbool isTransient = !source.Contains(@event.Entity);\r\n\t\t\tif (source.PersistenceContext.ReassociateIfUninitializedProxy(@event.Entity))\r\n\t\t\t{\r\n\t\t\t\tif (isTransient)\r\n\t\t\t\t\tsource.SetReadOnly(@event.Entity, source.DefaultReadOnly);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tobject obj = source.PersistenceContext.UnproxyAndReassociate(@event.Entity);\r\n\r\n\t\t\tif (refreshedAlready.Contains(obj))\r\n\t\t\t{\r\n\t\t\t\tlog.Debug(\"already refreshed\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tEntityEntry e = source.PersistenceContext.GetEntry(obj);\r\n\t\t\tIEntityPersister persister;\r\n\t\t\tobject id;\r\n\r\n\t\t\tif (e == null)\r\n\t\t\t{\r\n\t\t\t\tpersister = source.GetEntityPersister(null, obj); //refresh() does not pass an entityName\r\n\t\t\t\tid = persister.GetIdentifier(obj, source.EntityMode);\r\n\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"refreshing transient \" + MessageHelper.InfoString(persister, id, source.Factory));\r\n\t\t\t\t}\r\n\t\t\t\tEntityKey key = source.GenerateEntityKey(id, persister);\r\n\t\t\t\tif (source.PersistenceContext.GetEntry(key) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + \r\n\t\t\t\t\t\tMessageHelper.InfoString(persister, id, source.Factory));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"refreshing \" + MessageHelper.InfoString(e.Persister, e.Id, source.Factory));\r\n\t\t\t\t}\r\n\t\t\t\tif (!e.ExistsInDatabase)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new HibernateException(\"this instance does not yet exist as a row in the database\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpersister = e.Persister;\r\n\t\t\t\tid = e.Id;\r\n\t\t\t}\r\n\r\n\t\t\t// cascade the refresh prior to refreshing this entity\r\n\t\t\trefreshedAlready[obj] = obj;\r\n\t\t\tnew Cascade(CascadingAction.Refresh, CascadePoint.BeforeRefresh, source).CascadeOn(persister, obj, refreshedAlready);\r\n\r\n\t\t\tif (e != null)\r\n\t\t\t{\r\n\t\t\t\tEntityKey key = source.GenerateEntityKey(id, persister);\r\n\t\t\t\tsource.PersistenceContext.RemoveEntity(key);\r\n\t\t\t\tif (persister.HasCollections)\r\n\t\t\t\t\tnew EvictVisitor(source).Process(obj, persister);\r\n\t\t\t}\r\n\r\n\t\t\tif (persister.HasCache)\r\n\t\t\t{\r\n\t\t\t\tCacheKey ck = source.GenerateCacheKey(id, persister.IdentifierType, persister.RootEntityName);\r\n\t\t\t\tpersister.Cache.Remove(ck);\r\n\t\t\t}\r\n\r\n\t\t\tEvictCachedCollections(persister, id, source.Factory);\r\n\r\n\t\t\t// NH Different behavior : NH-1601\r\n\t\t\t// At this point the entity need the real refresh, all elementes of collections are Refreshed,\r\n\t\t\t// the collection state was evicted, but the PersistentCollection (in the entity state)\r\n\t\t\t// is associated with a possible previous session.\r\n\t\t\tnew WrapVisitor(source).Process(obj, persister);\r\n\r\n\t\t\tstring previousFetchProfile = source.FetchProfile;\r\n\t\t\tsource.FetchProfile = \"refresh\";\r\n\t\t\tobject result = persister.Load(id, obj, @event.LockMode, source);\r\n\t\t\t\r\n\t\t\tif (result != null)\r\n\t\t\t\tif (!persister.IsMutable)\r\n\t\t\t\t\tsource.SetReadOnly(result, true);\r\n\t\t\t\telse\r\n\t\t\t\t\tsource.SetReadOnly(result, (e == null ? source.DefaultReadOnly : e.IsReadOnly));\r\n\t\t\t\r\n\t\t\tsource.FetchProfile = previousFetchProfile;\r\n\r\n\t\t\t// NH Different behavior : we are ignoring transient entities without throw any kind of exception\r\n\t\t\t// because a transient entity is \"self refreshed\"\r\n\t\t\tif (!ForeignKeys.IsTransient(persister.EntityName, obj, result == null, @event.Session))\r\n\t\t\t\tUnresolvableObjectException.ThrowIfNull(result, id, persister.EntityName);\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Event\\Default\\DefaultRefreshEventListener.cs",
      "SourceLine": 26
    }
  ],
  [
    {
      "TypeIdentifier": "MultiQueryImpl",
      "MethodIdentifier": "DoList",
      "SourcesSample": "protected List<object> DoList()\r\n\t\t{\r\n\t\t\tbool statsEnabled = session.Factory.Statistics.IsStatisticsEnabled;\r\n\t\t\tvar stopWatch = new Stopwatch();\r\n\t\t\tif (statsEnabled)\r\n\t\t\t{\r\n\t\t\t\tstopWatch.Start();\r\n\t\t\t}\r\n\t\t\tint rowCount = 0;\r\n\r\n\t\t\tvar results = new List<object>();\r\n\r\n\t\t\tvar hydratedObjects = new List<object>[Translators.Count];\r\n\t\t\tList<EntityKey[]>[] subselectResultKeys = new List<EntityKey[]>[Translators.Count];\r\n\t\t\tbool[] createSubselects = new bool[Translators.Count];\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tusing (var reader = resultSetsCommand.GetReader(commandTimeout != RowSelection.NoValue ? commandTimeout : (int?)null))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlog.DebugFormat(\"Executing {0} queries\", translators.Count);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (int i = 0; i < translators.Count; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tITranslator translator = Translators[i];\r\n\t\t\t\t\t\tQueryParameters parameter = Parameters[i];\r\n\r\n\t\t\t\t\t\tint entitySpan = translator.Loader.EntityPersisters.Length;\r\n\t\t\t\t\t\thydratedObjects[i] = entitySpan > 0 ? new List<object>() : null;\r\n\t\t\t\t\t\tRowSelection selection = parameter.RowSelection;\r\n\t\t\t\t\t\tint maxRows = Loader.Loader.HasMaxRows(selection) ? selection.MaxRows : int.MaxValue;\r\n\t\t\t\t\t\tif (!dialect.SupportsLimitOffset || !translator.Loader.UseLimit(selection, dialect))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tLoader.Loader.Advance(reader, selection);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tLockMode[] lockModeArray = translator.Loader.GetLockModes(parameter.LockModes);\r\n\t\t\t\t\t\tEntityKey optionalObjectKey = Loader.Loader.GetOptionalObjectKey(parameter, session);\r\n\r\n\t\t\t\t\t\tcreateSubselects[i] = translator.Loader.IsSubselectLoadingEnabled;\r\n\t\t\t\t\t\tsubselectResultKeys[i] = createSubselects[i] ? new List<EntityKey[]>() : null;\r\n\r\n\t\t\t\t\t\ttranslator.Loader.HandleEmptyCollections(parameter.CollectionKeys, reader, session);\r\n\t\t\t\t\t\tEntityKey[] keys = new EntityKey[entitySpan]; // we can reuse it each time\r\n\r\n\t\t\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlog.Debug(\"processing result set\");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tIList tempResults = new List<object>();\r\n\t\t\t\t\t\tint count;\r\n\t\t\t\t\t\tfor (count = 0; count < maxRows && reader.Read(); count++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.Debug(\"result set row: \" + count);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\trowCount++;\r\n\t\t\t\t\t\t\tobject result = translator.Loader.GetRowFromResultSet(\r\n\t\t\t\t\t\t\t\treader, session, parameter, lockModeArray, optionalObjectKey, hydratedObjects[i], keys, true);\r\n\t\t\t\t\t\t\ttempResults.Add(result);\r\n\r\n\t\t\t\t\t\t\tif (createSubselects[i])\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tsubselectResultKeys[i].Add(keys);\r\n\t\t\t\t\t\t\t\tkeys = new EntityKey[entitySpan]; //can't reuse in this case\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlog.Debug(string.Format(\"done processing result set ({0} rows)\", count));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tresults.Add(tempResults);\r\n\r\n\t\t\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlog.DebugFormat(\"Query {0} returned {1} results\", i, tempResults.Count);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treader.NextResult();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (int i = 0; i < translators.Count; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tITranslator translator = translators[i];\r\n\t\t\t\t\t\tQueryParameters parameter = parameters[i];\r\n\r\n\t\t\t\t\t\ttranslator.Loader.InitializeEntitiesAndCollections(hydratedObjects[i], reader, session, false);\r\n\r\n\t\t\t\t\t\tif (createSubselects[i])\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttranslator.Loader.CreateSubselects(subselectResultKeys[i], parameter, session);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch (Exception sqle)\r\n\t\t\t{\r\n\t\t\t\tvar message = string.Format(\"Failed to execute multi query: [{0}]\", resultSetsCommand.Sql);\r\n\t\t\t\tlog.Error(message, sqle);\r\n\t\t\t\tthrow ADOExceptionHelper.Convert(session.Factory.SQLExceptionConverter, sqle, \"Failed to execute multi query\", resultSetsCommand.Sql);\r\n\t\t\t}\r\n\r\n\t\t\tif (statsEnabled)\r\n\t\t\t{\r\n\t\t\t\tstopWatch.Stop();\r\n\t\t\t\tsession.Factory.StatisticsImplementor.QueryExecuted(string.Format(\"{0} queries (MultiQuery)\", translators.Count), rowCount, stopWatch.Elapsed);\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Impl\\MultiQueryImpl.cs",
      "SourceLine": 501
    }
  ],
  [
    {
      "TypeIdentifier": "SQLQueryReturnProcessor",
      "MethodIdentifier": "GenerateCustomReturns",
      "SourcesSample": "public IList GenerateCustomReturns(bool queryHadAliases)\r\n\t\t{\r\n\t\t\tIList customReturns = new List<object>();\r\n\t\t\tIDictionary<string, object> customReturnsByAlias = new Dictionary<string, object>();\r\n\t\t\tfor (int i = 0; i < queryReturns.Length; i++)\r\n\t\t\t{\r\n\t\t\t\tif (queryReturns[i] is NativeSQLQueryScalarReturn)\r\n\t\t\t\t{\r\n\t\t\t\t\tNativeSQLQueryScalarReturn rtn = (NativeSQLQueryScalarReturn) queryReturns[i];\r\n\t\t\t\t\tcustomReturns.Add(new ScalarReturn(rtn.Type, rtn.ColumnAlias));\r\n\t\t\t\t}\r\n\t\t\t\telse if (queryReturns[i] is NativeSQLQueryRootReturn)\r\n\t\t\t\t{\r\n\t\t\t\t\tNativeSQLQueryRootReturn rtn = (NativeSQLQueryRootReturn) queryReturns[i];\r\n\t\t\t\t\tstring alias = rtn.Alias;\r\n\t\t\t\t\tIEntityAliases entityAliases;\r\n\t\t\t\t\tif (queryHadAliases || HasPropertyResultMap(alias))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tentityAliases =\r\n\t\t\t\t\t\t\tnew DefaultEntityAliases(entityPropertyResultMaps[alias], alias2Persister[alias], alias2Suffix[alias]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tentityAliases =\r\n\t\t\t\t\t\t\tnew ColumnEntityAliases(entityPropertyResultMaps[alias], alias2Persister[alias], alias2Suffix[alias]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tRootReturn customReturn = new RootReturn(alias, rtn.ReturnEntityName, entityAliases, rtn.LockMode);\r\n\t\t\t\t\tcustomReturns.Add(customReturn);\r\n\t\t\t\t\tcustomReturnsByAlias[rtn.Alias] = customReturn;\r\n\t\t\t\t}\r\n\t\t\t\telse if (queryReturns[i] is NativeSQLQueryCollectionReturn)\r\n\t\t\t\t{\r\n\t\t\t\t\tNativeSQLQueryCollectionReturn rtn = (NativeSQLQueryCollectionReturn) queryReturns[i];\r\n\t\t\t\t\tstring alias = rtn.Alias;\r\n\t\t\t\t\tISqlLoadableCollection persister = alias2CollectionPersister[alias];\r\n\t\t\t\t\tbool isEntityElements = persister.ElementType.IsEntityType;\r\n\t\t\t\t\tICollectionAliases collectionAliases;\r\n\t\t\t\t\tIEntityAliases elementEntityAliases = null;\r\n\t\t\t\t\tif (queryHadAliases || HasPropertyResultMap(alias))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcollectionAliases =\r\n\t\t\t\t\t\t\tnew GeneratedCollectionAliases(collectionPropertyResultMaps[alias], alias2CollectionPersister[alias],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   alias2CollectionSuffix[alias]);\r\n\t\t\t\t\t\tif (isEntityElements)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\telementEntityAliases =\r\n\t\t\t\t\t\t\t\tnew DefaultEntityAliases(entityPropertyResultMaps[alias], alias2Persister[alias], alias2Suffix[alias]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcollectionAliases =\r\n\t\t\t\t\t\t\tnew ColumnCollectionAliases(collectionPropertyResultMaps[alias], alias2CollectionPersister[alias]);\r\n\t\t\t\t\t\tif (isEntityElements)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\telementEntityAliases =\r\n\t\t\t\t\t\t\t\tnew ColumnEntityAliases(entityPropertyResultMaps[alias], alias2Persister[alias], alias2Suffix[alias]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tCollectionReturn customReturn =\r\n\t\t\t\t\t\tnew CollectionReturn(alias, rtn.OwnerEntityName, rtn.OwnerProperty, collectionAliases, elementEntityAliases,\r\n\t\t\t\t\t\t\t\t\t\t\t rtn.LockMode);\r\n\t\t\t\t\tcustomReturns.Add(customReturn);\r\n\t\t\t\t\tcustomReturnsByAlias[rtn.Alias] = customReturn;\r\n\t\t\t\t}\r\n\t\t\t\telse if (queryReturns[i] is NativeSQLQueryJoinReturn)\r\n\t\t\t\t{\r\n\t\t\t\t\tNativeSQLQueryJoinReturn rtn = (NativeSQLQueryJoinReturn) queryReturns[i];\r\n\t\t\t\t\tstring alias = rtn.Alias;\r\n\t\t\t\t\tFetchReturn customReturn;\r\n\t\t\t\t\tNonScalarReturn ownerCustomReturn = (NonScalarReturn) customReturnsByAlias[rtn.OwnerAlias];\r\n\t\t\t\t\tISqlLoadableCollection persister;\r\n\t\t\t\t\tif (alias2CollectionPersister.TryGetValue(alias, out persister))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbool isEntityElements = persister.ElementType.IsEntityType;\r\n\t\t\t\t\t\tICollectionAliases collectionAliases;\r\n\t\t\t\t\t\tIEntityAliases elementEntityAliases = null;\r\n\t\t\t\t\t\tif (queryHadAliases || HasPropertyResultMap(alias))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcollectionAliases =\r\n\t\t\t\t\t\t\t\tnew GeneratedCollectionAliases(collectionPropertyResultMaps[alias], persister, alias2CollectionSuffix[alias]);\r\n\t\t\t\t\t\t\tif (isEntityElements)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\telementEntityAliases =\r\n\t\t\t\t\t\t\t\t\tnew DefaultEntityAliases(entityPropertyResultMaps[alias], alias2Persister[alias], alias2Suffix[alias]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcollectionAliases = new ColumnCollectionAliases(collectionPropertyResultMaps[alias], persister);\r\n\t\t\t\t\t\t\tif (isEntityElements)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\telementEntityAliases =\r\n\t\t\t\t\t\t\t\t\tnew ColumnEntityAliases(entityPropertyResultMaps[alias], alias2Persister[alias], alias2Suffix[alias]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcustomReturn =\r\n\t\t\t\t\t\t\tnew CollectionFetchReturn(alias, ownerCustomReturn, rtn.OwnerProperty, collectionAliases, elementEntityAliases,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t  rtn.LockMode);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tIEntityAliases entityAliases;\r\n\t\t\t\t\t\tif (queryHadAliases || HasPropertyResultMap(alias))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tentityAliases =\r\n\t\t\t\t\t\t\t\tnew DefaultEntityAliases(entityPropertyResultMaps[alias], alias2Persister[alias], alias2Suffix[alias]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tentityAliases =\r\n\t\t\t\t\t\t\t\tnew ColumnEntityAliases(entityPropertyResultMaps[alias], alias2Persister[alias], alias2Suffix[alias]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcustomReturn = new EntityFetchReturn(alias, entityAliases, ownerCustomReturn, rtn.OwnerProperty, rtn.LockMode);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcustomReturns.Add(customReturn);\r\n\t\t\t\t\tcustomReturnsByAlias[alias] = customReturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn customReturns;\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Loader\\Custom\\Sql\\SQLQueryReturnProcessor.cs",
      "SourceLine": 293
    }
  ],
  [
    {
      "TypeIdentifier": "SqlTokenizer",
      "MethodIdentifier": "GetEnumerator",
      "SourcesSample": "public IEnumerator<SqlToken> GetEnumerator()\r\n\t\t{\r\n\t\t\tint sqlIndex = 0;\r\n\t\t\tforeach (var part in _sql)\r\n\t\t\t{\r\n\t\t\t\tvar parameter = part as Parameter;\r\n\t\t\t\tif (parameter != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (CanYield(SqlTokenType.Parameter))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tyield return new SqlToken(SqlTokenType.Parameter, _sql, sqlIndex, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsqlIndex++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar text = part as string;\r\n\t\t\t\tif (text != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tint offset = 0;\r\n\t\t\t\t\tint maxOffset = text.Length;\r\n\t\t\t\t\tint tokenOffset = 0;\r\n\t\t\t\t\tSqlTokenType nextTokenType = 0;\r\n\t\t\t\t\tint nextTokenLength = 0;\r\n\r\n\t\t\t\t\twhile (offset < maxOffset)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar ch = text[offset];\r\n\t\t\t\t\t\tswitch (ch)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcase '(':\r\n\t\t\t\t\t\t\t\tnextTokenType = SqlTokenType.BracketOpen;\r\n\t\t\t\t\t\t\t\tnextTokenLength = 1;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase ')':\r\n\t\t\t\t\t\t\t\tnextTokenType = SqlTokenType.BracketClose;\r\n\t\t\t\t\t\t\t\tnextTokenLength = 1;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase '\\'':      // String literals\r\n\t\t\t\t\t\t\tcase '\\\"':      // ANSI quoted identifiers\r\n\t\t\t\t\t\t\tcase '[':       // Sql Server quoted indentifiers\r\n\t\t\t\t\t\t\t\tnextTokenType = SqlTokenType.DelimitedText;\r\n\t\t\t\t\t\t\t\tnextTokenLength = SqlParserUtils.ReadDelimitedText(text, maxOffset, offset);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase ',':\r\n\t\t\t\t\t\t\t\tnextTokenType = SqlTokenType.Comma;\r\n\t\t\t\t\t\t\t\tnextTokenLength = 1;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase '/':\r\n\t\t\t\t\t\t\t\tif (offset + 1 < maxOffset && text[offset + 1] == '*')\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tnextTokenType = SqlTokenType.Comment;\r\n\t\t\t\t\t\t\t\t\tnextTokenLength = SqlParserUtils.ReadMultilineComment(text, maxOffset, offset);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase '-':\r\n\t\t\t\t\t\t\t\tif (offset + 1 < maxOffset && text[offset + 1] == '-')\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tnextTokenType = SqlTokenType.Comment;\r\n\t\t\t\t\t\t\t\t\tnextTokenLength = SqlParserUtils.ReadLineComment(text, maxOffset, offset);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tif (char.IsWhiteSpace(ch))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tnextTokenType = SqlTokenType.Whitespace;\r\n\t\t\t\t\t\t\t\t\tnextTokenLength = SqlParserUtils.ReadWhitespace(text, maxOffset, offset);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (nextTokenType != 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (offset > tokenOffset)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif (CanYield(SqlTokenType.Text))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tyield return new SqlToken(SqlTokenType.Text, _sql, sqlIndex + tokenOffset, offset - tokenOffset);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (CanYield(nextTokenType))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tyield return new SqlToken(nextTokenType, _sql, sqlIndex + offset, nextTokenLength);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\toffset += nextTokenLength;\r\n\t\t\t\t\t\t\ttokenOffset = offset;\r\n\r\n\t\t\t\t\t\t\tnextTokenType = 0;\r\n\t\t\t\t\t\t\tnextTokenLength = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\toffset++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (maxOffset > tokenOffset && CanYield(SqlTokenType.Text))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tyield return new SqlToken(SqlTokenType.Text, _sql, sqlIndex + tokenOffset, maxOffset - tokenOffset);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsqlIndex += maxOffset;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\Parser\\SqlTokenizer.cs",
      "SourceLine": 49
    }
  ],
  [
    {
      "TypeIdentifier": "SqlSelectBuilder",
      "MethodIdentifier": "ToSqlString",
      "SourcesSample": "public SqlString ToSqlString()\r\n\t\t{\r\n\t\t\t// 4 = the \"SELECT\", selectClause, \"FROM\", fromClause are straight strings\r\n\t\t\t// plus the number of parts in outerJoinsAfterFrom SqlString.\r\n\t\t\t// 1 = the \"WHERE\" \r\n\t\t\t// plus the number of parts in outerJoinsAfterWhere SqlString.\r\n\t\t\t// 1 = the whereClause\r\n\t\t\t// 2 = the \"ORDER BY\" and orderByClause\r\n\t\t\tvar joinAfterFrom = outerJoinsAfterFrom != null ? outerJoinsAfterFrom.Count : 0;\r\n\t\t\tvar joinAfterWhere = outerJoinsAfterWhere != null ? outerJoinsAfterWhere.Count : 0;\r\n\t\t\tint initialCapacity = 4 + joinAfterFrom + 1 + joinAfterWhere + 1 + 2;\r\n\t\t\tif (!string.IsNullOrEmpty(comment))\r\n\t\t\t\tinitialCapacity++;\r\n\r\n\t\t\tSqlStringBuilder sqlBuilder = new SqlStringBuilder(initialCapacity + 2);\r\n\t\t\tif (!string.IsNullOrEmpty(comment))\r\n\t\t\t\tsqlBuilder.Add(\"/* \" + comment + \" */ \");\r\n\r\n\t\t\tsqlBuilder.Add(\"SELECT \")\r\n\t\t\t\t.Add(selectClause)\r\n\t\t\t\t.Add(\" FROM \")\r\n\t\t\t\t.Add(fromClause);\r\n\r\n\t\t\tif (SqlStringHelper.IsNotEmpty(outerJoinsAfterFrom))\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(outerJoinsAfterFrom);\r\n\t\t\t}\r\n\r\n\t\t\tif (SqlStringHelper.IsNotEmpty(whereClause) || SqlStringHelper.IsNotEmpty(outerJoinsAfterWhere))\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(\" WHERE \");\r\n\t\t\t\t// the outerJoinsAfterWhere needs to come before where clause to properly\r\n\t\t\t\t// handle dynamic filters\r\n\t\t\t\tif (SqlStringHelper.IsNotEmpty(outerJoinsAfterWhere))\r\n\t\t\t\t{\r\n\t\t\t\t\tsqlBuilder.Add(outerJoinsAfterWhere);\r\n\t\t\t\t\tif (SqlStringHelper.IsNotEmpty(whereClause))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsqlBuilder.Add(\" AND \");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (SqlStringHelper.IsNotEmpty(whereClause))\r\n\t\t\t\t{\r\n\t\t\t\t\tsqlBuilder.Add(whereClause);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (StringHelper.IsNotEmpty(groupByClause))\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(\" GROUP BY \")\r\n\t\t\t\t\t.Add(groupByClause);\r\n\t\t\t}\r\n\r\n\t\t\tif(SqlStringHelper.IsNotEmpty(havingClause))\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(\" HAVING \")\r\n\t\t\t\t\t.Add(havingClause);\r\n\t\t\t}\r\n\r\n\t\t\tif (SqlStringHelper.IsNotEmpty(orderByClause))\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(\" ORDER BY \")\r\n\t\t\t\t\t.Add(orderByClause);\r\n\t\t\t}\r\n\r\n\t\t\tif (lockMode != null)\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(Dialect.GetForUpdateString(lockMode));\r\n\t\t\t}\r\n\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t{\r\n\t\t\t\tif (initialCapacity < sqlBuilder.Count)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\r\n\t\t\t\t\t\t\"The initial capacity was set too low at: \" + initialCapacity + \" for the SelectSqlBuilder \" +\r\n\t\t\t\t\t\t\"that needed a capacity of: \" + sqlBuilder.Count + \" for the table \" + fromClause);\r\n\t\t\t\t}\r\n\t\t\t\telse if (initialCapacity > 16 && ((float) initialCapacity / sqlBuilder.Count) > 1.2)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\r\n\t\t\t\t\t\t\"The initial capacity was set too high at: \" + initialCapacity + \" for the SelectSqlBuilder \" +\r\n\t\t\t\t\t\t\"that needed a capacity of: \" + sqlBuilder.Count + \" for the table \" + fromClause);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn sqlBuilder.ToSqlString();\r\n\t\t}",
      "nStatementSyntax": 15,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\SqlSelectBuilder.cs",
      "SourceLine": 201
    }
  ],
  [
    {
      "TypeIdentifier": "AbstractDetachedQuery",
      "MethodIdentifier": "SetQueryProperties",
      "SourcesSample": "protected void SetQueryProperties(IQuery q)\r\n\t\t{\r\n\t\t\tq.SetMaxResults(selection.MaxRows)\r\n\t\t\t\t.SetFirstResult(selection.FirstRow)\r\n\t\t\t\t.SetCacheable(cacheable)\r\n\t\t\t\t.SetReadOnly(readOnly)\r\n\t\t\t\t.SetTimeout(selection.Timeout)\r\n\t\t\t\t.SetFlushMode(flushMode)\r\n\t\t\t\t.SetFetchSize(selection.FetchSize);\r\n\t\t\tif (!string.IsNullOrEmpty(comment))\r\n\t\t\t\tq.SetComment(comment);\r\n\t\t\tif (!string.IsNullOrEmpty(cacheRegion))\r\n\t\t\t\tq.SetCacheRegion(cacheRegion);\r\n\t\t\tif (resultTransformer != null)\r\n\t\t\t\tq.SetResultTransformer(resultTransformer);\r\n\t\t\tif (cacheMode.HasValue)\r\n\t\t\t\tq.SetCacheMode(cacheMode.Value);\r\n\t\t\tforeach (KeyValuePair<string, LockMode> mode in lockModes)\r\n\t\t\t\tq.SetLockMode(mode.Key, mode.Value);\r\n\r\n\t\t\t// Set AbstractQueryImpl property before set parameters\r\n\t\t\tvar aqi = q as AbstractQueryImpl;\r\n\t\t\tif (aqi != null)\r\n\t\t\t\taqi.SetIgnoreUknownNamedParameters(shouldIgnoredUnknownNamedParameters);\r\n\r\n\t\t\t// Even if the probably that somebody use a mixed technique to set parameters \r\n\t\t\t// (from POCO using SetProperties and using named parameter setters) here is a possible\r\n\t\t\t// difference between IQuery and DetachedQuery behaviour.\r\n\t\t\t// In IQuery we don't know who override a param value; in DetachedQuery the direct use of \r\n\t\t\t// a named parameter setter override the param value set by SetProperties(POCO)\r\n\t\t\tforeach (var obj in optionalUntypeParams)\r\n\t\t\t\tq.SetProperties(obj);\r\n\r\n\t\t\t// Set untyped positional parameters\r\n\t\t\tforeach (var pup in posUntypeParams)\r\n\t\t\t\tq.SetParameter(pup.Key, pup.Value);\r\n\r\n\t\t\t// Set untyped named parameters\r\n\t\t\tforeach (var nup in namedUntypeParams)\r\n\t\t\t\tq.SetParameter(nup.Key, nup.Value);\r\n\r\n\t\t\t// Set untyped named parameters list\r\n\t\t\tforeach (var nulp in namedUntypeListParams)\r\n\t\t\t\tq.SetParameterList(nulp.Key, nulp.Value);\r\n\r\n\t\t\t// Set typed positional parameters\r\n\t\t\tforeach (var pp in posParams)\r\n\t\t\t\tq.SetParameter(pp.Key, pp.Value.Value, pp.Value.Type);\r\n\r\n\t\t\t// Set typed named parameters\r\n\t\t\tforeach (var np in namedParams)\r\n\t\t\t\tq.SetParameter(np.Key, np.Value.Value, np.Value.Type);\r\n\r\n\t\t\t// Set typed named parameters List\r\n\t\t\tforeach (var nlp in namedListParams)\r\n\t\t\t\tq.SetParameterList(nlp.Key, (IEnumerable) nlp.Value.Value, nlp.Value.Type);\r\n\t\t}",
      "nStatementSyntax": 14,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Impl\\AbstractDetachedQuery.cs",
      "SourceLine": 419
    }
  ],
  [
    {
      "TypeIdentifier": "BasicLazyInitializer",
      "MethodIdentifier": "Invoke",
      "SourcesSample": "public virtual object Invoke(MethodInfo method, object[] args, object proxy)\r\n\t\t{\r\n\t\t\tstring methodName = method.Name;\r\n\t\t\tint paramCount = method.GetParameters().Length;\r\n\r\n\t\t\tif (paramCount == 0)\r\n\t\t\t{\r\n\t\t\t\tif (!overridesEquals && methodName == \"GetHashCode\")\r\n\t\t\t\t{\r\n\t\t\t\t\treturn IdentityEqualityComparer.GetHashCode(proxy);\r\n\t\t\t\t}\r\n\t\t\t\telse if (IsUninitialized && IsEqualToIdentifierMethod(method))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn Identifier;\r\n\t\t\t\t}\r\n\t\t\t\telse if (methodName == \"Dispose\")\r\n\t\t\t\t{\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\telse if (\"get_HibernateLazyInitializer\".Equals(methodName))\r\n\t\t\t\t{\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (paramCount == 1)\r\n\t\t\t{\r\n\t\t\t\tif (!overridesEquals && methodName == \"Equals\")\r\n\t\t\t\t{\r\n\t\t\t\t\treturn IdentityEqualityComparer.Equals(args[0], proxy);\r\n\t\t\t\t}\r\n\t\t\t\telse if (setIdentifierMethod!=null&&method.Equals(setIdentifierMethod))\r\n\t\t\t\t{\r\n\t\t\t\t\tInitialize();\r\n\t\t\t\t\tIdentifier = args[0];\r\n\t\t\t\t\treturn InvokeImplementation;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (paramCount == 2)\r\n\t\t\t{\r\n\t\t\t\t// if the Proxy Engine delegates the call of GetObjectData to the Initializer\r\n\t\t\t\t// then we need to handle it.  Castle.DynamicProxy takes care of serializing\r\n\t\t\t\t// proxies for us, but other providers might not.\r\n\t\t\t\tif (methodName == \"GetObjectData\")\r\n\t\t\t\t{\r\n\t\t\t\t\tSerializationInfo info = (SerializationInfo)args[0];\r\n\t\t\t\t\tStreamingContext context = (StreamingContext)args[1]; // not used !?!\r\n\r\n\t\t\t\t\tif (Target == null & Session != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tEntityKey key = Session.GenerateEntityKey(Identifier, Session.Factory.GetEntityPersister(EntityName));\r\n\t\t\t\t\t\tobject entity = Session.PersistenceContext.GetEntity(key);\r\n\t\t\t\t\t\tif (entity != null)\r\n\t\t\t\t\t\t\tSetImplementation(entity);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// let the specific ILazyInitializer write its requirements for deserialization \r\n\t\t\t\t\t// into the stream.\r\n\t\t\t\t\tAddSerializationInfo(info, context);\r\n\r\n\t\t\t\t\t// don't need a return value for proxy.\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//if it is a property of an embedded component, invoke on the \"identifier\"\r\n\t\t\tif (componentIdType != null && componentIdType.IsMethodOf(method))\r\n\t\t\t{\r\n\t\t\t\treturn method.Invoke(Identifier, args);\r\n\t\t\t}\r\n\r\n\t\t\treturn InvokeImplementation;\r\n\t\t}",
      "nStatementSyntax": 14,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Proxy\\Poco\\BasicLazyInitializer.cs",
      "SourceLine": 64
    }
  ],
  [
    {
      "TypeIdentifier": "MsSqlSelectParser",
      "MethodIdentifier": "ParseColumnDefinitions",
      "SourcesSample": "private IEnumerable<ColumnDefinition> ParseColumnDefinitions(IEnumerator<SqlToken> tokenEnum)\r\n\t\t{\r\n\t\t\tint blockLevel = 0;\r\n\t\t\tSqlToken columnBeginToken = null;\r\n\t\t\tSqlToken columnEndToken = null;\r\n\t\t\tSqlToken columnAliasToken = null;\r\n\r\n\t\t\tSqlToken prevToken = null;\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\tvar token = tokenEnum.Current;\r\n\t\t\t\tif (token == null) break;\r\n\r\n\t\t\t\tcolumnBeginToken = columnBeginToken ?? token;\r\n\r\n\t\t\t\tswitch (token.TokenType)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase SqlTokenType.BracketOpen:\r\n\t\t\t\t\t\tblockLevel++;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase SqlTokenType.BracketClose:\r\n\t\t\t\t\t\tblockLevel--;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase SqlTokenType.Text:\r\n\t\t\t\t\t\tif (blockLevel != 0) break;\r\n\r\n\t\t\t\t\t\tif (token.Equals(\",\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (columnAliasToken != null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tyield return ParseSelectColumnDefinition(columnBeginToken, columnEndToken ?? columnAliasToken, columnAliasToken);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (token.Equals(\"from\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (columnAliasToken != null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tyield return ParseSelectColumnDefinition(columnBeginToken, columnEndToken ?? columnAliasToken, columnAliasToken);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tyield break;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (token.Equals(\"as\", StringComparison.InvariantCultureIgnoreCase))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcolumnEndToken = prevToken;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcolumnAliasToken = token;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase SqlTokenType.DelimitedText:\r\n\t\t\t\t\t\tif (blockLevel != 0) break;\r\n\r\n\t\t\t\t\t\tcolumnAliasToken = token;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase SqlTokenType.Comma:\r\n\t\t\t\t\t\tif (blockLevel != 0) break;\r\n\r\n\t\t\t\t\t\tif (columnAliasToken != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tyield return ParseSelectColumnDefinition(columnBeginToken, columnEndToken ?? columnAliasToken, columnAliasToken);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcolumnBeginToken = columnEndToken = columnAliasToken = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprevToken = token;\r\n\t\t\t} while (tokenEnum.MoveNext());\r\n\r\n\t\t\tif (columnAliasToken != null)\r\n\t\t\t{\r\n\t\t\t\tyield return ParseSelectColumnDefinition(columnBeginToken, columnEndToken ?? columnAliasToken, columnAliasToken);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 14,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\Parser\\MsSqlSelectParser.cs",
      "SourceLine": 108
    }
  ],
  [
    {
      "TypeIdentifier": "MasterDetailTest",
      "MethodIdentifier": "NonLazyBidirectional",
      "SourcesSample": "[Test]\r\n\t\tpublic void NonLazyBidirectional()\r\n\t\t{\r\n\t\t\tSingle sin = new Single();\r\n\t\t\tsin.Id = \"asfdfds\";\r\n\t\t\tsin.String = \"adsa asdfasd\";\r\n\t\t\tSeveral sev = new Several();\r\n\t\t\tsev.Id = \"asdfasdfasd\";\r\n\t\t\tsev.String = \"asd ddd\";\r\n\t\t\tsin.Several.Add(sev);\r\n\t\t\tsev.Single = sin;\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.Save(sin);\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tsin = (Single) s.Load(typeof(Single), sin);\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tsev = (Several) s.Load(typeof(Several), sev);\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(\"from s in class Several\").List();\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.CreateQuery(\"from s in class Single\").List();\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.Delete(\"from Single\");\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Legacy\\MasterDetailTest.cs",
      "SourceLine": 307
    }
  ],
  [
    {
      "TypeIdentifier": "Column",
      "MethodIdentifier": "Equals",
      "SourcesSample": "public override bool Equals(object obj)\r\n\t\t{\r\n\t\t\tif (this == obj)\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (obj == null)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (GetType() != obj.GetType())\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tColumn other = (Column) obj;\r\n\t\t\tif (null == _systemId)\r\n\t\t\t{\r\n\t\t\t\tif (null != other._systemId)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (!_systemId.Equals(other._systemId))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (null == _tableName)\r\n\t\t\t{\r\n\t\t\t\tif (null != other._tableName)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (!_tableName.Equals(other._tableName))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (null == _columnName)\r\n\t\t\t{\r\n\t\t\t\tif (null != other._columnName)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (!_columnName.Equals(other._columnName))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\NHSpecificTest\\NH1405\\Column.cs",
      "SourceLine": 62
    }
  ],
  [
    {
      "TypeIdentifier": "EntityUpdateAction",
      "MethodIdentifier": "Execute",
      "SourcesSample": "public override void Execute()\r\n\t\t{\r\n\t\t\tISessionImplementor session = Session;\r\n\t\t\tobject id = Id;\r\n\t\t\tIEntityPersister persister = Persister;\r\n\t\t\tobject instance = Instance;\r\n\r\n\t\t\tbool statsEnabled = Session.Factory.Statistics.IsStatisticsEnabled;\r\n\t\t\tStopwatch stopwatch = null;\r\n\t\t\tif (statsEnabled)\r\n\t\t\t{\r\n\t\t\t\tstopwatch = Stopwatch.StartNew();\r\n\t\t\t}\r\n\r\n\t\t\tbool veto = PreUpdate();\r\n\r\n\t\t\tISessionFactoryImplementor factory = Session.Factory;\r\n\r\n\t\t\tif (persister.IsVersionPropertyGenerated)\r\n\t\t\t{\r\n\t\t\t\t// we need to grab the version value from the entity, otherwise\r\n\t\t\t\t// we have issues with generated-version entities that may have\r\n\t\t\t\t// multiple actions queued during the same flush\r\n\t\t\t\tpreviousVersion = persister.GetVersion(instance, session.EntityMode);\r\n\t\t\t}\r\n\r\n\t\t\tCacheKey ck = null;\r\n\t\t\tif (persister.HasCache)\r\n\t\t\t{\r\n\t\t\t\tck = session.GenerateCacheKey(id, persister.IdentifierType, persister.RootEntityName);\r\n\t\t\t\tslock = persister.Cache.Lock(ck, previousVersion);\r\n\t\t\t}\r\n\r\n\t\t\tif (!veto)\r\n\t\t\t{\r\n\t\t\t\tpersister.Update(id, state, dirtyFields, hasDirtyCollection, previousState, previousVersion, instance, null, session);\r\n\t\t\t}\r\n\r\n\t\t\tEntityEntry entry = Session.PersistenceContext.GetEntry(instance);\r\n\t\t\tif (entry == null)\r\n\t\t\t{\r\n\t\t\t\tthrow new AssertionFailure(\"Possible nonthreadsafe access to session\");\r\n\t\t\t}\r\n\r\n\t\t\tif (entry.Status == Status.Loaded || persister.IsVersionPropertyGenerated)\r\n\t\t\t{\r\n\t\t\t\t// get the updated snapshot of the entity state by cloning current state;\r\n\t\t\t\t// it is safe to copy in place, since by this time no-one else (should have)\r\n\t\t\t\t// has a reference  to the array\r\n\t\t\t\tTypeHelper.DeepCopy(state, persister.PropertyTypes, persister.PropertyCheckability, state, Session);\r\n\t\t\t\tif (persister.HasUpdateGeneratedProperties)\r\n\t\t\t\t{\r\n\t\t\t\t\t// this entity defines property generation, so process those generated\r\n\t\t\t\t\t// values...\r\n\t\t\t\t\tpersister.ProcessUpdateGeneratedProperties(id, instance, state, Session);\r\n\t\t\t\t\tif (persister.IsVersionPropertyGenerated)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnextVersion = Versioning.GetVersion(state, persister);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// have the entity entry perform post-update processing, passing it the\r\n\t\t\t\t// update state and the new version (if one).\r\n\t\t\t\tentry.PostUpdate(instance, state, nextVersion);\r\n\t\t\t}\r\n\r\n\t\t\tif (persister.HasCache)\r\n\t\t\t{\r\n\t\t\t\tif (persister.IsCacheInvalidationRequired || entry.Status != Status.Loaded)\r\n\t\t\t\t{\r\n\t\t\t\t\tpersister.Cache.Evict(ck);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tCacheEntry ce = new CacheEntry(state, persister, persister.HasUninitializedLazyProperties(instance, session.EntityMode), nextVersion, Session, instance);\r\n\t\t\t\t\tcacheEntry = persister.CacheEntryStructure.Structure(ce);\r\n\r\n\t\t\t\t\tbool put = persister.Cache.Update(ck, cacheEntry, nextVersion, previousVersion);\r\n\r\n\t\t\t\t\tif (put && factory.Statistics.IsStatisticsEnabled)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfactory.StatisticsImplementor.SecondLevelCachePut(Persister.Cache.RegionName);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tPostUpdate();\r\n\r\n\t\t\tif (statsEnabled && !veto)\r\n\t\t\t{\r\n\t\t\t\tstopwatch.Stop();\r\n\t\t\t\tfactory.StatisticsImplementor.UpdateEntity(Persister.EntityName, stopwatch.Elapsed);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Action\\EntityUpdateAction.cs",
      "SourceLine": 43
    }
  ],
  [
    {
      "TypeIdentifier": "ParameterParser",
      "MethodIdentifier": "Parse",
      "SourcesSample": "public static void Parse(string sqlString, IRecognizer recognizer)\r\n\t\t{\r\n\t\t\t// TODO: WTF? \"CALL\"... it may work for ORACLE but what about others RDBMS ? (by FM)\r\n\t\t\tbool hasMainOutputParameter = sqlString.IndexOf(\"call\") > 0 &&\r\n\t\t\t\t\t\t\t\t\t\t  sqlString.IndexOf(\"?\") > 0 &&\r\n\t\t\t\t\t\t\t\t\t\t  sqlString.IndexOf(\"=\") > 0 &&\r\n\t\t\t\t\t\t\t\t\t\t  sqlString.IndexOf(\"?\") < sqlString.IndexOf(\"call\") &&\r\n\t\t\t\t\t\t\t\t\t\t  sqlString.IndexOf(\"=\") < sqlString.IndexOf(\"call\");\r\n\t\t\tbool foundMainOutputParam = false;\r\n\r\n\t\t\tint stringLength = sqlString.Length;\r\n\t\t\tbool inQuote = false;\r\n\t\t\tbool afterNewLine = false;\r\n\t\t\tfor (int indx = 0; indx < stringLength; indx++)\r\n\t\t\t{\r\n\t\t\t\t// check comments\r\n\t\t\t\tif (indx + 1 < stringLength && sqlString.Substring(indx,2) == \"/*\")\r\n\t\t\t\t{\r\n\t\t\t\t\tvar closeCommentIdx = sqlString.IndexOf(\"*/\", indx+2);\r\n\t\t\t\t\trecognizer.Other(sqlString.Substring(indx, (closeCommentIdx- indx)+2));\r\n\t\t\t\t\tindx = closeCommentIdx + 1;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (afterNewLine && (indx + 1 < stringLength) && sqlString.Substring(indx, 2) == \"--\")\r\n\t\t\t\t{\r\n\t\t\t\t\tvar closeCommentIdx = sqlString.IndexOf(Environment.NewLine, indx + 2);\r\n\t\t\t\t\tstring comment;\r\n\t\t\t\t\tif (closeCommentIdx == -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcloseCommentIdx = sqlString.Length;\r\n\t\t\t\t\t\tcomment = sqlString.Substring(indx);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcomment = sqlString.Substring(indx, closeCommentIdx - indx + Environment.NewLine.Length);\r\n\t\t\t\t\t}\r\n\t\t\t\t\trecognizer.Other(comment);\r\n\t\t\t\t\tindx = closeCommentIdx + NewLineLength - 1;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (indx + NewLineLength -1 < stringLength && sqlString.Substring(indx, NewLineLength) == Environment.NewLine)\r\n\t\t\t\t{\r\n\t\t\t\t\tafterNewLine = true;\r\n\t\t\t\t\tindx += NewLineLength - 1;\r\n\t\t\t\t\trecognizer.Other(Environment.NewLine);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tafterNewLine = false;\r\n\r\n\t\t\t\tchar c = sqlString[indx];\r\n\t\t\t\tif (inQuote)\r\n\t\t\t\t{\r\n\t\t\t\t\tif ('\\'' == c)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tinQuote = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trecognizer.Other(c);\r\n\t\t\t\t}\r\n\t\t\t\telse if ('\\'' == c)\r\n\t\t\t\t{\r\n\t\t\t\t\tinQuote = true;\r\n\t\t\t\t\trecognizer.Other(c);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (c == ':')\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// named parameter\r\n\t\t\t\t\t\tint right = StringHelper.FirstIndexOfChar(sqlString, ParserHelper.HqlSeparators, indx + 1);\r\n\t\t\t\t\t\tint chopLocation = right < 0 ? sqlString.Length : right;\r\n\t\t\t\t\t\tstring param = sqlString.Substring(indx + 1, chopLocation - (indx + 1));\r\n\t\t\t\t\t\trecognizer.NamedParameter(param, indx);\r\n\t\t\t\t\t\tindx = chopLocation - 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (c == '?')\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// could be either an ordinal or ejb3-positional parameter\r\n\t\t\t\t\t\tif (indx < stringLength - 1 && char.IsDigit(sqlString[indx + 1]))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// a peek ahead showed this as an ejb3-positional parameter\r\n\t\t\t\t\t\t\tint right = StringHelper.FirstIndexOfChar(sqlString, ParserHelper.HqlSeparators, indx + 1);\r\n\t\t\t\t\t\t\tint chopLocation = right < 0 ? sqlString.Length : right;\r\n\t\t\t\t\t\t\tstring param = sqlString.Substring(indx + 1, chopLocation - (indx + 1));\r\n\t\t\t\t\t\t\t// make sure this \"name\" is an integral\r\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tint.Parse(param);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch (FormatException e)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tthrow new QueryException(\"ejb3-style positional param was not an integral ordinal\", e);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\trecognizer.JpaPositionalParameter(param, indx);\r\n\t\t\t\t\t\t\tindx = chopLocation - 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (hasMainOutputParameter && !foundMainOutputParam)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tfoundMainOutputParam = true;\r\n\t\t\t\t\t\t\t\trecognizer.OutParameter(indx);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\trecognizer.OrdinalParameter(indx);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trecognizer.Other(c);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Engine\\Query\\ParameterParser.cs",
      "SourceLine": 43
    }
  ],
  [
    {
      "TypeIdentifier": "AbstractCollectionPersister",
      "MethodIdentifier": "DeleteRows",
      "SourcesSample": "public void DeleteRows(IPersistentCollection collection, object id, ISessionImplementor session)\r\n\t\t{\r\n\t\t\tif (!isInverse && RowDeleteEnabled)\r\n\t\t\t{\r\n\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"Deleting rows of collection: \" + MessageHelper.InfoString(this, id));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbool deleteByIndex = !IsOneToMany && hasIndex && !indexContainsFormula;\r\n\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\t// delete all the deleted entries\r\n\t\t\t\t\tIEnumerator deletes = collection.GetDeletes(this, !deleteByIndex).GetEnumerator();\r\n\t\t\t\t\tif (deletes.MoveNext())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdeletes.Reset();\r\n\t\t\t\t\t\tint offset = 0;\r\n\t\t\t\t\t\tint count = 0;\r\n\r\n\t\t\t\t\t\twhile (deletes.MoveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tIDbCommand st;\r\n\t\t\t\t\t\t\tIExpectation expectation = Expectations.AppropriateExpectation(deleteCheckStyle);\r\n\t\t\t\t\t\t\t//bool callable = DeleteCallable;\r\n\r\n\t\t\t\t\t\t\tbool useBatch = expectation.CanBeBatched;\r\n\t\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tst =\r\n\t\t\t\t\t\t\t\t\tsession.Batcher.PrepareBatchCommand(SqlDeleteRowString.CommandType, SqlDeleteRowString.Text,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSqlDeleteRowString.ParameterTypes);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tst =\r\n\t\t\t\t\t\t\t\t\tsession.Batcher.PrepareCommand(SqlDeleteRowString.CommandType, SqlDeleteRowString.Text,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   SqlDeleteRowString.ParameterTypes);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tobject entry = deletes.Current;\r\n\t\t\t\t\t\t\t\tint loc = offset;\r\n\t\t\t\t\t\t\t\tif (hasIdentifier)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tWriteIdentifier(st, entry, loc, session);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tloc = WriteKey(st, id, loc, session);\r\n\r\n\t\t\t\t\t\t\t\t\tif (deleteByIndex)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tWriteIndexToWhere(st, entry, loc, session);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tWriteElementToWhere(st, entry, loc, session);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tsession.Batcher.AddToBatch(expectation);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\texpectation.VerifyOutcomeNonBatched(session.Batcher.ExecuteNonQuery(st), st);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch (Exception e)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tsession.Batcher.AbortBatch(e);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tthrow;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif (!useBatch)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tsession.Batcher.CloseCommand(st, null);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlog.Debug(\"done deleting collection rows: \" + count + \" deleted\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlog.Debug(\"no rows to delete\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch (DbException sqle)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow ADOExceptionHelper.Convert(sqlExceptionConverter, sqle,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"could not delete collection rows: \" + MessageHelper.InfoString(this, id));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Persister\\Collection\\AbstractCollectionPersister.cs",
      "SourceLine": 1135
    }
  ],
  [
    {
      "TypeIdentifier": "SqlInsertBuilder",
      "MethodIdentifier": "ToSqlString",
      "SourcesSample": "public virtual SqlString ToSqlString()\r\n\t\t{\r\n\t\t\t// 5 = \"INSERT INTO\", tableName, \" (\" , \") VALUES (\", and \")\"\r\n\t\t\tint initialCapacity = 5;\r\n\r\n\t\t\t// 2 = the first column is just the columnName and columnValue\r\n\t\t\tinitialCapacity += 2;\r\n\r\n\t\t\t// eachColumn after the first one is 4 because of the \", \", columnName \r\n\t\t\t// and the \", \" columnValue\r\n\t\t\tif (columns.Count > 0)\r\n\t\t\t{\r\n\t\t\t\tinitialCapacity += ((columns.Count - 1) * 4);\r\n\t\t\t}\r\n\r\n\t\t\tif (!string.IsNullOrEmpty(comment))\r\n\t\t\t\tinitialCapacity++;\r\n\r\n\t\t\tSqlStringBuilder sqlBuilder = new SqlStringBuilder(initialCapacity + 2);\r\n\t\t\tif (!string.IsNullOrEmpty(comment))\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(\"/* \" + comment + \" */ \");\r\n\t\t\t}\r\n\r\n\t\t\tsqlBuilder.Add(\"INSERT INTO \")\r\n\t\t\t\t.Add(tableName);\r\n\r\n\t\t\tif (columns.Count == 0)\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(\" \").Add(factory.Dialect.NoColumnsInsertString);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tsqlBuilder.Add(\" (\");\r\n\r\n\t\t\t\t// do we need a comma before we add the column to the INSERT list\r\n\t\t\t\t// when we get started the first column doesn't need one.\r\n\t\t\t\tbool commaNeeded = false;\r\n\t\t\t\tforeach (string columnName in columns.Keys)\r\n\t\t\t\t{\r\n\t\t\t\t\t// build up the column list\r\n\t\t\t\t\tif (commaNeeded)\r\n\t\t\t\t\t\tsqlBuilder.Add(StringHelper.CommaSpace);\r\n\t\t\t\t\tcommaNeeded = true;\r\n\r\n\t\t\t\t\tsqlBuilder.Add(columnName);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsqlBuilder.Add(\") VALUES (\");\r\n\r\n\t\t\t\tcommaNeeded = false;\r\n\t\t\t\tforeach (object obj in columns.Values)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (commaNeeded)\r\n\t\t\t\t\t\tsqlBuilder.Add(StringHelper.CommaSpace);\r\n\t\t\t\t\tcommaNeeded = true;\r\n\r\n\t\t\t\t\tSqlType param = obj as SqlType;\r\n\t\t\t\t\tif (param != null)\r\n\t\t\t\t\t\tsqlBuilder.Add(Parameter.Placeholder);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tsqlBuilder.Add((string) obj);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsqlBuilder.Add(\")\");\r\n\t\t\t}\r\n\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t{\r\n\t\t\t\tif (initialCapacity < sqlBuilder.Count)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\r\n\t\t\t\t\t\t\"The initial capacity was set too low at: \" + initialCapacity + \" for the InsertSqlBuilder \" +\r\n\t\t\t\t\t\t\"that needed a capacity of: \" + sqlBuilder.Count + \" for the table \" + tableName);\r\n\t\t\t\t}\r\n\t\t\t\telse if (initialCapacity > 16 && ((float) initialCapacity / sqlBuilder.Count) > 1.2)\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\r\n\t\t\t\t\t\t\"The initial capacity was set too high at: \" + initialCapacity + \" for the InsertSqlBuilder \" +\r\n\t\t\t\t\t\t\"that needed a capacity of: \" + sqlBuilder.Count + \" for the table \" + tableName);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn sqlBuilder.ToSqlString();\r\n\t\t}",
      "nStatementSyntax": 13,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\SqlInsertBuilder.cs",
      "SourceLine": 115
    }
  ],
  [
    {
      "TypeIdentifier": "HQLFunctions",
      "MethodIdentifier": "Cast",
      "SourcesSample": "[Test]\r\n\t\tpublic void Cast()\r\n\t\t{\r\n\t\t\tconst double magicResult = 7 + 123 - 5*1.3d;\r\n\r\n\t\t\tIgnoreIfNotSupported(\"cast\");\r\n\t\t\t// The cast is used to test various cases of a function render\r\n\t\t\t// Cast was selected because represent a special case for:\r\n\t\t\t// 1) Has more then 1 argument\r\n\t\t\t// 2) The argument separator is \"as\" (for the other function is ',' or ' ')\r\n\t\t\t// 3) The ReturnType is not fixed (depend on a column type)\r\n\t\t\t// 4) The 2th argument is parsed by NH and traslated for a specific Dialect (can't be interpreted directly by RDBMS)\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t{\r\n\t\t\t\tAnimal a1 = new Animal(\"abcdef\", 1.3f);\r\n\t\t\t\ts.Save(a1);\r\n\t\t\t\ts.Flush();\r\n\t\t\t}\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t{\r\n\t\t\t\tstring hql;\r\n\t\t\t\tIList l;\r\n\t\t\t\tAnimal result;\r\n\t\t\t\t// Rendered in SELECT using a property \r\n\t\t\t\thql = \"select cast(a.BodyWeight as Double) from Animal a\";\r\n\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\tAssert.That(l[0], Is.TypeOf(typeof (double)));\r\n\r\n\t\t\t\t// Rendered in SELECT using a property in an operation with costant \r\n\t\t\t\thql = \"select cast(7+123-5*a.BodyWeight as Double) from Animal a\";\r\n\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\tAssert.AreEqual(magicResult, (double)l[0], 0.00001);\r\n\r\n\t\t\t\t// Rendered in SELECT using a property and nested functions\r\n\t\t\t\tif (!(Dialect is Oracle8iDialect))\r\n\t\t\t\t{\r\n\t\t\t\t\thql = \"select cast(cast(a.BodyWeight as string) as Double) from Animal a\";\r\n\t\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\t\tAssert.That(l[0], Is.TypeOf(typeof(double)));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: Rendered in SELECT using string costant assigned with critic chars (separators)\r\n\r\n\t\t\t\t// Rendered in WHERE using a property \r\n\t\t\t\tif (!(Dialect is Oracle8iDialect))\r\n\t\t\t\t{\r\n\t\t\t\t\thql = \"from Animal a where cast(a.BodyWeight as string) like '1.%'\";\r\n\t\t\t\t\tresult = (Animal) s.CreateQuery(hql).UniqueResult();\r\n\t\t\t\t\tAssert.AreEqual(\"abcdef\", result.Description);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Rendered in WHERE using a property in an operation with costants\r\n\t\t\t\thql = \"from Animal a where cast(7+123-2*a.BodyWeight as Double)>0\";\r\n\t\t\t\tresult = (Animal)s.CreateQuery(hql).UniqueResult();\r\n\t\t\t\tAssert.AreEqual(\"abcdef\", result.Description);\r\n\r\n\t\t\t\t// Rendered in WHERE using a property and named param\r\n\t\t\t\thql = \"from Animal a where cast(:aParam+a.BodyWeight as Double)>0\";\r\n\t\t\t\tresult = (Animal)s.CreateQuery(hql)\r\n\t\t\t\t\t.SetDouble(\"aParam\", 2D)\r\n\t\t\t\t\t.UniqueResult();\r\n\t\t\t\tAssert.AreEqual(\"abcdef\", result.Description);\r\n\r\n\t\t\t\t// Rendered in WHERE using a property and nested functions\r\n\t\t\t\tif (!(Dialect is Oracle8iDialect))\r\n\t\t\t\t{\r\n\t\t\t\t\thql = \"from Animal a where cast(cast(cast(a.BodyWeight as string) as double) as int) = 1\";\r\n\t\t\t\t\tresult = (Animal) s.CreateQuery(hql).UniqueResult();\r\n\t\t\t\t\tAssert.AreEqual(\"abcdef\", result.Description);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Rendered in GROUP BY using a property \r\n\t\t\t\thql = \"select cast(a.BodyWeight as Double) from Animal a group by cast(a.BodyWeight as Double)\";\r\n\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\tAssert.That(l[0], Is.TypeOf(typeof(double)));\r\n\r\n\t\t\t\t// Rendered in GROUP BY using a property in an operation with costant \r\n\t\t\t\thql = \"select cast(7+123-5*a.BodyWeight as Double) from Animal a group by cast(7+123-5*a.BodyWeight as Double)\";\r\n\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\tAssert.AreEqual(magicResult, (double)l[0], 0.00001);\r\n\r\n\t\t\t\t// Rendered in GROUP BY using a property and nested functions\r\n\t\t\t\tif (!(Dialect is Oracle8iDialect))\r\n\t\t\t\t{\r\n\t\t\t\t\thql =\r\n\t\t\t\t\t\t\"select cast(cast(a.BodyWeight as string) as Double) from Animal a group by cast(cast(a.BodyWeight as string) as Double)\";\r\n\t\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\t\tAssert.That(l[0], Is.TypeOf(typeof(double)));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Rendered in HAVING using a property \r\n\t\t\t\thql = \"select cast(a.BodyWeight as Double) from Animal a group by cast(a.BodyWeight as Double) having cast(a.BodyWeight as Double)>0\";\r\n\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\tAssert.That(l[0], Is.TypeOf(typeof(double)));\r\n\r\n\t\t\t\t// Rendered in HAVING using a property in an operation with costants\r\n\t\t\t\thql = \"select cast(7+123.3-1*a.BodyWeight as int) from Animal a group by cast(7+123.3-1*a.BodyWeight as int) having cast(7+123.3-1*a.BodyWeight as int)>0\";\r\n\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\tAssert.AreEqual((int)(7 + 123.3 - 1 * 1.3d), l[0]);\r\n\r\n\t\t\t\t// Rendered in HAVING using a property and named param (NOT SUPPORTED)\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\thql = \"select cast(:aParam+a.BodyWeight as int) from Animal a group by cast(:aParam+a.BodyWeight as int) having cast(:aParam+a.BodyWeight as int)>0\";\r\n\t\t\t\t\tl = s.CreateQuery(hql).SetInt32(\"aParam\", 10).List();\r\n\t\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\t\tAssert.AreEqual(11, l[0]);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (QueryException ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!(ex.InnerException is NotSupportedException))\r\n\t\t\t\t\t\tthrow;\r\n\t\t\t\t}\r\n\t\t\t\tcatch (ADOException ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Dialect is Oracle8iDialect)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!ex.InnerException.Message.StartsWith(\"ORA-00979\"))\r\n\t\t\t\t\t\t\tthrow;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tstring msgToCheck =\r\n\t\t\t\t\t\t\t\"Column 'Animal.BodyWeight' is invalid in the HAVING clause because it is not contained in either an aggregate function or the GROUP BY clause.\";\r\n\t\t\t\t\t\t// This test raises an exception in SQL Server because named \r\n\t\t\t\t\t\t// parameters internally are always positional (@p0, @p1, etc.)\r\n\t\t\t\t\t\t// and named differently hence they mismatch between GROUP BY and HAVING clauses.\r\n\t\t\t\t\t\tif (!ex.InnerException.Message.Equals(msgToCheck))\r\n\t\t\t\t\t\t\tthrow;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Rendered in HAVING using a property and nested functions\r\n\t\t\t\tif (!(Dialect is Oracle8iDialect))\r\n\t\t\t\t{\r\n\t\t\t\t\tstring castExpr = \"cast(cast(cast(a.BodyWeight as string) as double) as int)\";\r\n\t\t\t\t\thql = string.Format(\"select {0} from Animal a group by {0} having {0} = 1\", castExpr);\r\n\t\t\t\t\tl = s.CreateQuery(hql).List();\r\n\t\t\t\t\tAssert.AreEqual(1, l.Count);\r\n\t\t\t\t\tAssert.AreEqual(1, l[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Hql\\HQLFunctions.cs",
      "SourceLine": 616
    }
  ],
  [
    {
      "TypeIdentifier": "DefaultMergeEventListener",
      "MethodIdentifier": "OnMerge",
      "SourcesSample": "public virtual void OnMerge(MergeEvent @event, IDictionary copiedAlready)\r\n\t\t{\r\n\t\t\tEventCache copyCache = (EventCache)copiedAlready;\r\n\t\t\tIEventSource source = @event.Session;\r\n\t\t\tobject original = @event.Original;\r\n\r\n\t\t\tif (original != null)\r\n\t\t\t{\r\n\t\t\t\tobject entity;\r\n\t\t\t\tif (original.IsProxy())\r\n\t\t\t\t{\r\n\t\t\t\t\tILazyInitializer li = ((INHibernateProxy)original).HibernateLazyInitializer;\r\n\t\t\t\t\tif (li.IsUninitialized)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlog.Debug(\"ignoring uninitialized proxy\");\r\n\t\t\t\t\t\t@event.Result = source.Load(li.EntityName, li.Identifier);\r\n\t\t\t\t\t\treturn; //EARLY EXIT!\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tentity = li.GetImplementation();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tentity = original;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (copyCache.Contains(entity) && copyCache.IsOperatedOn(entity))\r\n\t\t\t\t{\r\n\t\t\t\t\tlog.Debug(\"already in merge process\");\r\n\t\t\t\t\t@event.Result = entity;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (copyCache.Contains(entity))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlog.Info(\"already in copyCache; setting in merge process\");\r\n\t\t\t\t\t\tcopyCache.SetOperatedOn(entity, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t@event.Entity = entity;\r\n\t\t\t\t\tEntityState entityState = EntityState.Undefined;\r\n\t\t\t\t\tif (ReferenceEquals(null, @event.EntityName))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t@event.EntityName = source.BestGuessEntityName(entity);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check the persistence context for an entry relating to this\r\n\t\t\t\t\t// entity to be merged...\r\n\t\t\t\t\tEntityEntry entry = source.PersistenceContext.GetEntry(entity);\r\n\t\t\t\t\tif (entry == null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tIEntityPersister persister = source.GetEntityPersister(@event.EntityName, entity);\r\n\t\t\t\t\t\tobject id = persister.GetIdentifier(entity, source.EntityMode);\r\n\t\t\t\t\t\tif (id != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tEntityKey key = source.GenerateEntityKey(id, persister);\r\n\t\t\t\t\t\t\tobject managedEntity = source.PersistenceContext.GetEntity(key);\r\n\t\t\t\t\t\t\tentry = source.PersistenceContext.GetEntry(managedEntity);\r\n\t\t\t\t\t\t\tif (entry != null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// we have specialized case of a detached entity from the\r\n\t\t\t\t\t\t\t\t// perspective of the merge operation.  Specifically, we\r\n\t\t\t\t\t\t\t\t// have an incoming entity instance which has a corresponding\r\n\t\t\t\t\t\t\t\t// entry in the current persistence context, but registered\r\n\t\t\t\t\t\t\t\t// under a different entity instance\r\n\t\t\t\t\t\t\t\tentityState = EntityState.Detached;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (entityState == EntityState.Undefined)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tentityState = GetEntityState(entity, @event.EntityName, entry, source);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch (entityState)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase EntityState.Persistent:\r\n\t\t\t\t\t\t\tEntityIsPersistent(@event, copyCache);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase EntityState.Transient:\r\n\t\t\t\t\t\t\tEntityIsTransient(@event, copyCache);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase EntityState.Detached:\r\n\t\t\t\t\t\t\tEntityIsDetached(@event, copyCache);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tthrow new ObjectDeletedException(\"deleted instance passed to merge\", null, GetLoggableName(@event.EntityName, entity));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Event\\Default\\DefaultMergeEventListener.cs",
      "SourceLine": 82
    }
  ],
  [
    {
      "TypeIdentifier": "IndexNode",
      "MethodIdentifier": "Resolve",
      "SourcesSample": "public override void  Resolve(bool generateJoin, bool implicitJoin, string classAlias, IASTNode parent)\r\n\t\t{\r\n\t\t\tif (IsResolved) \r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tFromReferenceNode collectionNode = ( FromReferenceNode ) GetChild(0);\r\n\t\t\tSessionFactoryHelperExtensions sessionFactoryHelper = SessionFactoryHelper;\r\n\t\t\tcollectionNode.ResolveIndex( this );\t\t// Fully resolve the map reference, create implicit joins.\r\n\r\n\t\t\tIType type = collectionNode.DataType;\r\n\t\t\tif ( !type.IsCollectionType ) \r\n\t\t\t{\r\n\t\t\t\tthrow new SemanticException( \"The [] operator cannot be applied to type \" + type);\r\n\t\t\t}\r\n\r\n\t\t\tstring collectionRole = ( ( CollectionType ) type ).Role;\r\n\t\t\tIQueryableCollection queryableCollection = sessionFactoryHelper.RequireQueryableCollection( collectionRole );\r\n\t\t\tif ( !queryableCollection.HasIndex ) \r\n\t\t\t{\r\n\t\t\t\tthrow new QueryException( \"unindexed fromElement before []: \" + collectionNode.Path );\r\n\t\t\t}\r\n\r\n\t\t\t// Generate the inner join -- The elements need to be joined to the collection they are in.\r\n\t\t\tFromElement fromElement = collectionNode.FromElement;\r\n\t\t\tString elementTable = fromElement.TableAlias;\r\n\t\t\tFromClause fromClause = fromElement.FromClause;\r\n\t\t\tString path = collectionNode.Path;\r\n\r\n\t\t\tFromElement elem = fromClause.FindCollectionJoin( path );\r\n\t\t\tif ( elem == null ) \r\n\t\t\t{\r\n\t\t\t\tFromElementFactory factory = new FromElementFactory( fromClause, fromElement, path );\r\n\t\t\t\telem = factory.CreateCollectionElementsJoin( queryableCollection, elementTable );\r\n\t\t\t\tif ( Log.IsDebugEnabled )\r\n\t\t\t\t{\r\n\t\t\t\t\tLog.Debug( \"No FROM element found for the elements of collection join path \" + path\r\n\t\t\t\t\t\t\t+ \", created \" + elem );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse \r\n\t\t\t{\r\n\t\t\t\tif ( Log.IsDebugEnabled ) \r\n\t\t\t\t{\r\n\t\t\t\t\tLog.Debug( \"FROM element found for collection join path \" + path );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// The 'from element' that represents the elements of the collection.\r\n\t\t\tFromElement = fromElement;\r\n\r\n\t\t\t// Add the condition to the join sequence that qualifies the indexed element.\r\n\t\t\tIASTNode selector = GetChild(1);\r\n\t\t\tif ( selector == null ) \r\n\t\t\t{\r\n\t\t\t\tthrow new QueryException( \"No index value!\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Sometimes use the element table alias, sometimes use the... umm... collection table alias (many to many)\r\n\t\t\tString collectionTableAlias = elementTable;\r\n\t\t\tif ( elem.CollectionTableAlias != null ) \r\n\t\t\t{\r\n\t\t\t\tcollectionTableAlias = elem.CollectionTableAlias;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: get SQL rendering out of here, create an AST for the join expressions.\r\n\t\t\t// Use the SQL generator grammar to generate the SQL text for the index expression.\r\n\t\t\tJoinSequence joinSequence = fromElement.JoinSequence;\r\n\t\t\tstring[] indexCols = queryableCollection.IndexColumnNames;\r\n\t\t\tif ( indexCols.Length != 1 ) \r\n\t\t\t{\r\n\t\t\t\tthrow new QueryException( \"composite-index appears in []: \" + collectionNode.Path );\r\n\t\t\t}\r\n\r\n\t\t\tSqlGenerator gen = new SqlGenerator(SessionFactoryHelper.Factory, new CommonTreeNodeStream(selector));\r\n\r\n\t\t\ttry \r\n\t\t\t{\r\n\t\t\t\tgen.simpleExpr(); //TODO: used to be exprNoParens! was this needed?\r\n\t\t\t}\r\n\t\t\tcatch ( RecognitionException e ) \r\n\t\t\t{\r\n\t\t\t\tthrow new QueryException( e.Message, e );\r\n\t\t\t}\r\n\r\n\t\t\tstring selectorExpression = gen.GetSQL().ToString();\r\n\r\n\t\t\tjoinSequence.AddCondition(new SqlString(collectionTableAlias + '.' + indexCols[0] + \" = \" + selectorExpression ));\r\n\t\t\t//joinSequence.AddCondition(collectionTableAlias, new string[] { indexCols[0] }, selectorExpression, false);\r\n\r\n\t\t\tIList<IParameterSpecification> paramSpecs = gen.GetCollectedParameters();\r\n\t\t\tif ( paramSpecs != null ) \r\n\t\t\t{\r\n\t\t\t\tswitch ( paramSpecs.Count ) \r\n\t\t\t\t{\r\n\t\t\t\t\tcase 0 :\r\n\t\t\t\t\t\t// nothing to do\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 1 :\r\n\t\t\t\t\t\tIParameterSpecification paramSpec = paramSpecs[0];\r\n\t\t\t\t\t\tparamSpec.ExpectedType = queryableCollection.IndexType;\r\n\t\t\t\t\t\tfromElement.SetIndexCollectionSelectorParamSpec( paramSpec );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tfromElement.SetIndexCollectionSelectorParamSpec(\r\n\t\t\t\t\t\t\t\tnew AggregatedIndexCollectionSelectorParameterSpecifications( paramSpecs )\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Now, set the text for this node.  It should be the element columns.\r\n\t\t\tString[] elementColumns = queryableCollection.GetElementColumnNames( elementTable );\r\n\t\t\tText = elementColumns[0];\r\n\r\n\t\t    IsResolved = true;\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Tree\\IndexNode.cs",
      "SourceLine": 37
    }
  ],
  [
    {
      "TypeIdentifier": "LiteralProcessor",
      "MethodIdentifier": "SetConstantValue",
      "SourcesSample": "private void SetConstantValue(DotNode node, string text, object value)\r\n\t\t{\r\n\t\t\tif (log.IsDebugEnabled)\r\n\t\t\t{\r\n\t\t\t\tlog.Debug(\"setConstantValue() \" + text + \" -> \" + value + \" \" + value.GetType().Name);\r\n\t\t\t}\r\n\r\n\t\t\tnode.ClearChildren();\t// Chop off the rest of the tree.\r\n\r\n\t\t\tif (value is string)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.QUOTED_String;\r\n\t\t\t}\r\n\t\t\telse if (value is char)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.QUOTED_String;\r\n\t\t\t}\r\n\t\t\telse if (value is byte)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.NUM_INT;\r\n\t\t\t}\r\n\t\t\telse if (value is short)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.NUM_INT;\r\n\t\t\t}\r\n\t\t\telse if (value is int)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.NUM_INT;\r\n\t\t\t}\r\n\t\t\telse if (value is long)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.NUM_LONG;\r\n\t\t\t}\r\n\t\t\telse if (value is double)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.NUM_DOUBLE;\r\n\t\t\t}\r\n\t\t\telse if (value is decimal)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.NUM_DECIMAL;\r\n\t\t\t}\r\n\t\t\telse if (value is float)\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.NUM_FLOAT;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tnode.Type = HqlSqlWalker.CONSTANT;\r\n\t\t\t}\r\n\r\n\t\t\tIType type;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttype = TypeFactory.HeuristicType(value.GetType().Name);\r\n\t\t\t}\r\n\t\t\tcatch (MappingException me)\r\n\t\t\t{\r\n\t\t\t\tthrow new QueryException(me);\r\n\t\t\t}\r\n\r\n\t\t\tif (type == null)\r\n\t\t\t{\r\n\t\t\t\tthrow new QueryException(LiteralProcessor.ErrorCannotDetermineType + node.Text);\r\n\t\t\t}\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tILiteralType literalType = (ILiteralType)type;\r\n\t\t\t\tNHibernate.Dialect.Dialect dialect = _walker.SessionFactoryHelper.Factory.Dialect;\r\n\t\t\t\tnode.Text = literalType.ObjectToSQLString(value, dialect);\r\n\t\t\t}\r\n\t\t\tcatch (Exception e)\r\n\t\t\t{\r\n\t\t\t\tthrow new QueryException(LiteralProcessor.ErrorCannotFormatLiteral + node.Text, e);\r\n\t\t\t}\r\n\r\n\t\t\tnode.DataType = type;\r\n\t\t\tnode.SetResolvedConstant(text);\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Util\\LiteralProcessor.cs",
      "SourceLine": 272
    }
  ],
  [
    {
      "TypeIdentifier": "SyntheticAndFactory",
      "MethodIdentifier": "AddWhereFragment",
      "SourcesSample": "public void AddWhereFragment(\r\n\t\t\t\tJoinFragment joinFragment,\r\n\t\t\t\tSqlString whereFragment,\r\n\t\t\t\tQueryNode query,\r\n\t\t\t\tFromElement fromElement,\r\n\t\t\t\tHqlSqlWalker hqlSqlWalker)\r\n\t\t{\r\n\t\t\tif (whereFragment == null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (!fromElement.UseWhereFragment && !joinFragment.HasThetaJoins)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\twhereFragment = whereFragment.Trim();\r\n\t\t\tif (StringHelper.IsEmpty(whereFragment.ToString()))\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Forcefully remove leading ands from where fragments; the grammar will\r\n\t\t\t// handle adding them\r\n\t\t\tif (whereFragment.StartsWithCaseInsensitive(\"and\"))\r\n\t\t\t{\r\n\t\t\t\twhereFragment = whereFragment.Substring(4);\r\n\t\t\t}\r\n\r\n\t\t\tlog.Debug(\"Using unprocessed WHERE-fragment [\" + whereFragment +\"]\");\r\n\r\n\t\t\tSqlFragment fragment = (SqlFragment) Create(HqlSqlWalker.SQL_TOKEN, whereFragment.ToString());\r\n\r\n\t\t\tfragment.SetJoinFragment(joinFragment);\r\n\t\t\tfragment.FromElement = fromElement;\r\n\r\n\t\t\tif (fromElement.IndexCollectionSelectorParamSpec != null)\r\n\t\t\t{\r\n\t\t\t\tfragment.AddEmbeddedParameter(fromElement.IndexCollectionSelectorParamSpec);\r\n\t\t\t\tfromElement.IndexCollectionSelectorParamSpec = null;\r\n\t\t\t}\r\n\r\n\t\t\tif (hqlSqlWalker.IsFilter())\r\n\t\t\t{\r\n\t\t\t\t//if (whereFragment.IndexOfCaseInsensitive(\"?\") >= 0)\r\n                if (whereFragment.ToString().IndexOf(\"?\") >= 0)\r\n                {\r\n\t\t\t\t\tIType collectionFilterKeyType = hqlSqlWalker.SessionFactoryHelper\r\n\t\t\t\t\t\t\t.RequireQueryableCollection(hqlSqlWalker.CollectionFilterRole)\r\n\t\t\t\t\t\t\t.KeyType;\r\n\t\t\t\t\tCollectionFilterKeyParameterSpecification paramSpec = new CollectionFilterKeyParameterSpecification(\r\n\t\t\t\t\t\t\thqlSqlWalker.CollectionFilterRole,\r\n\t\t\t\t\t\t\tcollectionFilterKeyType,\r\n\t\t\t\t\t\t\t0\r\n\t\t\t\t\t);\r\n\t\t\t\t\tfragment.AddEmbeddedParameter(paramSpec);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tJoinProcessor.ProcessDynamicFilterParameters(\r\n\t\t\t\t\twhereFragment,\r\n\t\t\t\t\tfragment,\r\n\t\t\t\t\thqlSqlWalker\r\n\t\t\t);\r\n\r\n\t\t\tlog.Debug(\"Using processed WHERE-fragment [\" + fragment.Text + \"]\");\r\n\r\n\t\t\t// Filter conditions need to be inserted before the HQL where condition and the\r\n\t\t\t// theta join node.  This is because org.hibernate.loader.Loader binds the filter parameters first,\r\n\t\t\t// then it binds all the HQL query parameters, see org.hibernate.loader.Loader.processFilterParameters().\r\n\t\t\tif (fragment.FromElement.IsFilter || fragment.HasFilterCondition)\r\n\t\t\t{\r\n\t\t\t\tif (_filters == null)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Find or create the WHERE clause\r\n\t\t\t\t\tIASTNode where = (IASTNode) query.WhereClause;\r\n\t\t\t\t\t// Create a new FILTERS node as a parent of all filters\r\n\t\t\t\t\t_filters = Create(HqlSqlWalker.FILTERS, \"{filter conditions}\");\r\n\t\t\t\t\t// Put the FILTERS node before the HQL condition and theta joins\r\n\t\t\t\t\twhere.InsertChild(0, _filters);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// add the current fragment to the FILTERS node\r\n\t\t\t\t_filters.AddChild(fragment);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (_thetaJoins == null)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Find or create the WHERE clause\r\n\t\t\t\t\tIASTNode where = (IASTNode) query.WhereClause;\r\n\r\n\t\t\t\t\t// Create a new THETA_JOINS node as a parent of all filters\r\n\t\t\t\t\t_thetaJoins = Create(HqlSqlWalker.THETA_JOINS, \"{theta joins}\");\r\n\r\n\t\t\t\t\t// Put the THETA_JOINS node before the HQL condition, after the filters.\r\n\t\t\t\t\tif (_filters == null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhere.InsertChild(0, _thetaJoins);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n                        _filters.AddSibling(_thetaJoins);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// add the current fragment to the THETA_JOINS node\r\n\t\t\t\t_thetaJoins.AddChild(fragment);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Util\\SyntheticAndFactory.cs",
      "SourceLine": 30
    }
  ],
  [
    {
      "TypeIdentifier": "QuerySplitter",
      "MethodIdentifier": "ConcreteQueries",
      "SourcesSample": "public static string[] ConcreteQueries(string query, ISessionFactoryImplementor factory)\r\n\t\t{\r\n\t\t\t//scan the query string for class names appearing in the from clause and replace\r\n\t\t\t//with all persistent implementors of the class/interface, returning multiple\r\n\t\t\t//query strings (make sure we don't pick up a class in the select clause!)\r\n\r\n\t\t\t//TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....\r\n\r\n\t\t\tSessionFactoryHelper helper = new SessionFactoryHelper(factory);\r\n\r\n\t\t\tstring[] tokens = StringHelper.Split(StringHelper.WhiteSpace + \"(),\", query, true);\r\n\t\t\tif (tokens.Length == 0)\r\n\t\t\t{\r\n\t\t\t\treturn new String[] {query}; // just especially for the trivial collection filter\r\n\t\t\t}\r\n\t\t\tvar placeholders = new List<object>();\r\n\t\t\tvar replacements = new List<object>();\r\n\t\t\tStringBuilder templateQuery = new StringBuilder(40);\r\n\t\t\tint count = 0;\r\n\t\t\tstring last = null;\r\n\t\t\tint nextIndex = 0;\r\n\t\t\tstring next = null;\r\n\r\n\t\t\ttemplateQuery.Append(tokens[0]);\r\n\t\t\tbool isSelectClause = StringHelper.EqualsCaseInsensitive(\"select\", tokens[0]);\r\n\r\n\t\t\tfor (int i = 1; i < tokens.Length; i++)\r\n\t\t\t{\r\n\t\t\t\t//update last non-whitespace token, if necessary\r\n\t\t\t\tif (!ParserHelper.IsWhitespace(tokens[i - 1]))\r\n\t\t\t\t{\r\n\t\t\t\t\tlast = tokens[i - 1].ToLowerInvariant();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// select-range is terminated by declaration of \"from\"\r\n\t\t\t\tisSelectClause = !StringHelper.EqualsCaseInsensitive(\"from\", tokens[i]);\r\n\r\n\t\t\t\tstring token = tokens[i];\r\n\t\t\t\tif (!ParserHelper.IsWhitespace(token) || last == null)\r\n\t\t\t\t{\r\n\t\t\t\t\t//scan for next non-whitespace token\r\n\t\t\t\t\tif (nextIndex <= i)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (nextIndex = i + 1; nextIndex < tokens.Length; nextIndex++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tnext = tokens[nextIndex].ToLowerInvariant();\r\n\t\t\t\t\t\t\tif (!ParserHelper.IsWhitespace(next))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// TODO H3.2 Different behavior\r\n\t\t\t\t\t// NHb: This block is not an exactly port from H3.2 but a port from previous implementation of QueryTranslator\r\n\t\t\t\t\tif (((last != null && beforeClassTokens.Contains(last)) &&\r\n\t\t\t\t\t\t (next == null || !notAfterClassTokens.Contains(next))) ||\r\n\t\t\t\t\t\tParserHelper.EntityClass.Equals(last))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSystem.Type clazz = helper.GetImportedClass(token);\r\n\t\t\t\t\t\tif (clazz != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tstring[] implementors = factory.GetImplementors(clazz.FullName);\r\n\t\t\t\t\t\t\tstring placeholder = \"$clazz\" + count++ + \"$\";\r\n\r\n\t\t\t\t\t\t\tif (implementors != null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tplaceholders.Add(placeholder);\r\n\t\t\t\t\t\t\t\treplacements.Add(implementors);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttoken = placeholder; //Note this!!\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ttemplateQuery.Append(token);\r\n\t\t\t}\r\n\t\t\tstring[] results =\r\n\t\t\t\tStringHelper.Multiply(templateQuery.ToString(), placeholders.GetEnumerator(), replacements.GetEnumerator());\r\n\t\t\tif (results.Length == 0)\r\n\t\t\t{\r\n\t\t\t\tlog.Warn(\"no persistent classes found for query class: \" + query);\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\QuerySplitter.cs",
      "SourceLine": 38
    }
  ],
  [
    {
      "TypeIdentifier": "QuerySelect",
      "MethodIdentifier": "ToQuerySqlString",
      "SourcesSample": "public SqlString ToQuerySqlString()\r\n\t\t{\r\n\t\t\tvar builder = new SqlStringBuilder();\r\n\r\n\t\t\tbuilder.Add(\"select \");\r\n\r\n\t\t\tif (distinct)\r\n\t\t\t{\r\n\t\t\t\tbuilder.Add(\"distinct \");\r\n\t\t\t}\r\n\r\n\t\t\tSqlString from = joins.ToFromFragmentString;\r\n\t\t\tif (from.StartsWithCaseInsensitive(\",\"))\r\n\t\t\t{\r\n\t\t\t\tfrom = from.Substring(1);\r\n\t\t\t}\r\n\t\t\telse if (from.StartsWithCaseInsensitive(\" inner join\"))\r\n\t\t\t{\r\n\t\t\t\tfrom = from.Substring(11);\r\n\t\t\t}\r\n\r\n\t\t\tbuilder.Add(selectBuilder.ToSqlString())\r\n\t\t\t\t.Add(\" from\")\r\n\t\t\t\t.Add(from);\r\n\r\n\t\t\tSqlString part1 = joins.ToWhereFragmentString.Trim();\r\n\t\t\tSqlString part2 = whereBuilder.ToSqlString();\r\n\t\t\tbool hasPart1 = part1.Count > 0;\r\n\t\t\tbool hasPart2 = part2.Count > 0;\r\n\r\n\t\t\tif (hasPart1 || hasPart2)\r\n\t\t\t{\r\n\t\t\t\tbuilder.Add(\" where \");\r\n\t\t\t}\r\n\t\t\tif (hasPart1)\r\n\t\t\t{\r\n\t\t\t\tbuilder.Add(part1.Substring(4));\r\n\t\t\t}\r\n\t\t\tif (hasPart2)\r\n\t\t\t{\r\n\t\t\t\tif (hasPart1)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuilder.Add(\" and (\");\r\n\t\t\t\t}\r\n\t\t\t\tbuilder.Add(part2);\r\n\t\t\t\tif (hasPart1)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuilder.Add(\")\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (groupBy.Count > 0)\r\n\t\t\t{\r\n\t\t\t\tbuilder.Add(\" group by \").Add(groupBy.ToSqlString());\r\n\t\t\t}\r\n\t\t\tif (having.Count > 0)\r\n\t\t\t{\r\n\t\t\t\tbuilder.Add(\" having \").Add(having.ToSqlString());\r\n\t\t\t}\r\n\t\t\tif (orderBy.Count > 0)\r\n\t\t\t{\r\n\t\t\t\tbuilder.Add(\" order by \").Add(orderBy.ToSqlString());\r\n\t\t\t}\r\n\t\t\treturn builder.ToSqlString();\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\QuerySelect.cs",
      "SourceLine": 205
    }
  ],
  [
    {
      "TypeIdentifier": "SqlString",
      "MethodIdentifier": "Equals",
      "SourcesSample": "public override bool Equals(object obj)\r\n\t\t{\r\n\t\t\tvar other = obj as SqlString;\r\n\t\t\tif (other == null) return false;\r\n\t\t\tif (other == this) return true;\r\n\r\n\t\t\t// Exit early if the length or number of parts differ - cannot be equal then.\r\n\t\t\tif (_length != other._length) return false;\r\n\t\t\tif (_lastPartIndex - _firstPartIndex != other._lastPartIndex - other._firstPartIndex) return false;\r\n\t\t\tif (_parameters.Count != other._parameters.Count) return false;\r\n\r\n\t\t\tusing (var partEnum = this.GetEnumerator())\r\n\t\t\tusing (var otherPartEnum = other.GetEnumerator())\r\n\t\t\t{\r\n\t\t\t\twhile (partEnum.MoveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!otherPartEnum.MoveNext()) return false;\r\n\t\t\t\t\tif (!Equals(partEnum.Current, otherPartEnum.Current)) return false;\r\n\t\t\t\t}\r\n\t\t\t\tif (otherPartEnum.MoveNext()) return false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\SqlString.cs",
      "SourceLine": 875
    }
  ],
  [
    {
      "TypeIdentifier": "TypeFactory",
      "MethodIdentifier": "HeuristicType",
      "SourcesSample": "public static IType HeuristicType(string typeName, IDictionary<string, string> parameters, int? length)\r\n\t\t{\r\n\t\t\tIType type = Basic(typeName);\r\n\r\n\t\t\tif (type != null)\r\n\t\t\t\treturn type;\r\n\t\t\t\r\n\t\t\tstring[] parsedTypeName;\r\n\t\t\tTypeClassification typeClassification = GetTypeClassification(typeName);\r\n\t\t\tif (typeClassification == TypeClassification.Length)\r\n\t\t\t\tparsedTypeName = typeName.Split(LengthSplit);\r\n\t\t\telse\r\n\t\t\t\tparsedTypeName = typeClassification == TypeClassification.PrecisionScale ? typeName.Split(PrecisionScaleSplit) : new[] { typeName };\r\n\r\n\r\n\t\t\tSystem.Type typeClass;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\ttypeClass = ReflectHelper.ClassForName(parsedTypeName[0]); //typeName);\r\n\t\t\t}\r\n\t\t\tcatch (Exception)\r\n\t\t\t{\r\n\t\t\t\ttypeClass = null;\r\n\t\t\t}\r\n\r\n\t\t\tif (typeClass == null)\r\n\t\t\t\treturn null;\r\n\t\t\t\t\r\n\t\t\tif (typeof(IType).IsAssignableFrom(typeClass))\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\ttype = (IType) Cfg.Environment.BytecodeProvider.ObjectsFactory.CreateInstance(typeClass);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new MappingException(\"Could not instantiate IType \" + typeClass.Name + \": \" + e, e);\r\n\t\t\t\t}\r\n\t\t\t\tInjectParameters(type, parameters);\r\n\t\t\t\treturn type;\r\n\t\t\t}\r\n\t\t\tif (typeof(ICompositeUserType).IsAssignableFrom(typeClass))\r\n\t\t\t{\r\n\t\t\t\treturn new CompositeCustomType(typeClass, parameters);\r\n\t\t\t}\r\n\t\t\tif (typeof(IUserType).IsAssignableFrom(typeClass))\r\n\t\t\t{\r\n\t\t\t\treturn new CustomType(typeClass, parameters);\r\n\t\t\t}\r\n\t\t\tif (typeof(ILifecycle).IsAssignableFrom(typeClass))\r\n\t\t\t{\r\n\t\t\t\treturn NHibernateUtil.Entity(typeClass);\r\n\t\t\t}\r\n\r\n\t\t\tvar unwrapped = typeClass.UnwrapIfNullable();\r\n\t\t\tif (unwrapped.IsEnum)\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (IType) Activator.CreateInstance(typeof (EnumType<>).MakeGenericType(unwrapped));\r\n\t\t\t\t}\r\n\t\t\t\tcatch (Exception e)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new MappingException(string.Format(\"Can't instantiate enum {0}; The enum can't be empty\", typeClass.FullName), e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!typeClass.IsSerializable)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tif (typeClassification == TypeClassification.Length)\r\n\t\t\t\treturn GetSerializableType(typeClass, Int32.Parse(parsedTypeName[1]));\r\n\t\t\t\r\n\t\t\tif (length.HasValue)\r\n\t\t\t\treturn GetSerializableType(typeClass, length.Value);\r\n\r\n\t\t\treturn GetSerializableType(typeClass);\r\n\t\t}",
      "nStatementSyntax": 12,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Type\\TypeFactory.cs",
      "SourceLine": 465
    }
  ],
  [
    {
      "TypeIdentifier": "ReadOnlyCriteriaQueryTest",
      "MethodIdentifier": "Subselect",
      "SourcesSample": "[Test]\r\n\t\tpublic void Subselect()\r\n\t\t{\r\n\t\t\tStudent gavin = null;\r\n\t\t\tEnrolment enrolment = null;\r\n\t\t\t\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tCourse course = new Course();\r\n\t\t\t\tcourse.CourseCode = \"HIB\";\r\n\t\t\t\tcourse.Description = \"Hibernate Training\";\r\n\t\t\t\ts.Persist(course);\r\n\t\t\r\n\t\t\t\tCourse coursePreferred = new Course();\r\n\t\t\t\tcoursePreferred.CourseCode = \"JBOSS\";\r\n\t\t\t\tcoursePreferred.Description = \"JBoss\";\r\n\t\t\t\ts.Persist(coursePreferred);\r\n\t\t\r\n\t\t\t\tgavin = new Student();\r\n\t\t\t\tgavin.Name = \"Gavin King\";\r\n\t\t\t\tgavin.StudentNumber = 232;\r\n\t\t\t\tgavin.PreferredCourse = coursePreferred;\r\n\t\t\t\ts.Persist(gavin);\r\n\t\t\r\n\t\t\t\tenrolment = new Enrolment();\r\n\t\t\t\tenrolment.Course = course;\r\n\t\t\t\tenrolment.CourseCode = course.CourseCode;\r\n\t\t\t\tenrolment.Semester = 3;\r\n\t\t\t\tenrolment.Year = 1998;\r\n\t\t\t\tenrolment.Student = gavin;\r\n\t\t\t\tenrolment.StudentNumber = gavin.StudentNumber;\r\n\t\t\t\tgavin.Enrolments.Add(enrolment);\r\n\t\t\t\ts.Persist(enrolment);\r\n\t\t\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tDetachedCriteria dc = NHibernate.Criterion.DetachedCriteria.For<Student>()\r\n\t\t\t\t\t.Add(Property.ForName(\"StudentNumber\").Eq(232L))\r\n\t\t\t\t\t.SetProjection(Property.ForName(\"Name\"));\r\n\t\t\t\t\r\n\t\t\t\tgavin = s.CreateCriteria<Student>()\r\n\t\t\t\t\t.Add(Subqueries.Exists(dc))\r\n\t\t\t\t\t.SetReadOnly(true)\r\n\t\t\t\t\t.UniqueResult<Student>();\r\n\t\t\t\t\r\n\t\t\t\tAssert.That(s.DefaultReadOnly, Is.False);\r\n\t\t\t\tAssert.That(s.IsReadOnly(gavin), Is.True);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(gavin.PreferredCourse), Is.False);\r\n\t\t\t\tCheckProxyReadOnly(s, gavin.PreferredCourse, true);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(gavin.PreferredCourse), Is.False);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(gavin.PreferredCourse);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(gavin.PreferredCourse), Is.True);\r\n\t\t\t\tCheckProxyReadOnly(s, gavin.PreferredCourse, true);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(gavin.Enrolments), Is.False);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(gavin.Enrolments);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(gavin.Enrolments), Is.True);\r\n\t\t\t\tAssert.That(gavin.Enrolments.Count, Is.EqualTo(1));\r\n\t\t\t\tIEnumerator<Enrolment> enrolments = gavin.Enrolments.GetEnumerator();\r\n\t\t\t\tenrolments.MoveNext();\r\n\t\t\t\tenrolment = enrolments.Current;\r\n\t\t\t\tAssert.That(s.IsReadOnly(enrolment), Is.False);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Course), Is.False);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Course, false);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(enrolment.Course);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Course, false);\r\n\t\t\t\t\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tDetachedCriteria dc = NHibernate.Criterion.DetachedCriteria.For<Student>(\"st\")\r\n\t\t\t\t\t.Add(Property.ForName(\"st.StudentNumber\").EqProperty(\"e.StudentNumber\"))\r\n\t\t\t\t\t.SetProjection(Property.ForName(\"Name\"));\r\n\t\t\t\t\r\n\t\t\t\tenrolment = s.CreateCriteria<Enrolment>(\"e\")\r\n\t\t\t\t\t.Add(Subqueries.Eq(\"Gavin King\", dc))\r\n\t\t\t\t\t.SetReadOnly(true)\r\n\t\t\t\t\t.UniqueResult<Enrolment>();\r\n\t\t\t\t\r\n\t\t\t\tAssert.That(s.IsReadOnly(enrolment), Is.True);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Course), Is.False);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Course, true);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(enrolment.Course);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Course), Is.True);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Course, true);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Student), Is.False);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Student, true);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(enrolment.Student);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Student), Is.True);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Student, true);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Student.PreferredCourse), Is.False);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Student.PreferredCourse, false);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(enrolment.Student.PreferredCourse);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Student.PreferredCourse), Is.True);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Student.PreferredCourse, false);\r\n\t\t\t\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tDetachedCriteria dc = NHibernate.Criterion.DetachedCriteria.For<Student>(\"st\")\r\n\t\t\t\t\t.CreateCriteria(\"Enrolments\")\r\n\t\t\t\t\t.CreateCriteria(\"Course\")\r\n\t\t\t\t\t.Add(Property.ForName(\"Description\").Eq(\"Hibernate Training\"))\r\n\t\t\t\t\t.SetProjection(Property.ForName(\"st.Name\"));\r\n\t\t\t\t\r\n\t\t\t\tenrolment = s.CreateCriteria<Enrolment>(\"e\")\r\n\t\t\t\t\t.Add(Subqueries.Eq(\"Gavin King\", dc))\r\n\t\t\t\t\t.SetReadOnly(true)\r\n\t\t\t\t\t.UniqueResult<Enrolment>();\r\n\t\t\t\t\r\n\t\t\t\tAssert.That(s.IsReadOnly(enrolment), Is.True);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Course), Is.False);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Course, true);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(enrolment.Course);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Course), Is.True);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Course, true);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Student), Is.False);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Student, true);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(enrolment.Student);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Student), Is.True);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Student, true);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Student.PreferredCourse), Is.False);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Student.PreferredCourse, false);\r\n\t\t\t\t\r\n\t\t\t\tNHibernateUtil.Initialize(enrolment.Student.PreferredCourse);\r\n\t\t\t\tAssert.That(NHibernateUtil.IsInitialized(enrolment.Student.PreferredCourse), Is.True);\r\n\t\t\t\tCheckProxyReadOnly(s, enrolment.Student.PreferredCourse, false);\r\n\t\t\t\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.Delete(gavin.PreferredCourse);\r\n\t\t\t\ts.Delete(gavin);\r\n\t\t\t\ts.Delete(gavin.Enrolments.First().Course);\r\n\t\t\t\ts.Delete(gavin.Enrolments.First());\r\n\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\ReadOnly\\ReadOnlyCriteriaQueryTest.cs",
      "SourceLine": 891
    }
  ],
  [
    {
      "TypeIdentifier": "IdentityInsertWithStoredProcsTest",
      "MethodIdentifier": "InsertUsesStoredProc",
      "SourcesSample": "[Test]\r\n\t\tpublic void InsertUsesStoredProc()\r\n\t\t{\r\n\t\t\tusing (var spy = new SqlLogSpy())\r\n\t\t\t{\r\n\t\t\t\tOrganization ifa;\r\n\t\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\tifa = new Organization(\"IFA\");\r\n\t\t\t\t\ts.Save(ifa);\r\n\t\t\t\t\tt.Commit();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tAssert.AreEqual(1, spy.Appender.GetEvents().Length, \"Num loggedEvents\");\r\n\t\t\t\tAssert.AreEqual(1, ifa.Id, \"ifa.Id\");\r\n\t\t\t\tAssert.AreEqual(GetExpectedInsertOrgLogStatement(\"IFA\"), spy.Appender.GetEvents()[0].MessageObject, \"Message 1\");\r\n\t\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\ts.Delete(ifa);\r\n\t\t\t\t\tt.Commit();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tusing (var spy = new SqlLogSpy())\r\n\t\t\t{\r\n\t\t\t\tOrganization efa;\r\n\t\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\tefa = new Organization(\"EFA\");\r\n\t\t\t\t\ts.Save(efa);\r\n\t\t\t\t\tt.Commit();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tAssert.AreEqual(1, spy.Appender.GetEvents().Length, \"Num loggedEvents\");\r\n\t\t\t\tAssert.AreEqual(2, efa.Id, \"efa.Id\");\r\n\t\t\t\tAssert.AreEqual(GetExpectedInsertOrgLogStatement(\"EFA\"), spy.Appender.GetEvents()[0].MessageObject, \"Message 2\");\r\n\t\t\t\tusing (ISession s = OpenSession())\r\n\t\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t\t{\r\n\t\t\t\t\ts.Delete(efa);\r\n\t\t\t\t\tt.Commit();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\SqlTest\\Identity\\IdentityInsertWithStoredProcsTest.cs",
      "SourceLine": 25
    }
  ],
  [
    {
      "TypeIdentifier": "UnionSubclassFixture",
      "MethodIdentifier": "UnionSubclass",
      "SourcesSample": "[Test]\r\n\t\tpublic void UnionSubclass()\r\n\t\t{\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\tLocation mel = new Location(\"Melbourne, Australia\");\r\n\t\t\t\tLocation atl = new Location(\"Atlanta, GA\");\r\n\t\t\t\tLocation mars = new Location(\"Mars\");\r\n\t\t\t\ts.Save(mel);\r\n\t\t\t\ts.Save(atl);\r\n\t\t\t\ts.Save(mars);\r\n\r\n\t\t\t\tHuman gavin = new Human();\r\n\t\t\t\tgavin.Identity = \"gavin\";\r\n\t\t\t\tgavin.Sex = 'M';\r\n\t\t\t\tgavin.Location = mel;\r\n\t\t\t\tmel.AddBeing(gavin);\r\n\r\n\t\t\t\tAlien x23y4 = new Alien();\r\n\t\t\t\tx23y4.Identity = \"x23y4$$hu%3\";\r\n\t\t\t\tx23y4.Location = mars;\r\n\t\t\t\tx23y4.Species = \"martian\";\r\n\t\t\t\tmars.AddBeing(x23y4);\r\n\r\n\t\t\t\tHive hive = new Hive();\r\n\t\t\t\thive.Location = mars;\r\n\t\t\t\thive.Members.Add(x23y4);\r\n\t\t\t\tx23y4.Hive = hive;\r\n\t\t\t\ts.Persist(hive);\r\n\r\n\t\t\t\tAssert.AreEqual(2, s.CreateQuery(\"from Being\").List().Count);\r\n\t\t\t\tAssert.AreEqual(1, s.CreateQuery(\"from Being b where b.class = Alien\").List().Count);\r\n\t\t\t\tAssert.AreEqual(1, s.CreateQuery(\"from Alien\").List().Count);\r\n\t\t\t\ts.Clear();\r\n\r\n\t\t\t\tIList<Being> beings = s.CreateQuery(\"from Being b left join fetch b.location\").List<Being>();\r\n\t\t\t\tforeach (Being b in beings)\r\n\t\t\t\t{\r\n\t\t\t\t\tAssert.IsTrue(NHibernateUtil.IsInitialized(b.Location));\r\n\t\t\t\t\tAssert.IsNotNull(b.Location.Name);\r\n\t\t\t\t\tAssert.IsNotNull(b.Identity);\r\n\t\t\t\t\tAssert.IsNotNull(b.Species);\r\n\t\t\t\t}\r\n\t\t\t\tAssert.AreEqual(2, beings.Count);\r\n\t\t\t\ts.Clear();\r\n\r\n\t\t\t\tbeings = s.CreateQuery(\"from Being\").List<Being>();\r\n\t\t\t\tforeach (Being b in beings)\r\n\t\t\t\t{\r\n\t\t\t\t\tAssert.IsFalse(NHibernateUtil.IsInitialized(b.Location));\r\n\t\t\t\t\tAssert.IsNotNull(b.Location.Name);\r\n\t\t\t\t\tAssert.IsNotNull(b.Identity);\r\n\t\t\t\t\tAssert.IsNotNull(b.Species);\r\n\t\t\t\t}\r\n\t\t\t\tAssert.AreEqual(2, beings.Count);\r\n\t\t\t\ts.Clear();\r\n\r\n\t\t\t\tIList<Location> locations = s.CreateQuery(\"from Location\").List<Location>();\r\n\t\t\t\tint count = 0;\r\n\t\t\t\tforeach (Location l in locations)\r\n\t\t\t\t{\r\n\t\t\t\t\tAssert.IsNotNull(l.Name);\r\n\t\t\t\t\tforeach (Being o in l.Beings)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\tAssert.AreSame(o.Location, l);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tAssert.AreEqual(2, count);\r\n\t\t\t\tAssert.AreEqual(3, locations.Count);\r\n\t\t\t\ts.Clear();\r\n\r\n\t\t\t\tlocations = s.CreateQuery(\"from Location loc left join fetch loc.beings\").List<Location>();\r\n\t\t\t\tcount = 0;\r\n\t\t\t\tforeach (Location l in locations)\r\n\t\t\t\t{\r\n\t\t\t\t\tAssert.IsNotNull(l.Name);\r\n\t\t\t\t\tforeach (Being o in l.Beings)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\tAssert.AreSame(o.Location, l);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tAssert.AreEqual(2, count);\r\n\t\t\t\tAssert.AreEqual(3, locations.Count);\r\n\t\t\t\ts.Clear();\r\n\r\n\t\t\t\tgavin = s.Get<Human>(gavin.Id);\r\n\t\t\t\tatl = s.Get<Location>(atl.Id);\r\n\r\n\t\t\t\tatl.AddBeing(gavin);\r\n\t\t\t\tAssert.AreEqual(1, s.CreateQuery(\"from Human h where h.location.name like '%GA'\").List().Count);\r\n\t\t\t\ts.Delete(gavin);\r\n\t\t\t\tx23y4 = (Alien) s.CreateCriteria(typeof (Alien)).UniqueResult();\r\n\t\t\t\ts.Delete(x23y4.Hive);\r\n\t\t\t\tAssert.AreEqual(0, s.CreateQuery(\"from Being\").List().Count);\r\n\t\t\t\tt.Commit();\r\n\t\t\t\ts.Close();\r\n\t\t\t}\r\n\t\t\tusing (ISession s = OpenSession())\r\n\t\t\tusing (ITransaction t = s.BeginTransaction())\r\n\t\t\t{\r\n\t\t\t\ts.Delete(\"from Location\");\r\n\t\t\t\tt.Commit();\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate.Test\\Unionsubclass\\UnionSubclassFixture.cs",
      "SourceLine": 266
    }
  ],
  [
    {
      "TypeIdentifier": "Dialect",
      "MethodIdentifier": "ExtractColumnOrAliasNames",
      "SourcesSample": "internal static void ExtractColumnOrAliasNames(SqlString select, out List<SqlString> columnsOrAliases, out Dictionary<SqlString, SqlString> aliasToColumn, out Dictionary<SqlString, SqlString> columnToAlias)\r\n\t\t{\r\n\t\t\tcolumnsOrAliases = new List<SqlString>();\r\n\t\t\taliasToColumn = new Dictionary<SqlString, SqlString>();\r\n\t\t\tcolumnToAlias = new Dictionary<SqlString, SqlString>();\r\n\r\n\t\t\tvar tokens = new QuotedAndParenthesisStringTokenizer(select).GetTokens();\r\n\t\t\tint index = 0;\r\n\t\t\twhile (index < tokens.Count)\r\n\t\t\t{\r\n\t\t\t\tvar token = tokens[index];\r\n\r\n\t\t\t\tint nextTokenIndex = index += 1;\r\n\r\n\t\t\t\tif (token.StartsWithCaseInsensitive(\"select\"))\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tif (token.StartsWithCaseInsensitive(\"distinct\"))\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tif (token.StartsWithCaseInsensitive(\",\"))\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tif (token.StartsWithCaseInsensitive(\"from\"))\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// handle composite expressions like \"2 * 4 as foo\"\r\n\t\t\t\twhile ((nextTokenIndex < tokens.Count)\r\n\t\t\t\t\t&& (tokens[nextTokenIndex].StartsWithCaseInsensitive(\"as\") == false\r\n\t\t\t\t\t&& tokens[nextTokenIndex].StartsWithCaseInsensitive(\"from\") == false\r\n\t\t\t\t\t&& tokens[nextTokenIndex].StartsWithCaseInsensitive(\",\") == false))\r\n\t\t\t\t{\r\n\t\t\t\t\tSqlString nextToken = tokens[nextTokenIndex];\r\n\t\t\t\t\ttoken = token.Append(nextToken);\r\n\t\t\t\t\tnextTokenIndex = index += 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if there is no alias, the token and the alias will be the same\r\n\t\t\t\tSqlString alias = token;\r\n\r\n\t\t\t\tbool isFunctionCallOrQuotedString = token.IndexOfCaseInsensitive(\"'\") >= 0 || token.IndexOfCaseInsensitive(\"(\") >= 0;\r\n\r\n\t\t\t\t// this is heuristic guess, if the expression contains ' or (, it is probably\r\n\t\t\t\t// not appropriate to just slice parts off of it\r\n\t\t\t\tif (isFunctionCallOrQuotedString == false)\r\n\t\t\t\t{\r\n\t\t\t\t\t// its a simple column reference, so lets set the alias to the\r\n\t\t\t\t\t// column name minus the table qualifier if it exists\r\n\t\t\t\t\tint dot = token.IndexOfCaseInsensitive(\".\");\r\n\t\t\t\t\tif (dot != -1)\r\n\t\t\t\t\t\talias = token.Substring(dot + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// notice! we are checking here the existence of \"as\" \"alias\", two\r\n\t\t\t\t// tokens from the current one\r\n\t\t\t\tif (nextTokenIndex + 1 < tokens.Count)\r\n\t\t\t\t{\r\n\t\t\t\t\tSqlString nextToken = tokens[nextTokenIndex];\r\n\t\t\t\t\tif (nextToken.IndexOfCaseInsensitive(\"as\") >= 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSqlString tokenAfterNext = tokens[nextTokenIndex + 1];\r\n\t\t\t\t\t\talias = tokenAfterNext;\r\n\t\t\t\t\t\tindex += 2; //skip the \"as\" and the alias\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolumnsOrAliases.Add(alias);\r\n\t\t\t\taliasToColumn[alias] = token;\r\n\t\t\t\tcolumnToAlias[token] = alias;\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Dialect\\Dialect.cs",
      "SourceLine": 1144
    }
  ],
  [
    {
      "TypeIdentifier": "IdentNode",
      "MethodIdentifier": "Resolve",
      "SourcesSample": "public override void Resolve(bool generateJoin, bool implicitJoin, string classAlias, IASTNode parent)\r\n\t\t{\r\n\t\t\tif (!IsResolved)\r\n\t\t\t{\r\n\t\t\t\tif (Walker.CurrentFromClause.IsFromElementAlias(Text))\r\n\t\t\t\t{\r\n\t\t\t\t\tif (ResolveAsAlias())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tIsResolved = true;\r\n\t\t\t\t\t\t// We represent a from-clause alias\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (parent != null && parent.Type == HqlSqlWalker.DOT)\r\n\t\t\t\t{\r\n\t\t\t\t\tDotNode dot = (DotNode)parent;\r\n\t\t\t\t\tif (parent.GetFirstChild() == this)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (ResolveAsNakedComponentPropertyRefLhs(dot))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// we are the LHS of the DOT representing a naked comp-prop-ref\r\n\t\t\t\t\t\t\tIsResolved = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (ResolveAsNakedComponentPropertyRefRhs(dot))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// we are the RHS of the DOT representing a naked comp-prop-ref\r\n\t\t\t\t\t\t\tIsResolved = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tint result = ResolveAsNakedPropertyRef();\r\n\t\t\t\t\tif (result == PropertyRef)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// we represent a naked (simple) prop-ref\r\n\t\t\t\t\t\tIsResolved = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (result == ComponentRef)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// EARLY EXIT!!!  return so the resolve call explicitly coming from DotNode can\r\n\t\t\t\t\t\t// resolve this...\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if we are still not resolved, we might represent a constant.\r\n\t\t\t\t//      needed to add this here because the allowance of\r\n\t\t\t\t//      naked-prop-refs in the grammar collides with the\r\n\t\t\t\t//      definition of literals/constants (\"nondeterminism\").\r\n\t\t\t\t//      TODO: cleanup the grammar so that \"processConstants\" is always just handled from here\r\n\t\t\t\tif (!IsResolved)\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tWalker.LiteralProcessor.ProcessConstant(this, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (Exception)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// just ignore it for now, it'll get resolved later...\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Hql\\Ast\\ANTLR\\Tree\\IdentNode.cs",
      "SourceLine": 110
    }
  ],
  [
    {
      "TypeIdentifier": "Loader",
      "MethodIdentifier": "InitializeEntitiesAndCollections",
      "SourcesSample": "internal void InitializeEntitiesAndCollections(IList hydratedObjects, object resultSetId, ISessionImplementor session, bool readOnly)\r\n\t\t{\r\n\t\t\tICollectionPersister[] collectionPersisters = CollectionPersisters;\r\n\t\t\tif (collectionPersisters != null)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < collectionPersisters.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (collectionPersisters[i].IsArray)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//for arrays, we should end the collection load before resolving\r\n\t\t\t\t\t\t//the entities, since the actual array instances are not instantiated\r\n\t\t\t\t\t\t//during loading\r\n\t\t\t\t\t\t//TODO: or we could do this polymorphically, and have two\r\n\t\t\t\t\t\t//      different operations implemented differently for arrays\r\n\t\t\t\t\t\tEndCollectionLoad(resultSetId, session, collectionPersisters[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//important: reuse the same event instances for performance!\r\n\t\t\tPreLoadEvent pre;\r\n\t\t\tPostLoadEvent post;\r\n\t\t\tif (session.IsEventSource)\r\n\t\t\t{\r\n\t\t\t\tvar eventSourceSession = (IEventSource)session;\r\n\t\t\t\tpre = new PreLoadEvent(eventSourceSession);\r\n\t\t\t\tpost = new PostLoadEvent(eventSourceSession);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tpre = null;\r\n\t\t\t\tpost = null;\r\n\t\t\t}\r\n\r\n\t\t\tif (hydratedObjects != null)\r\n\t\t\t{\r\n\t\t\t\tint hydratedObjectsSize = hydratedObjects.Count;\r\n\r\n\t\t\t\tif (Log.IsDebugEnabled)\r\n\t\t\t\t{\r\n\t\t\t\t\tLog.Debug(string.Format(\"total objects hydrated: {0}\", hydratedObjectsSize));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (int i = 0; i < hydratedObjectsSize; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tTwoPhaseLoad.InitializeEntity(hydratedObjects[i], readOnly, session, pre, post);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (collectionPersisters != null)\r\n\t\t\t{\r\n\t\t\t\tfor (int i = 0; i < collectionPersisters.Length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!collectionPersisters[i].IsArray)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t//for sets, we should end the collection load after resolving\r\n\t\t\t\t\t\t//the entities, since we might call hashCode() on the elements\r\n\t\t\t\t\t\t//TODO: or we could do this polymorphically, and have two\r\n\t\t\t\t\t\t//      different operations implemented differently for arrays\r\n\t\t\t\t\t\tEndCollectionLoad(resultSetId, session, collectionPersisters[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Loader\\Loader.cs",
      "SourceLine": 558
    }
  ],
  [
    {
      "TypeIdentifier": "BasicCollectionPersister",
      "MethodIdentifier": "DoUpdateRows",
      "SourcesSample": "protected override int DoUpdateRows(object id, IPersistentCollection collection, ISessionImplementor session)\r\n\t\t{\r\n\t\t\tif (ArrayHelper.IsAllFalse(elementColumnIsSettable)) return 0;\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tIDbCommand st = null;\r\n\t\t\t\tIExpectation expectation = Expectations.AppropriateExpectation(UpdateCheckStyle);\r\n\t\t\t\t//bool callable = UpdateCallable;\r\n\t\t\t\tbool useBatch = expectation.CanBeBatched;\r\n\t\t\t\tIEnumerable entries = collection.Entries(this);\r\n\t\t\t\tint i = 0;\r\n\t\t\t\tint count = 0;\r\n\t\t\t\tforeach (object entry in entries)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (collection.NeedsUpdating(entry, i, ElementType))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tint offset = 0;\r\n\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (st == null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tst =\r\n\t\t\t\t\t\t\t\t\tsession.Batcher.PrepareBatchCommand(SqlUpdateRowString.CommandType, SqlUpdateRowString.Text,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSqlUpdateRowString.ParameterTypes);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tst =\r\n\t\t\t\t\t\t\t\tsession.Batcher.PrepareCommand(SqlUpdateRowString.CommandType, SqlUpdateRowString.Text,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   SqlUpdateRowString.ParameterTypes);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t//offset += expectation.Prepare(st, Factory.ConnectionProvider.Driver);\r\n\r\n\t\t\t\t\t\t\tint loc = WriteElement(st, collection.GetElement(entry), offset, session);\r\n\t\t\t\t\t\t\tif (hasIdentifier)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tWriteIdentifier(st, collection.GetIdentifier(entry, i), loc, session);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tloc = WriteKey(st, id, loc, session);\r\n\t\t\t\t\t\t\t\tif (HasIndex && !indexContainsFormula)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tWriteIndexToWhere(st, collection.GetIndex(entry, i, this), loc, session);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tWriteElementToWhere(st, collection.GetSnapshotElement(entry, i), loc, session);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tsession.Batcher.AddToBatch(expectation);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\texpectation.VerifyOutcomeNonBatched(session.Batcher.ExecuteNonQuery(st), st);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch (Exception e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (useBatch)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tsession.Batcher.AbortBatch(e);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthrow;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (!useBatch)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tsession.Batcher.CloseCommand(st, null);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t\treturn count;\r\n\t\t\t}\r\n\t\t\tcatch (DbException sqle)\r\n\t\t\t{\r\n\t\t\t\tthrow ADOExceptionHelper.Convert(SQLExceptionConverter, sqle,\r\n\t\t\t\t\t\t\t\t\t\t\t\t \"could not update collection rows: \" + MessageHelper.InfoString(this, id),\r\n\t\t\t\t\t\t\t\t\t\t\t\t SqlUpdateRowString.Text);\r\n\t\t\t}\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\Persister\\Collection\\BasicCollectionPersister.cs",
      "SourceLine": 158
    }
  ],
  [
    {
      "TypeIdentifier": "InFragment",
      "MethodIdentifier": "ToFragmentString",
      "SourcesSample": "public SqlString ToFragmentString()\r\n\t\t{\r\n\t\t\tvar buf = new SqlStringBuilder(values.Count * 5);\r\n\t\t\tbuf.Add(columnName);\r\n\r\n\t\t\tif (values.Count > 1)\r\n\t\t\t{\r\n\t\t\t\t// is a comma needed before the value that's about to be added - it\r\n\t\t\t\t// defaults to false because we don't need a comma right away.\r\n\t\t\t\tbool commaNeeded = false;\r\n\r\n\t\t\t\t// if a \"null\" is in the list of values then we need to manipulate\r\n\t\t\t\t// the SqlString a little bit more at the end.\r\n\t\t\t\tbool allowNull = false;\r\n\r\n\t\t\t\tbuf.Add(\" in (\");\r\n\t\t\t\tfor (int i = 0; i < values.Count; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tobject value = values[i];\r\n\t\t\t\t\tif (Null.Equals(value))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tallowNull = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (NotNull.Equals(value))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new NotSupportedException(string.Format(\"not null makes no sense for in expression (column:{0})\",columnName));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (commaNeeded)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbuf.Add(StringHelper.CommaSpace);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (value is Parameter)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbuf.Add((Parameter) value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tbuf.Add((string) value);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// a value has been added into the IN clause so the next\r\n\t\t\t\t\t\t// one needs a comma before it\r\n\t\t\t\t\t\tcommaNeeded = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbuf.Add(StringHelper.ClosedParen);\r\n\r\n\t\t\t\t// if \"null\" is in the list of values then add to the beginning of the\r\n\t\t\t\t// SqlString \"is null or [column] (\" + [rest of sqlstring here] + \")\"\r\n\t\t\t\tif (allowNull)\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Insert(0, \" is null or \").Insert(0, columnName).Insert(0, StringHelper.OpenParen).Add(StringHelper.ClosedParen);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (values.Count == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new NotSupportedException(string.Format(\"Attempting to parse a null value into an sql string (column:{0}).\", columnName));\r\n\t\t\t\t}\r\n\t\t\t\tobject value = values[0];\r\n\t\t\t\tif (Null.Equals(value))\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Add(\" is null\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (NotNull.Equals(value))\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Add(\" is not null \");\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbuf.Add(\"=\").AddObject(values[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn buf.ToSqlString();\r\n\t\t}",
      "nStatementSyntax": 11,
      "FilePath": "D:\\temp\\nhibernate-core-master\\src\\NHibernate\\SqlCommand\\InFragment.cs",
      "SourceLine": 47
    }
  ]
]